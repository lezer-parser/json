{"version":3,"sources":["node_modules/@codemirror/next/text/dist/index.es.js","../src/tree.ts","node_modules/@codemirror/next/state/dist/index.es.js","node_modules/style-mod/src/style-mod.js","node_modules/@codemirror/next/rangeset/dist/index.es.js","node_modules/@codemirror/next/view/dist/index.es.js","node_modules/@codemirror/next/highlight/dist/index.es.js","node_modules/@codemirror/next/gutter/dist/index.es.js","node_modules/w3c-keyname/index.es.js","node_modules/@codemirror/next/keymap/dist/index.es.js","node_modules/@codemirror/next/commands/dist/index.es.js","node_modules/@codemirror/next/syntax/dist/index.es.js","node_modules/@codemirror/next/matchbrackets/dist/index.es.js","node_modules/@codemirror/next/closebrackets/dist/index.es.js","node_modules/@codemirror/next/special-chars/dist/index.es.js","node_modules/@codemirror/next/fold/dist/index.es.js","node_modules/lezer-tree/dist/tree.es.js","node_modules/process/browser.js","../src/parse.ts","../../node_modules/tslib/tslib.es6.js","../src/stack.ts","../src/token.ts","../src/decode.ts","dist/index.js","demo.js"],"names":["extendingChars","RegExp","_","isExtendingChar","code","test","String","fromCharCode","nonASCIISingleCaseWordChar","wordChar","isWordCharBasic","ch","toUpperCase","toLowerCase","isWordChar","wordChars","source","indexOf","CharType","charType","Space","Word","Other","codePointAt","str","pos","code0","charCodeAt","length","code1","fromCodePoint","minPairCodePoint","countColumn","string","n","tabSize","i","findColumn","col","offset","leftOver","Text","constructor","lineAt","RangeError","lineCache","line","start","end","cacheLine","lineInner","finish","lines","number","replace","from","to","text","replaceInner","textLength","sliceLines","sliceTo","slice","lineSeparator","join","eq","other","eqContent","iter","dir","RawTextCursor","iterRange","PartialTextCursor","iterLines","LineCursor","toString","of","TextLeaf","TextNode","split","lineCachePos","lineCacheSize","children","appendText","sliceText","target","isLine","Line","decomposeStart","push","decomposeEnd","lastLineLength","firstLineLength","part","newLength","cut","after","child","lengthDiff","Math","max","min","endLine","inner","add","lineLengthTo","content","lineLengthFrom","chunkLength","maxLength","minLength","chunked","currentLength","currentChunk","childLength","last","node","flush","first","a","b","iterA","iterB","offA","offB","lineBreak","done","next","strA","value","strB","empty","nodes","offsets","skip","top","pop","len","cursor","limit","charAt","result","LineContent","doc","strings","SelectionRange","anchor","head","map","mapping","mapPos","extend","abs","toJSON","fromJSON","json","groupAt","state","bias","linePos","read","type","lineFrom","lineTo","EditorSelection","ranges","primaryIndex","create","r","primary","asSingle","addRange","range","concat","replaceRange","which","Array","isArray","single","normalized","sort","prev","splice","checkSelection","selection","nextID","Facet","combine","compareInput","compare","isStatic","id","default","define","config","sameArray","static","FacetProvider","compute","deps","get","Error","computeN","every","e","dependencies","facet","dynamicSlot","addresses","getter","idx","multi","depDoc","depSel","depAddrs","dep","tr","reconfigured","values","docChanged","selectionSet","some","addr","ensureAddr","newVal","oldVal","startState","compareArray","dynamicFacetSlot","providers","providerAddrs","p","providerTypes","dynamic","filter","oldAddr","address","changed","dynAddr","getAddr","val","StateField","createF","updateF","compareF","facets","update","provide","prec","provider","field","maybePrec","provideN","slot","oldIdx","Precedence","set","extension","PrecExtension","ext","Fallback","Default","Extend","Override","GroupExtension","group","ExtensionGroup","name","Configuration","replacements","dynamicSlots","staticValues","statusTemplate","staticFacet","resolve","Map","oldState","fields","Object","flatten","f","seen","Set","groupsSeen","has","reduce","status","applying","allowMultipleSelections","v","annotationID","Annotation","languageData","NodeProp","MapMode","ChangeDesc","invertedDesc","mode","Simple","TrackBefore","TrackAfter","Change","invert","apply","desc","ChangeSet","changes","mirror","_changedRanges","getMirror","append","change","appendSet","mapInner","fromI","toI","rec","recoverables","hasMirrors","deleted","endI","touchesRange","diff","partialMapping","PartialMapping","changedRanges","fromA","toA","fromB","toB","ChangedRange","addToSet","ChangeType","me","lenDiff","off","side","Transaction","time","Date","now","docs","_annotations","flags","reconfigureData","annotate","annotation","ensureOpen","splitLines","replaceSelection","forEachRange","sel","newRanges","before","setSelection","scrollIntoView","scrolledIntoView","replaceExtension","replaced","forEach","base","reconfigure","applyTransaction","invertedChanges","preserveGoalColumn","userEvent","addToHistory","DefaultIndentUnit","DefaultTabsize","DefaultSplit","EditorState","cur","require","t","timestamp","joinLines","extensions","reconf","configuration","indentUnit","tree","syntax","getTree","Tree","combineConfig","configs","defaults","key","keys","current","undefined","hasOwnProperty","call","fillConfig","indentation","foldable","sym","random","Symbol","floor","for","COUNT","SET","RULES","global","window","StyleModule","spec","options","style","specificity","newName","selector","generateClasses","className","renderStyle","prototype","mount","root","modules","StyleSet","styleTag","ownerDocument","createElement","insertBefore","firstChild","sheet","reset","j","mod","index","k","insertRule","textContent","output","JSON","stringify","props","prop","local","l","RangeValue","Range","startSide","endSide","point","startMapMode","endMapMode","TrackDel","cmpRange","ChunkSize","BigPointSize","Far","Chunk","maxPoint","findIndex","startAt","arr","lo","hi","mid","between","newPos","newFrom","newTo","mapped","RangeSet","chunkPos","chunk","nextLayer","chunkEnd","size","filterFrom","filterTo","LayerCursor","goto","spill","builder","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","finishInner","chunks","touch","HeapCursor","oldSets","newSets","textDiff","comparator","_a","minPoint","minPointSize","sharedChunks","findSharedChunks","sideA","SpanCursor","sideB","posA","posB","spans","sets","iterator","curTo","pointFrom","span","active","build","chunkStart","lastFrom","lastTo","setMaxPoint","finishChunk","newArrays","inA","shared","layer","gotoInner","forward","heap","heapBubble","childIndex","activeTo","minActive","removeActive","remove","findMinIndex","nextVal","startA","startB","endB","dPos","clipEnd","comparePoint","sameSet","compareRange","outer","array","found","foundPos","nav","navigator","document","userAgent","vendor","platform","documentElement","ie_edge","exec","ie_upto10","ie_11up","ie","gecko","chrome","webkit","browser","mac","ie_version","documentMode","gecko_version","chrome_version","ios","android","safari","webkit_version","getSelection","selectionCollapsed","domSel","collapsed","isCollapsed","rangeCount","getRangeAt","hasSelection","dom","anchorNode","contains","nodeType","parentNode","clientRectsFor","createRange","setEnd","nodeValue","setStart","getClientRects","isEquivalentPosition","targetNode","targetOff","scanFor","domIndex","previousSibling","maxOffset","nodeName","parent","childNodes","windowRect","win","left","right","innerWidth","bottom","innerHeight","ScrollSpace","scrollRectIntoView","rect","defaultView","bounding","body","scrollHeight","clientHeight","scrollWidth","clientWidth","getBoundingClientRect","moveX","moveY","scrollBy","scrollTop","scrollLeft","host","DOMSelection","anchorOffset","focusNode","focusOffset","preventScrollSupported","focusPreventScroll","setActive","focus","stack","preventScroll","elt","DOMPos","precise","none","ContentView","dirty","editorView","overrideDOMText","posAtStart","posBefore","posAtEnd","view","breakAfter","posAfter","coordsAt","sync","reuseDOM","nextSibling","syncNodeInto","rm","localPosFromDOM","lastChild","domBoundsAround","fromStart","toEnd","startDOM","endDOM","markDirty","andParent","markParentsDirty","childList","setParent","setDOM","cmView","rootView","replaceChildren","ignoreMutation","ignoreEvent","event","childCursor","ChildCursor","childPos","findPos","removeChild","combineAttrs","class","attrsEq","keysA","keysB","updateAttrs","attrs","removeAttribute","setAttribute","none$1","InlineView","match","getSide","MaxJoinLen","TextView","tagName","clss","textDOM","createDOM","createTextNode","appendChild","merge","domAtPos","textCoords","x","WidgetView","widget","open","customView","updateDOM","toDOM","contentEditable","rects","CompositionView","WidgetType","_dom","estimatedHeight","_event","BlockType","Decoration","heightRelevant","mark","MarkDecoration","block","PointDecoration","getInclusive","LineDecoration","hasHeight","attributes","isReplace","WidgetRange","WidgetBefore","WidgetAfter","widgetsEq","inclusiveStart","inclusiveEnd","inclusive","MinRangeGap","theme","baseThemeID","buildTheme","styles","parts","themeClass","baseTheme","wrap","position","boxSizing","outline_fallback","outline","display","flexDirection","scroller","alignItems","fontFamily","lineHeight","height","overflowX","margin","flexGrow","minHeight","whiteSpace","padding","caretColor","LineClass","LineView","arguments","prevAttrs","takeDeco","transferDOM","setDeco","elts","toOff","fromOff","dLen","shift","at","addLineDeco","deco","classList","hack","cmIgnore","measureTextSize","totalWidth","width","charWidth","none$2","BlockWidgetView","ContentBuilder","curLine","breakAtStart","textOff","posCovered","getLine","addWidget","buildText","_ranges","take","openStart","openEnd","NullWidget","decorations","wrappingWhiteSpace","HeightOracle","lineWrapping","direction","heightSamples","lineLength","heightChanged","heightForGap","ceil","heightForLine","setDoc","mustRefresh","lineHeights","newHeight","h","refresh","knownHeights","round","MeasuredHeights","heights","more","BlockInfo","detail","QueryType","HeightMap","outdated","setHeight","oracle","_from","_to","decomposeLeft","decomposeRight","applyChanges","oldDoc","ByPosNoHeight","NodeBuilder","updateHeight","HeightMapText","break","brk","HeightMapBranch","HeightMapBlock","blockAt","_height","_doc","_value","_type","forEachLine","_force","measured","widgetHeight","force","HeightMapGap","firstLine","lastLine","ByHeight","unshift","rightTop","rightOffset","subQuery","ByPos","rightStart","balanced","mergeGaps","rebalance","around","relevantWidgetHeight","lineStart","lineEnd","covering","writtenTo","isCovered","addBlock","enterLine","ensureLine","heightRelevantDecoChanges","comp","DecorationComparator","none$3","domEventHandlers","clickAddsSelectionRange","dragMovesSelection","PluginField","scrollMargins","nextPluginID","viewPlugin","ViewPlugin","fromClass","cls","pluginDecorations","PluginInstance","updateFunc","bind","console","error","dummy","takeField","destroy","editorAttributes","contentAttributes","styleModule","phrases","ViewUpdate","transactions","chs","prevState","hasFocus","inputState","notifiedFocused","viewportChanged","focusChanged","visiblePixelRange","paddingTop","parentRect","LineGap","same","gA","gB","draw","wrapping","LineGapWidget","vertical","ViewState","pixelViewport","paddingBottom","heightOracle","heightMap","scrollTo","printing","visibleRanges","viewport","getViewport","lineGaps","ensureLineGaps","lineGapDeco","gap","computeVisibleRanges","newDeco","contentChanges","heightChanges","extendWithRanges","prevHeight","mapViewport","viewportIsCovering","updateLineGaps","mapLineGaps","measure","docView","repeated","getComputedStyle","parseInt","dTop","dBottom","measureVisibleLineHeights","minWidth","scrollPosIntoView","marginTop","Viewport","newTop","newBottom","gaps","structure","viewFrom","viewTo","lineStructure","total","findPosition","gapTo","gapFrom","find","gapSize","findFraction","ratio","editorTop","lineAtHeight","blockAtHeight","dI","rI","dist","counted","none$4","DocView","viewports","compositionDeco","selectionDirty","minWidthFrom","minWidthTo","impreciseAnchor","impreciseHead","contentDOM","updateInner","updateDeco","forceSelection","composing","computeCompositionDeco","prevDeco","findChangedDeco","updateSelection","oldLength","updateChildren","observer","ignore","viewState","breakAtEnd","clearSelectionDirty","activeElement","collapse","removeAllRanges","nearest","domView","posFromDOM","scrollDOM","cancelAnimationFrame","setSelectionDirty","clearSelection","requestAnimationFrame","computeBlockGapDeco","visible","BlockGapWidget","pluginField","mLeft","mRight","mTop","mBottom","margins","MaxNodeHeight","remaining","textNode","nearbyTextNode","cView","topNode","CompositionWidget","DecorationComparator$1","movePos","granularity","action","context","LineContext","modify","nearViewportEnd","moveCharacterSimple","startCoords","coordsAtPos","goal","getGoalColumn","startY","posAtCoords","column","y","moveLineByColumn","moveWord","prepared","prepareForQuery","equiv","atWidget","undoQueryPreparation","otherLine","inline","goalColumns","linesToSync","maybeHide","addForLine","omit","toSync","getdx","getdy","yOverlap","upTop","upBot","domPosAtCoords","closest","closestRect","closestX","closestY","above","below","aboveRect","belowRect","dx","dy","domPosInText","clipX","halfLine","defaultLineHeight","bounced","element","elementFromPoint","caretPositionFromPoint","offsetNode","caretRangeFromPoint","startContainer","startOffset","InputState","lastKeyCode","lastKeyTime","lastSelectionOrigin","lastSelectionTime","registeredEvents","customHandlers","mouseSelection","handlers","handler","addEventListener","eventBelongsToEditor","runCustomHandlers","preventDefault","keyCode","ensureHandlers","setSelectionOrigin","origin","defaultPrevented","startMouseSelection","MouseSelection","move","up","shiftKey","multiple","addsSelectionRange","dragMove","dragMovesSelection$1","startSelection","queryPos","startPos","curPos","startBias","curBias","dragging","isInPrimarySelection","select","clientX","clientY","coords","buttons","removeEventListener","dispatch","metaKey","ctrlKey","altKey","bubbles","brokenClipboardAPI","capturePaste","cssText","setTimeout","doPaste","mustCapture","mods","macCtrl","rangeForClick","updateMouseSelection","startRange","captureCopy","selectionEnd","selectionStart","forceClearComposition","keydown","touchdown","touchmove","mousedown","button","dragstart","dataTransfer","setData","effectAllowed","drop","dropPos","getData","paste","data","clipboardData","copy","clearData","blur","beforeprint","requestMeasure","compositionstart","compositionupdate","compositionend","observeOptions","characterData","subtree","characterDataOldValue","useCharData","DOMObserver","onChange","onScrollChanged","ignoreSelection","charDataQueue","charDataTimeout","scrollTargets","intersection","intersecting","parentCheck","MutationObserver","mutations","onCharData","oldValue","prevValue","onSelectionChange","onScroll","IntersectionObserver","entries","listenForScroll","intersectionRatio","observe","stop","clear","disconnect","takeCharRecords","clearTimeout","takeRecords","records","newSel","typeOver","record","readMutation","childBefore","findChild","childAfter","curView","LineSep","applyDOMChange","bounds","selPoints","selectionPoints","reader","DOMReader","readRange","selectionFromPoints","preferredPos","preferredSide","findDiff","iHead","iAnchor","dispatchKey","minLen","points","findPointBefore","readNode","nextView","isBlockElement","fromView","findPointIn","maxLen","DOMPoint","cancelable","down","KeyboardEvent","dispatchEvent","EditorView","plugins","editorAttrs","contentAttrs","updateState","measureScheduled","measureRequests","mountStyles","ensureGlobalHandler","updatePlugins","redrawn","styleModules","prevSpecs","specs","newPlugins","reused","plugin","measuring","warn","m","write","spellcheck","contenteditable","reverse","phrase","posAtDOM","readMeasured","request","inst","ensureTop","viewportLines","contentHeight","defaultCharacterWidth","textDirection","prefix","given","resizeDebounce","handleResize","querySelectorAll","__test","Inherit","TagSystem","typeNames","typeIDs","types","flagMask","pow","typeShift","subtypes","parentNames","typeID","subID","parents","flag","tags","NodeType","highlighter","styling","Styling","Highlighter","module","tag","defaultTags","styleTags","StyleRule","cache","modSpec","nextCls","rules","known","rule","buildDeco","parsePos","curClass","inherited","iterate","enter","inheritedClass","leave","_t","_s","backTo","defaultHighlighter","invalid","color","keyword","atom","character","regexp","escape","typeName","comment","meta","GutterMarker","_view","elementClass","renderEmptyElements","elementStyle","initialMarkers","updateMarkers","markers","lineMarker","initialSpacer","updateSpacer","activeGutters","gutter","gutters","background","borderRight","flexShrink","overflow","gutterElement","textAlign","unfixGutters","gutterView","fixed","conf","SingleGutterView","updateGutters","contexts","UpdateContext","cx","g","offsetWidth","localMarkers","forLine","elements","newElt","GutterElement","sameMarkers","spacer","prevMarkers","updated","eltClass","cssClass","c","lineNumberMarkers","lineNumberConfig","formatNumber","exists","NumberMarker","lineNumberGutter","ann","others","maxLineNumber","lineNumbers","w3cKeyname","base_1","shift_1","brokenModifierNames","keyName","ignoreKey","normalizeKeyName","alt","ctrl","modifiers","keymap","NormalizedKeymap","isChar","direct","baseName","fromCode","moveSelection","transaction","moveCharLeft","moveCharRight","moveWordLeft","moveWordRight","moveLineUp","moveLineDown","moveLineStart","moveLineEnd","extendSelection","extendCharLeft","extendCharRight","extendWordLeft","extendWordRight","extendLineUp","extendLineDown","extendLineStart","extendLineEnd","selectDocStart","selectDocEnd","selectAll","deleteText","deleteCharBackward","deleteCharForward","space","getIndentation","insertNewlineAndIndent","indent","indentSelection","positions","pcBaseKeymap","macBaseKeymap","os","baseKeymap","indentNodeProp","syntaxIndentation","computeIndentation","ast","scan","scanPos","strategy","indentStrategy","topIndent","IndentContext","delim","delimitedIndent","closing","unit","textAfter","tab","nextTab","lineIndent","search","baseIndent","atBreak","isParent","bracketedAligned","openToken","openLine","skipped","align","units","closed","aligned","flatIndent","continuedIndent","except","matchExcept","foldNodeProp","syntaxFolding","LezerSyntax","parser","setSyntax","SyntaxState","advance","HighlightWorker","upto","ensureTree","timeout","updatedTree","parse","startParse","work","stopParse","docNodeType","languageDataAt","hasNested","nothing","DocStream","cursorPos","stringStart","clip","endTime","takeTree","parsed","forceFinish","requestIdle","requestIdleCallback","callback","cancelIdle","cancelIdleCallback","working","scheduleWork","deadline","timeRemaining","badness","mkMatchProp","deserialize","openNodeProp","closeNodeProp","matchingBracket","nonmatchingBracket","DefaultScanDist","DefaultBrackets","bracketMatchingConfig","afterCursor","brackets","maxScanDistance","matchingMark","nonmatchingMark","bracketMatchingState","matchBrackets","matched","bracketMatchingUnique","bracketMatching","matchingNodes","byProp","matches","sub","matchMarkedBrackets","matchPlainBrackets","_state","_pos","token","matching","firstToken","depth","tokenType","startCh","bracket","startToken","distance","basePos","closeBrackets","closeBracketsBefore","definedClosing","handleBackspace","handleInsertion","tokens","dont","prevChar","nextChar","tok","handleSame","handleOpen","handleClose","close","closeBefore","allowTriple","nodeStart","isTriple","Specials","Names","specialCharConfig","render","specialChars","addSpecialChars","replaceTabs","MozTabSize","specialCharPlugin","styleExt","JoinGap","decorationCache","updateForViewport","closeHoles","vp","getDecorationsFor","TabWidget","SpecialCharWidget","placeHolder","DefaultPlaceholder","ph","custom","title","verticalAlign","foldAnnotation","selectedLines","foldState","folded","fold","unfold","FoldWidget","decoration","foldInside","foldCode","unfoldCode","defaultConfig","placeholderDOM","placeholderText","foldConfig","codeFolding","ignoreEvents","onclick","foldGutterDefaults","openText","closedText","FoldMarker","foldGutter","fullConfig","click","foldPlaceholder","border","borderRadius","DefaultBufferLength","Iteration","doEnter","nextPropID","Number","propObj","NodePropSource","NodeGroup","newTypes","newProps","Subtree","d","resolveAt","partial","cutAt","nextPos","iterInner","cacheRoot","cached","resolveInner","childStart","NodeSubtree","buffer","BufferSubtree","balance","maxBufferLength","BalanceBranchFactor","balanceRange","buildTree","TreeBuffer","childToString","endIndex","cutPoint","newBuffer","Uint16Array","iterChild","iterRev","parentNodesByEnd","startIndex","order","endOrder","nextStart","nextEnd","takeNext","run","lastI","buf","start1","end1","bufferStart","FlatBufferCursor","fork","topID","minRepeatType","takeNode","parentStart","minPos","tagBuffer","findBufferSize","maxSize","minStart","nodeSize","localSkipped","endPos","copyToBuffer","localChildren","localPositions","repeating","outerType","innerType","maxChild","groupFrom","groupStart","only","containsType","cachedSetTimeout","cachedClearTimeout","process","exports","defaultSetTimout","defaultClearTimeout","runTimeout","fun","runClearTimeout","marker","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","Item","noop","nextTick","args","env","argv","version","versions","on","addListener","once","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","defineProperty","lezer","Parser","states","stateData","nodeNames","nodeProps","repeatNodeCount","tokenData","tokenizers","topRules","specializeTable","tokenPrec","raw","jsonSyntax","withProps","Null","PropertyName"],"mappings":"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","file":"demo.41314180.js","sourceRoot":"..","sourcesContent":["let extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u180b-\\u180d\\u18a9\\u200c\\u200d]/;\ntry {\n    extendingChars = new RegExp(\"\\\\p{Grapheme_Extend}\", \"u\");\n}\ncatch (_) { }\n/// Test whether a given code unit (as in, the thing that `charCodeAt`\n/// returns) extends the character before it.\nfunction isExtendingChar(code) {\n    return code >= 768 && (code >= 0xdc00 && code < 0xe000 || extendingChars.test(String.fromCharCode(code)));\n}\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = new RegExp(\"[\\\\p{Alphabetic}_]\", \"u\");\n}\ncatch (_) { }\n// FIXME this doesn't work for astral chars yet (need different calling convention)\nfunction isWordCharBasic(ch) {\n    if (wordChar)\n        return wordChar.test(ch);\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n        (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n}\n/// Test whether the given character is a word character.\nfunction isWordChar(ch, wordChars) {\n    if (!wordChars)\n        return isWordCharBasic(ch);\n    if (wordChars.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch))\n        return true;\n    return wordChars.test(ch);\n}\n/// This is used to group characters into three categoriesword\n/// characters, whitespace, and anything else. It is used, by default,\n/// to do things like selecting by word.\nvar CharType;\n(function (CharType) {\n    CharType[CharType[\"Word\"] = 0] = \"Word\";\n    CharType[CharType[\"Space\"] = 1] = \"Space\";\n    CharType[CharType[\"Other\"] = 2] = \"Other\";\n})(CharType || (CharType = {}));\n/// Determine the character type for a given character.\nfunction charType(ch, wordChars) {\n    // FIXME make this configurable in a better way\n    return /\\s/.test(ch) ? CharType.Space : isWordChar(ch, wordChars) ? CharType.Word : CharType.Other;\n}\n/// Find the code point at the given position in a string (as in the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (code0 < 0xd800 || code0 > 0xdbff || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (code1 < 0xdc00 || code1 > 0xdfff)\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (as in\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint).\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nconst minPairCodePoint = 0x10000;\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nfunction countColumn(string, n, tabSize) {\n    for (let i = 0; i < string.length; i++) {\n        let code = string.charCodeAt(i);\n        if (code == 9)\n            n += tabSize - (n % tabSize);\n        else if (code < 768 || !isExtendingChar(code))\n            n++;\n    }\n    return n;\n}\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nfunction findColumn(string, n, col, tabSize) {\n    for (let i = 0; i < string.length; i++) {\n        let code = string.charCodeAt(i);\n        if (isExtendingChar(code))\n            continue;\n        if (n >= col)\n            return { offset: i, leftOver: 0 };\n        n += code == 9 ? tabSize - (n % tabSize) : 1;\n    }\n    return { offset: string.length, leftOver: col - n };\n}\n\n/// The document tree type.\nclass Text {\n    /// @internal\n    constructor() { }\n    /// Get the line description around the given position.\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        for (let i = 0; i < lineCache.length; i += 2) {\n            if (lineCache[i] != this)\n                continue;\n            let line = lineCache[i + 1];\n            if (line.start <= pos && line.end >= pos)\n                return line;\n        }\n        return cacheLine(this, this.lineInner(pos, false, 1, 0).finish(this));\n    }\n    /// Get the description for the given (1-based) line number.\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        for (let i = 0; i < lineCache.length; i += 2) {\n            if (lineCache[i] != this)\n                continue;\n            let line = lineCache[i + 1];\n            if (line.number == n)\n                return line;\n        }\n        return cacheLine(this, this.lineInner(n, true, 1, 0).finish(this));\n    }\n    /// Replace a range of the text with the given lines. `text` should\n    /// have a length of at least one.\n    replace(from, to, text) {\n        if (text.length == 0)\n            throw new RangeError(\"An inserted range must have at least one line\");\n        return this.replaceInner(from, to, text, textLength(text));\n    }\n    /// Retrieve the lines between the given points.\n    sliceLines(from, to = this.length) {\n        return this.sliceTo(from, to, [\"\"]);\n    }\n    /// Retrieve the text between the given points.\n    slice(from, to, lineSeparator = \"\\n\") {\n        return this.sliceLines(from, to).join(lineSeparator);\n    }\n    /// Test whether this text is equal to another instance.\n    eq(other) { return this == other || eqContent(this, other); }\n    /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /// Iterate over lines in the text, starting at position (_not_ line\n    /// number) `from`. An iterator returned by this combines all text\n    /// on a line into a single string (which may be expensive for very\n    /// long lines), and skips line breaks (its\n    /// [`lineBreak`](#text.TextIterator.lineBreak) property is always\n    /// false).\n    iterLines(from = 0) { return new LineCursor(this, from); }\n    /// Flattens the document into a single string, using `\"\\n\"` as line\n    /// separator.\n    toString() { return this.slice(0, this.length); }\n    /// Create a `Text` instance for the given array of lines.\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        let length = textLength(text);\n        return length < 1024 /* MaxLeaf */ ? new TextLeaf(text, length) : TextNode.from(TextLeaf.split(text, []), length);\n    }\n}\nlet lineCache = [], lineCachePos = -2, lineCacheSize = 12;\nfunction cacheLine(text, line) {\n    lineCachePos = (lineCachePos + 2) % lineCacheSize;\n    lineCache[lineCachePos] = text;\n    lineCache[lineCachePos + 1] = line;\n    return line;\n}\n// Leaves store an array of strings. There are always line breaks\n// between these strings (though not between adjacent leaves). These\n// are limited in length, so that bigger documents are constructed as\n// a tree structure. Long lines will be broken into a number of\n// single-line leaves.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    replaceInner(from, to, text, length) {\n        return Text.of(appendText(this.text, appendText(text, sliceText(this.text, 0, from)), to));\n    }\n    sliceTo(from, to = this.length, target) {\n        return appendText(this.text, target, from, to);\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decomposeStart(to, target) {\n        target.push(new TextLeaf(sliceText(this.text, 0, to), to));\n    }\n    decomposeEnd(from, target) {\n        target.push(new TextLeaf(sliceText(this.text, from), this.length - from));\n    }\n    lastLineLength() { return this.text[this.text.length - 1].length; }\n    firstLineLength() { return this.text[0].length; }\n    static split(text, target) {\n        let part = [], length = -1;\n        for (let line of text) {\n            for (;;) {\n                let newLength = length + line.length + 1;\n                if (newLength < 512 /* BaseLeaf */) {\n                    length = newLength;\n                    part.push(line);\n                    break;\n                }\n                let cut = 512 /* BaseLeaf */ - length - 1, after = line.charCodeAt(cut);\n                if (after >= 0xdc00 && after < 0xe000)\n                    cut++;\n                part.push(line.slice(0, cut));\n                target.push(new TextLeaf(part, 512 /* BaseLeaf */));\n                line = line.slice(cut);\n                length = -1;\n                part = [];\n            }\n        }\n        if (length != -1)\n            target.push(new TextLeaf(part, length));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance itself on\n// changes.\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 1;\n        for (let child of children)\n            this.lines += child.lines - 1;\n    }\n    replaceInner(from, to, text, length) {\n        let lengthDiff = length - (to - from), newLength = this.length + lengthDiff;\n        if (newLength <= 512 /* BaseLeaf */)\n            return new TextLeaf(appendText(this.sliceLines(to), appendText(text, this.sliceTo(0, from, [\"\"]))), newLength);\n        let children;\n        for (let i = 0, pos = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from >= pos && to <= end &&\n                (lengthDiff > 0\n                    ? child.length + lengthDiff < Math.max(newLength >> (3 /* BranchShift */ - 1), 1024 /* MaxLeaf */)\n                    : child.length + lengthDiff > newLength >> (3 /* BranchShift */ + 1))) {\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                children = this.children.slice();\n                children[i] = child.replace(from - pos, to - pos, text);\n                return new TextNode(children, newLength);\n            }\n            else if (end >= from) {\n                // Otherwise, we must build up a new array of children\n                if (children == null)\n                    children = this.children.slice(0, i);\n                if (pos < from) {\n                    if (end == from)\n                        children.push(child);\n                    else\n                        child.decomposeStart(from - pos, children);\n                }\n                if (pos <= from && end >= from)\n                    TextLeaf.split(text, children);\n                if (pos >= to)\n                    children.push(child);\n                else if (end > to)\n                    child.decomposeEnd(to - pos, children);\n            }\n            pos = end;\n        }\n        return children ? TextNode.from(children, newLength) : this;\n    }\n    sliceTo(from, to, target) {\n        let pos = 0;\n        for (let child of this.children) {\n            let end = pos + child.length;\n            if (to > pos && from < end)\n                child.sliceTo(Math.max(0, from - pos), Math.min(child.length, to - pos), target);\n            pos = end;\n        }\n        return target;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) {\n                let inner = child.lineInner(target, isLine, line, offset), add;\n                if (inner.start == offset && (add = this.lineLengthTo(i))) {\n                    inner.start -= add;\n                    inner.content = null;\n                }\n                if (inner.end == end && (add = this.lineLengthFrom(i + 1))) {\n                    inner.end += add;\n                    inner.content = null;\n                }\n                return inner;\n            }\n            offset = end;\n            line = endLine;\n        }\n    }\n    decomposeStart(to, target) {\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end <= to) {\n                target.push(child);\n            }\n            else {\n                if (pos < to)\n                    child.decomposeStart(to - pos, target);\n                break;\n            }\n            pos = end;\n        }\n    }\n    decomposeEnd(from, target) {\n        let pos = 0;\n        for (let child of this.children) {\n            let end = pos + child.length;\n            if (pos >= from)\n                target.push(child);\n            else if (end > from && pos < from)\n                child.decomposeEnd(from - pos, target);\n            pos = end;\n        }\n    }\n    lineLengthTo(to) {\n        let length = 0;\n        for (let i = to - 1; i >= 0; i--) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.lastLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    lastLineLength() { return this.lineLengthTo(this.children.length); }\n    lineLengthFrom(from) {\n        let length = 0;\n        for (let i = from; i < this.children.length; i++) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.firstLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    firstLineLength() { return this.lineLengthFrom(0); }\n    static from(children, length) {\n        if (length < 1024 /* MaxLeaf */) {\n            let text = [\"\"];\n            for (let child of children)\n                child.sliceTo(0, child.length, text);\n            return new TextLeaf(text, length);\n        }\n        let chunkLength = Math.max(512 /* BaseLeaf */, length >> 3 /* BranchShift */), maxLength = chunkLength << 1, minLength = chunkLength >> 1;\n        let chunked = [], currentLength = 0, currentChunk = [];\n        function add(child) {\n            let childLength = child.length, last;\n            if (childLength > maxLength && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (childLength > minLength && (currentLength > minLength || currentLength == 0)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLength > 0 &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.length + last.length <= 512 /* BaseLeaf */) {\n                currentLength += childLength;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(appendText(child.text, last.text.slice()), child.length + last.length);\n            }\n            else {\n                if (currentLength + childLength > chunkLength)\n                    flush();\n                currentLength += childLength;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLength == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLength));\n            currentLength = 0;\n            currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = Text.of([\"\"]);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nfunction eqContent(a, b) {\n    if (a.length != b.length || a.lines != b.lines)\n        return false;\n    let iterA = new RawTextCursor(a), iterB = new RawTextCursor(b);\n    for (let offA = 0, offB = 0;;) {\n        if (iterA.lineBreak != iterB.lineBreak || iterA.done != iterB.done) {\n            return false;\n        }\n        else if (iterA.done) {\n            return true;\n        }\n        else if (iterA.lineBreak) {\n            iterA.next();\n            iterB.next();\n            offA = offB = 0;\n        }\n        else {\n            let strA = iterA.value.slice(offA), strB = iterB.value.slice(offB);\n            if (strA.length == strB.length) {\n                if (strA != strB)\n                    return false;\n                iterA.next();\n                iterB.next();\n                offA = offB = 0;\n            }\n            else if (strA.length > strB.length) {\n                if (strA.slice(0, strB.length) != strB)\n                    return false;\n                offA += strB.length;\n                iterB.next();\n                offB = 0;\n            }\n            else {\n                if (strB.slice(0, strA.length) != strA)\n                    return false;\n                offB += strA.length;\n                iterA.next();\n                offA = 0;\n            }\n        }\n    }\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n    }\n    next(skip = 0) {\n        for (;;) {\n            let last = this.nodes.length - 1;\n            if (last < 0) {\n                this.done = true;\n                this.value = \"\";\n                this.lineBreak = false;\n                return this;\n            }\n            let top = this.nodes[last];\n            let offset = this.offsets[last];\n            if (top instanceof TextLeaf) {\n                // Internal offset with lineBreak == false means we have to\n                // count the line break at this position\n                if (offset != (this.dir > 0 ? 0 : top.text.length) && !this.lineBreak) {\n                    this.lineBreak = true;\n                    if (skip == 0) {\n                        this.value = \"\\n\";\n                        return this;\n                    }\n                    skip--;\n                    continue;\n                }\n                // Otherwise, move to the next string\n                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n                this.offsets[last] = (offset += this.dir);\n                if (offset == (this.dir > 0 ? top.text.length : 0)) {\n                    this.nodes.pop();\n                    this.offsets.pop();\n                }\n                this.lineBreak = false;\n                if (next.length > skip) {\n                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else if (offset == (this.dir > 0 ? top.children.length : 0)) {\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else {\n                let next = top.children[this.dir > 0 ? offset : offset - 1], len = next.length;\n                this.offsets[last] = offset + this.dir;\n                if (skip > len) {\n                    skip -= len;\n                }\n                else {\n                    this.nodes.push(next);\n                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n                }\n            }\n        }\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        if (start > end) {\n            this.skip = text.length - start;\n            this.limit = start - end;\n        }\n        else {\n            this.skip = start;\n            this.limit = end - start;\n        }\n    }\n    next() {\n        if (this.limit <= 0) {\n            this.limit = -1;\n        }\n        else {\n            let { value, lineBreak } = this.cursor.next(this.skip);\n            this.skip = 0;\n            this.value = value;\n            let len = lineBreak ? 1 : value.length;\n            if (len > this.limit)\n                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n            this.limit -= this.value.length;\n        }\n        return this;\n    }\n    get lineBreak() { return this.cursor.lineBreak; }\n    get done() { return this.limit < 0; }\n}\nclass LineCursor {\n    constructor(text, from = 0) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = text.iter();\n        this.skip = from;\n    }\n    next() {\n        if (this.cursor.done) {\n            this.done = true;\n            this.value = \"\";\n            return this;\n        }\n        for (this.value = \"\";;) {\n            let { value, lineBreak, done } = this.cursor.next(this.skip);\n            this.skip = 0;\n            if (done || lineBreak)\n                return this;\n            this.value += value;\n        }\n    }\n    get lineBreak() { return false; }\n}\n// FIXME rename start/end to from/to for consistency with other types?\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nclass Line {\n    /// @internal\n    constructor(\n    /// The position of the start of the line.\n    start, \n    /// The position at the end of the line (_before_ the line break,\n    /// if this isn't the last line).\n    end, \n    /// This line's line number (1-based).\n    number, \n    /// @internal\n    content) {\n        this.start = start;\n        this.end = end;\n        this.number = number;\n        this.content = content;\n    }\n    /// The length of the line (not including any line break after it).\n    get length() { return this.end - this.start; }\n    /// Retrieve a part of the content of this line. This is a method,\n    /// rather than, say, a string property, to avoid concatenating long\n    /// lines whenever they are accessed. Try to write your code, if it\n    /// is going to be doing a lot of line-reading, to read only the\n    /// parts it needs.\n    slice(from = 0, to = this.length) {\n        if (typeof this.content == \"string\")\n            return to == from + 1 ? this.content.charAt(from) : this.content.slice(from, to);\n        if (from == to)\n            return \"\";\n        let result = this.content.slice(from, to);\n        if (from == 0 && to == this.length)\n            this.content = result;\n        return result;\n    }\n    /// @internal\n    finish(text) {\n        if (this.content == null)\n            this.content = new LineContent(text, this.start);\n        return this;\n    }\n}\nclass LineContent {\n    constructor(doc, start) {\n        this.doc = doc;\n        this.start = start;\n        this.cursor = null;\n        this.strings = null;\n    }\n    // FIXME quadratic complexity (somewhat) when iterating long lines in small pieces\n    slice(from, to) {\n        if (!this.cursor) {\n            this.cursor = this.doc.iter();\n            this.strings = [this.cursor.next(this.start).value];\n        }\n        for (let result = \"\", pos = 0, i = 0;; i++) {\n            if (i == this.strings.length)\n                this.strings.push(this.cursor.next().value);\n            let string = this.strings[i], end = pos + string.length;\n            if (end <= from)\n                continue;\n            result += string.slice(Math.max(0, from - pos), Math.min(string.length, to - pos));\n            if (end >= to)\n                return result;\n            pos += string.length;\n        }\n    }\n}\n\nexport { CharType, Line, Text, charType, codePointAt, countColumn, findColumn, fromCodePoint, isExtendingChar, isWordChar, minPairCodePoint };\n","/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024\n\n/// The `unchanged` method expects changed ranges in this format.\nexport interface ChangedRange {\n  /// The start of the change in the start document\n  fromA: number\n  /// The end of the change in the start document\n  toA: number\n  /// The start of the replacement in the new document\n  fromB: number\n  /// The end of the replacement in the new document\n  toB: number\n}\n\ntype EnterFunc<T> = (type: NodeType, start: number, end: number) => T | false | undefined\n\ntype LeaveFunc = (type: NodeType, start: number, end: number) => void\n\n/// Passed to `Subtree.iterate`.\ntype IterateArgs<T> = {\n  /// The function called when entering a node. It is given a node's\n  /// type, start position, and end position, and can return...\n  ///\n  ///  * `undefined` to proceed iterating as normal.\n  ///\n  ///  * `false` to not further iterate this node, but continue\n  ///    iterating nodes after it.\n  ///\n  ///  * Any other value to immediately stop iteration and return that\n  ///    value from the `iterate` method.\n  enter: EnterFunc<T>,\n  /// The function to be called when leaving a node.\n  leave?: LeaveFunc,\n  /// The position in the tree to start iterating. All nodes that\n  /// overlap with this position (including those that start/end\n  /// directly at it) are included in the iteration. Defaults to the\n  /// start of the subtree.\n  from?: number,\n  /// The position in the tree to iterate towards. May be less than\n  /// `from` to perform a reverse iteration. Defaults to the end of\n  /// the subtree.\n  to?: number\n}\n\nclass Iteration<T> {\n  result: T | undefined = undefined\n\n  constructor(readonly enter: EnterFunc<T>,\n              readonly leave: LeaveFunc | undefined) {}\n\n  get done() { return this.result !== undefined }\n\n  doEnter(type: NodeType, start: number, end: number) {\n    let value = this.enter(type, start, end)\n    if (value === undefined) return true\n    if (value !== false) this.result = value\n    return false\n  }\n}\n\nlet nextPropID = 0\n\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file. Defaults to raising an error.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({deserialize}: {deserialize?: (str: string) => T} = {}) {\n    this.id = nextPropID++\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n  static string() { return new NodeProp<string>({deserialize: str => str}) }\n\n  /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n  static number() { return new NodeProp<number>({deserialize: Number}) }\n\n  /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n  static flag() { return new NodeProp<boolean>({deserialize: () => true}) }\n\n  /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n  set(propObj: {[prop: number]: any}, value: T) {\n    propObj[this.id] = value\n    return propObj\n  }\n\n  /// This is meant to be used with\n  /// [`NodeGroup.extend`](#tree.NodeGroup.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the group. Takes a [match\n  /// object](#tree.NodeType.match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    return new NodePropSource(this, typeof match == \"function\" ? match : NodeType.match(match))\n  }\n\n  /// The special node type that the parser uses to represent parse\n  /// errors has this flag set. (You shouldn't use it for custom nodes\n  /// that represent erroneous content.)\n  static error = NodeProp.flag()\n\n  /// Nodes that were produced by skipped expressions (such as\n  /// comments) have this prop set to true.\n  static skipped = NodeProp.flag()\n\n  /// Prop that is used to describe a rule's delimiters. For example,\n  /// a parenthesized expression node would set this to the string `\"(\n  /// )\"` (the open and close strings separated by a space). This is\n  /// added by the parser generator's `@detectDelim` feature, but you\n  /// can also manually add them.\n  static delim = NodeProp.string()\n\n  /// Indicates that this node indicates a top level document.\n  static top = NodeProp.flag()\n}\n\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node group.\nexport class NodePropSource {\n  /// @internal\n  constructor(\n    /// @internal\n    readonly prop: NodeProp<any>,\n    /// @internal\n    readonly f: (type: NodeType) => any) {}\n}\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node group should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its group. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number) {}\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node names. Often\n  /// useful with [`NodeProp.add`](#tree.NodeProp.add). You can put\n  /// multiple node names, separated by spaces, in a single property\n  /// name to map multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => direct[node.name]\n  }\n}\n\n/// A node group holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.group) a node group, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same group. A group can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeGroup {\n  /// Create a group with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this group, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node group\")\n  }\n\n  /// Create a copy of this group with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeGroup {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps = null\n      for (let source of props) {\n        let value = source.f(type)\n        if (value !== undefined) {\n          if (!newProps) {\n            newProps = Object.create(null)\n            for (let prop in type.props) newProps[prop] = type.props[prop]\n          }\n          newProps[source.prop.id] = value\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id) : type)\n    }\n    return new NodeGroup(newTypes)\n  }\n}\n\n/// A subtree is a representation of part of the syntax tree. It may\n/// either be the tree root, or a tagged node.\nexport abstract class Subtree {\n  /// The subtree's parent. Will be `null` for the root node\n  abstract parent: Subtree | null\n\n  /// The node's type\n  abstract type: NodeType\n  // Shorthand for `.type.name`.\n  get name() { return this.type.name }\n  /// The start source offset of this subtree\n  abstract start: number\n  /// The end source offset\n  abstract end: number\n\n  /// The depth (number of parent nodes) of this subtree\n  get depth() {\n    let d = 0\n    for (let p = this.parent; p; p = p.parent) d++\n    return d\n  }\n\n  /// The root of the tree that this subtree is part of\n  get root(): Tree {\n    let cx = this as Subtree\n    while (cx.parent) cx = cx.parent\n    return cx as Tree\n  }\n\n  /// @internal\n  abstract toString(): string\n\n  /// Iterate over all nodes in this subtree. Will iterate through the\n  /// tree in, calling `args.enter` for each node it enters and, if\n  /// given, `args.leave` when it leaves a node.\n  abstract iterate<T = any>(args: IterateArgs<T>): T | undefined\n\n  /// Find the node at a given position. By default, this will return\n  /// the lowest-depth subtree that covers the position from both\n  /// sides, meaning that nodes starting or ending at the position\n  /// aren't entered. You can pass a `side` of `-1` to enter nodes\n  /// that end at the position, or `1` to enter nodes that start\n  /// there.\n  resolve(pos: number, side: -1 | 0 | 1 = 0): Subtree {\n    let result = this.resolveAt(pos)\n    // FIXME this is slightly inefficient in that it scans the result\n    // of resolveAt twice (but further complicating child-finding\n    // logic seems unattractive as well)\n    if (side != 0) for (;;) {\n      let child = (side < 0 ? result.childBefore(pos) : result.childAfter(pos))\n      if (!child || (side < 0 ? child.end : child.start) != pos) break\n      result = child\n    }\n    return result\n  }\n\n  /// @internal\n  abstract resolveAt(pos: number): Subtree\n\n  /// Find the child tree before the given position, if any.\n  abstract childBefore(pos: number): Subtree | null\n  /// Find the child tree after the given position, if any.\n  abstract childAfter(pos: number): Subtree | null\n\n  /// Get the first child of this subtree.\n  get firstChild() { return this.childAfter(this.start - 1) }\n  /// Find the last child of this subtree.\n  get lastChild() { return this.childBefore(this.end + 1) }\n}\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `Subtree` interface instead, which provides a view on some\n/// part of this data structure, and can be used (through `resolve`,\n/// for example) to zoom in on any single node.\nexport class Tree extends Subtree {\n  /// @internal\n  parent!: null\n\n  /// @internal\n  constructor(\n    /// @internal\n    readonly type: NodeType,\n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer` will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree @internal\n    readonly length: number\n  ) {\n    super()\n  }\n\n  /// @internal\n  get start() { return 0 }\n\n  /// @internal\n  get end() { return this.length }\n\n  /// @internal\n  toString(): string {\n    let children = this.children.map(c => c.toString()).join()\n    return !this.name ? children :\n      (/\\W/.test(this.name) && !this.type.prop(NodeProp.error) ? JSON.stringify(this.name) : this.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  private partial(start: number, end: number, offset: number, children: (Tree | TreeBuffer)[], positions: number[]) {\n    for (let i = 0; i < this.children.length; i++) {\n      let from = this.positions[i]\n      if (from > end) break\n      let child = this.children[i], to = from + child.length\n      if (to < start) continue\n      if (start <= from && end >= to) {\n        children.push(child)\n        positions.push(from + offset)\n      } else if (child instanceof Tree) {\n        child.partial(start - from, end - from, offset + from, children, positions)\n      }\n    }\n  }\n\n  /// Apply a set of edits to a tree, removing all nodes that were\n  /// touched by the edits, and moving remaining nodes so that their\n  /// positions are updated for insertions/deletions before them. This\n  /// is likely to destroy a lot of the structure of the tree, and\n  /// mostly useful for extracting the nodes that can be reused in a\n  /// subsequent incremental re-parse.\n  applyChanges(changes: readonly ChangedRange[]) {\n    if (changes.length == 0) return this\n    let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n\n    function cutAt(tree: Tree, pos: number, side: -1 | 1) {\n      let found = -1\n      tree.iterate({\n        from: pos,\n        to: side < 0 ? 0 : tree.length,\n        enter() { return found < 0 ? undefined : false },\n        leave(type, start, end) {\n          if (found < 0 && !type.prop(NodeProp.error))\n            found = side < 0 ? Math.min(pos, end - 1) : Math.max(pos, start + 1)\n        }\n      })\n      return found > -1 ? found : side < 0 ? 0 : tree.length\n    }\n\n    let off = 0\n    for (let i = 0, pos = 0;; i++) {\n      let next = i == changes.length ? null : changes[i]\n      let nextPos = next ? cutAt(this, next.fromA, -1) : this.length\n      if (nextPos > pos) this.partial(pos, nextPos, off, children, positions)\n      if (!next) break\n      pos = cutAt(this, next.toA, 1)\n      off += (next.toB - next.fromB) - (next.toA - next.fromA)\n    }\n    return new Tree(NodeType.none, children, positions, this.length + off)\n  }\n\n  /// Take the part of the tree up to the given position.\n  cut(at: number): Tree {\n    if (at >= this.length) return this\n    let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n    for (let i = 0; i < this.children.length; i++) {\n      let from = this.positions[i]\n      if (from >= at) break\n      let child = this.children[i], to = from + child.length\n      children.push(to <= at ? child : child.cut(at - from))\n      positions.push(from)\n    }\n    return new Tree(this.type, children, positions, at)\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// @internal\n  iterate<T = any>({from = this.start, to = this.end, enter, leave}: IterateArgs<T>) {\n    let iter = new Iteration(enter, leave)\n    this.iterInner(from, to, 0, iter)\n    return iter.result\n  }\n\n  /// @internal\n  iterInner<T>(from: number, to: number, offset: number, iter: Iteration<T>) {\n    if (this.type.name && !iter.doEnter(this.type, offset, offset + this.length))\n      return\n\n    if (from <= to) {\n      for (let i = 0; i < this.children.length && !iter.done; i++) {\n        let child = this.children[i], start = this.positions[i] + offset, end = start + child.length\n        if (start > to) break\n        if (end < from) continue\n        child.iterInner(from, to, start, iter)\n      }\n    } else {\n      for (let i = this.children.length - 1; i >= 0 && !iter.done; i--) {\n        let child = this.children[i], start = this.positions[i] + offset, end = start + child.length\n        if (end < to) break\n        if (start > from) continue\n        child.iterInner(from, to, start, iter)\n      }\n    }      \n    if (iter.leave && this.type.name) iter.leave(this.type, offset, offset + this.length)\n    return\n  }\n\n  /// @internal\n  resolveAt(pos: number): Subtree {\n    if (cacheRoot == this) {\n      for (let tree = cached;;) {\n        let next = tree.parent\n        if (!next) break\n        if (tree.start < pos && tree.end > pos) return tree.resolve(pos)\n        tree = next\n      }\n    }\n    cacheRoot = this\n    return cached = this.resolveInner(pos, 0, this)\n  }\n\n  /// @internal\n  childBefore(pos: number): Subtree | null {\n    return this.findChild(pos, -1, 0, this)\n  }\n\n  /// @internal\n  childAfter(pos: number): Subtree | null {\n    return this.findChild(pos, 1, 0, this)\n  }\n\n  /// @internal\n  findChild(pos: number, side: number, start: number, parent: Subtree): Subtree | null {\n    for (let i = 0; i < this.children.length; i++) {\n      let childStart = this.positions[i] + start, select = -1\n      if (childStart >= pos) {\n        if (side < 0 && i > 0) select = i - 1\n        else if (side > 0) select = i\n        else break\n      }\n      if (select < 0 && (childStart + this.children[i].length > pos || side < 0 && i == this.children.length - 1))\n        select = i\n      if (select >= 0) {\n        let child = this.children[select], childStart = this.positions[select] + start\n        if (child.length == 0 && childStart == pos) continue\n        if (child instanceof Tree) {\n          if (child.type.name) return new NodeSubtree(child, childStart, parent)\n          return child.findChild(pos, side, childStart, parent)\n        } else {\n          let found = child.findIndex(pos, side, childStart, 0, child.buffer.length)\n          if (found > -1) return new BufferSubtree(child, childStart, found, parent)\n        }\n      }\n    }\n    return null\n  }\n\n  /// @internal\n  resolveInner(pos: number, start: number, parent: Subtree): Subtree {\n    let found = this.findChild(pos, 0, start, parent)\n    return found ? found.resolveAt(pos) : parent\n  }\n\n  /// Append another tree to this tree. `other` must have empty space\n  /// big enough to fit this tree at its start.\n  append(other: Tree) {\n    if (other.children.length && other.positions[0] < this.length) throw new Error(\"Can't append overlapping trees\")\n    return new Tree(this.type, this.children.concat(other.children), this.positions.concat(other.positions), other.length)\n  }\n\n  /// Balance the direct children of this tree.\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this\n      : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0,\n                     maxBufferLength, this.length)\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\nTree.prototype.parent = null\n\n/// Options passed to [`Tree.build`](#tree.Tree^build).\nexport type BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  group: NodeGroup,\n  /// The id of the top node type, if any.\n  topID?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#tree.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional set of reused nodes that the buffer can refer to.\n  reused?: (Tree | TreeBuffer)[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n// Top-level `resolveAt` calls store their last result here, so that\n// if the next call is near the last, parent trees can be cheaply\n// reused.\nlet cacheRoot: Tree = Tree.empty\nlet cached: Subtree = Tree.empty\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor(\n    /// @internal\n    readonly buffer: Uint16Array,\n    // The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// @internal\n    readonly group: NodeGroup,\n    /// An optional type tag, used to tag a buffer as being part of a\n    /// repetition @internal\n    readonly type = NodeType.none\n  ) {}\n\n  /// @internal\n  toString() {\n    let parts: string[] = []\n    for (let index = 0; index < this.buffer.length;)\n      index = this.childToString(index, parts)\n    return parts.join(\",\")\n  }\n\n  /// @internal\n  childToString(index: number, parts: string[]): number {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.group.types[id], result = type.name\n    if (/\\W/.test(result) && !type.prop(NodeProp.error)) result = JSON.stringify(result)\n    index += 4\n    if (endIndex > index) {\n      let children: string[] = []\n      while (index < endIndex) index = this.childToString(index, children)\n      result += \"(\" + children.join(\",\") + \")\"\n    }\n    parts.push(result)\n    return index\n  }\n\n  /// @internal\n  cut(at: number) {\n    let cutPoint = 0\n    while (cutPoint < this.buffer.length && this.buffer[cutPoint + 1] < at) cutPoint += 4\n    let newBuffer = new Uint16Array(cutPoint)\n    for (let i = 0; i < cutPoint; i += 4) {\n      newBuffer[i] = this.buffer[i]\n      newBuffer[i + 1] = this.buffer[i + 1]\n      newBuffer[i + 2] = Math.min(at, this.buffer[i + 2])\n      newBuffer[i + 3] = Math.min(this.buffer[i + 3], cutPoint)\n    }\n    return new TreeBuffer(newBuffer, Math.min(at, this.length), this.group)\n  }\n\n  iterate<T = any>({from = 0, to = this.length, enter, leave}: IterateArgs<T>): T | undefined {\n    let iter = new Iteration(enter, leave)\n    this.iterInner(from, to, 0, iter)\n    return iter.result\n  }\n\n  /// @internal\n  iterInner<T>(from: number, to: number, offset: number, iter: Iteration<T>) {\n    if (from <= to) {\n      for (let index = 0; index < this.buffer.length;)\n        index = this.iterChild(from, to, offset, index, iter)\n    } else {\n      this.iterRev(from, to, offset, 0, this.buffer.length, iter)\n    }\n  }\n\n  /// @internal\n  iterChild<T>(from: number, to: number, offset: number, index: number, iter: Iteration<T>) {\n    let type = this.group.types[this.buffer[index++]], start = this.buffer[index++] + offset,\n        end = this.buffer[index++] + offset, endIndex = this.buffer[index++]\n    if (start > to) return this.buffer.length\n    if (end >= from && iter.doEnter(type, start, end)) {\n      while (index < endIndex && !iter.done) index = this.iterChild(from, to, offset, index, iter)\n      if (iter.leave) iter.leave(type, start, end)\n    }\n    return endIndex\n  }\n\n  private parentNodesByEnd(startIndex: number, endIndex: number) {\n    // Build up an array of node indices reflecting the order in which\n    // non-empty nodes end, to avoid having to scan for parent nodes\n    // at every position during reverse iteration.\n    let order: number[] = []\n    let scan = (index: number) => {\n      let end = this.buffer[index + 3]\n      if (end == index + 4) return end\n      for (let i = index + 4; i < end;) i = scan(i)\n      order.push(index)\n      return end\n    }\n    for (let index = startIndex; index < endIndex;) index = scan(index)\n    return order\n  }\n\n  /// @internal\n  iterRev<T>(from: number, to: number, offset: number, startIndex: number, endIndex: number, iter: Iteration<T>) {\n    let endOrder = this.parentNodesByEnd(startIndex, endIndex)\n    // Index range for the next non-empty node\n    let nextStart = -1, nextEnd = -1\n    let takeNext = () => {\n      if (endOrder.length > 0) {\n        nextStart = endOrder.pop()!\n        nextEnd = this.buffer[nextStart + 3]\n      } else {\n        nextEnd = -1\n      }\n    }\n    takeNext()\n\n    run: for (let index = endIndex; index > startIndex && !iter.done;) {\n      while (nextEnd == index) {\n        let base = nextStart\n        let id = this.buffer[base], start = this.buffer[base + 1] + offset, end = this.buffer[base + 2] + offset\n        takeNext()\n        if (start <= from && end >= to) {\n          if (!iter.doEnter(this.group.types[id], start, end)) {\n            // Skip the entire node\n            index = base\n            while (nextEnd > base) takeNext()\n            continue run\n          }\n        }\n      }\n      let endIndex = this.buffer[--index], end = this.buffer[--index] + offset,\n        start = this.buffer[--index] + offset, id = this.buffer[--index]\n      if (start > from || end < to) continue\n      if ((endIndex != index + 4 || iter.doEnter(this.group.types[id], start, end)) && iter.leave)\n        iter.leave(this.group.types[id], start, end)\n    }\n  }\n\n  /// @internal\n  findIndex(pos: number, side: number, start: number, from: number, to: number) {\n    let lastI = -1\n    for (let i = from, buf = this.buffer; i < to;) {\n      let start1 = buf[i + 1] + start, end1 = buf[i + 2] + start\n      let ignore = start1 == end1 && start1 == pos\n      if (start1 >= pos) {\n        if (side > 0 && !ignore) return i\n        break\n      }\n      if (end1 > pos) return i\n      if (!ignore) lastI = i\n      i = buf[i + 3]\n    }\n    return side < 0 ? lastI : -1\n  }\n}\n\nclass NodeSubtree extends Subtree {\n  constructor(readonly node: Tree,\n              readonly start: number,\n              readonly parent: Subtree) {\n    super()\n  }\n\n  get type() { return this.node.type }\n\n  get end() { return this.start + this.node.length }\n\n  resolveAt(pos: number): Subtree {\n    if (pos <= this.start || pos >= this.end)\n      return this.parent.resolveAt(pos)\n    return this.node.resolveInner(pos, this.start, this)\n  }\n\n  childBefore(pos: number): Subtree | null {\n    return this.node.findChild(pos, -1, this.start, this)\n  }\n\n  childAfter(pos: number): Subtree | null {\n    return this.node.findChild(pos, 1, this.start, this)\n  }\n\n  toString() { return this.node.toString() }\n\n  iterate<T = any>({from = this.start, to = this.end, enter, leave}: IterateArgs<T>) {\n    let iter = new Iteration(enter, leave)\n    this.node.iterInner(from, to, this.start, iter)\n    return iter.result\n  }\n}\n\nclass BufferSubtree extends Subtree {\n  constructor(readonly buffer: TreeBuffer,\n              readonly bufferStart: number,\n              readonly index: number,\n              readonly parent: Subtree) {\n    super()\n  }\n\n  get type() { return this.buffer.group.types[this.buffer.buffer[this.index]] }\n  get start() { return this.buffer.buffer[this.index + 1] + this.bufferStart }\n  get end() { return this.buffer.buffer[this.index + 2] + this.bufferStart }\n\n  private get endIndex() { return this.buffer.buffer[this.index + 3] }\n\n  childBefore(pos: number): Subtree | null {\n    let index = this.buffer.findIndex(pos, -1, this.bufferStart, this.index + 4, this.endIndex)\n    return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this)\n  }\n\n  childAfter(pos: number): Subtree | null {\n    let index = this.buffer.findIndex(pos, 1, this.bufferStart, this.index + 4, this.endIndex)\n    return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this)\n  }\n\n  iterate<T = any>({from = this.start, to = this.end, enter, leave}: IterateArgs<T>) {\n    let iter = new Iteration(enter, leave)\n    if (from <= to)\n      this.buffer.iterChild(from, to, this.bufferStart, this.index, iter)\n    else\n      this.buffer.iterRev(from, to, this.bufferStart, this.index, this.endIndex, iter)\n    return iter.result\n  }\n\n  resolveAt(pos: number): Subtree {\n    if (pos <= this.start || pos >= this.end) return this.parent.resolveAt(pos)\n    let found = this.buffer.findIndex(pos, 0, this.bufferStart, this.index + 4, this.endIndex)\n    return found < 0 ? this : new BufferSubtree(this.buffer, this.bufferStart, found, this).resolveAt(pos)\n  }\n\n  toString() {\n    let result: string[] = []\n    this.buffer.childToString(this.index, result)\n    return result.join(\"\")\n  }\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer.\nexport interface BufferCursor {\n  pos: number\n  id: number\n  start: number\n  end: number\n  size: number\n  next(): void\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\nconst BalanceBranchFactor = 8\n\nfunction buildTree(data: BuildData) {\n  let {buffer, group, topID = 0,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = group.types.length} = data as BuildData\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = group.types\n  function takeNode(parentStart: number, minPos: number, children: (Tree | TreeBuffer)[], positions: number[],\n                    tagBuffer: NodeType) {\n    let {id, start, end, size} = cursor, buffer!: {size: number, start: number, skip: number} | null\n    let startPos = start - parentStart\n    if (size < 0) { // Reused node\n      children.push(reused[id])\n      positions.push(startPos)\n      cursor.next()\n      return\n    }\n\n    let type = types[id], node\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index)\n      node = new TreeBuffer(data, end - buffer.start, group, tagBuffer)\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      // Check if this is a repeat wrapper. Store the id of the inner\n      // repeat node in the variable if it is\n      let repeating = id >= group.types.length ? id - (group.types.length - minRepeatType) : -1\n      if (repeating > -1) {\n        type = types[repeating]\n        while (cursor.pos > endPos) {\n          let isRepeat = cursor.id == repeating // This starts with an inner repeated node\n          takeNode(start, endPos, localChildren, localPositions, isRepeat ? type : NodeType.none)\n        }\n      } else {\n        while (cursor.pos > endPos)\n          takeNode(start, endPos, localChildren, localPositions, NodeType.none)\n      }\n      localChildren.reverse(); localPositions.reverse()\n\n      if (repeating > -1 && localChildren.length > BalanceBranchFactor)\n        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start)\n      else\n        node = new Tree(type, localChildren, localPositions, end - start)\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function findBufferSize(maxSize: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer)\n    // If `type` is > -1, only include siblings with that same type\n    // (used to group repeat content into a buffer)\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan\n        if (fork.id >= minRepeatType) localSkipped += 4\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    return size > 4 ? {size, start, skip} : null\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    let startIndex = index\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4)\n      while (cursor.pos > endPos)\n        index = copyToBuffer(bufferStart, buffer, index)\n    }\n    if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(0, 0, children, positions, NodeType.none)\n  let length = children.length ? positions[0] + children[0].length : 0\n  return new Tree(group.types[topID], children.reverse(), positions.reverse(), length)\n}\n\nfunction balanceRange(outerType: NodeType, innerType: NodeType,\n                      children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                      from: number, to: number,\n                      start: number, maxBufferLength: number, length: number): Tree {\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i])\n      localPositions.push(positions[i] - start)\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor))\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i]\n      i++\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length\n        if (nextEnd - groupStart > maxChild) break\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom]\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j])\n            localPositions.push(only.positions[j] + groupStart - start)\n          }\n          continue\n        }\n        localChildren.push(only)\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom])\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart,\n                                 maxBufferLength, positions[i - 1] - groupStart)\n        if (innerType != NodeType.none && !containsType(inner.children, innerType))\n          inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length)\n        localChildren.push(inner)\n      }\n      localPositions.push(groupStart - start)\n    }\n  }\n  return new Tree(outerType, localChildren, localPositions, length)\n}\n\nfunction containsType(nodes: readonly (Tree | TreeBuffer)[], type: NodeType) {\n  for (let elt of nodes) if (elt.type == type) return true\n  return false\n}\n","import { charType, Text } from '../../text';\nexport { Text } from '../../text';\nimport { NodeProp, Tree } from 'lezer-tree';\n\n/// A single selection range. When\n/// [`allowMultipleSelections`](#state.EditorState^allowMultipleSelections)\n/// is enabled, a [selection](#state.EditorSelection) may hold\n/// multiple ranges. By default, selections hold exactly one range.\nclass SelectionRange {\n    /// Create a range. `head` defaults to `anchor` when not given.\n    constructor(\n    /// The anchor of the rangethe side that doesn't move when you\n    /// extend it.\n    anchor, \n    /// The head of the range, which is moved when the range is\n    /// [extended](#state.SelectionRange.extend).\n    head = anchor) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    /// The lower side of the range.\n    get from() { return Math.min(this.anchor, this.head); }\n    /// The upper side of the range.\n    get to() { return Math.max(this.anchor, this.head); }\n    /// True when `anchor` and `head` are at the same position.\n    get empty() { return this.anchor == this.head; }\n    /// Map this range through a mapping.\n    map(mapping) {\n        let anchor = mapping.mapPos(this.anchor), head = mapping.mapPos(this.head);\n        if (anchor == this.anchor && head == this.head)\n            return this;\n        else\n            return new SelectionRange(anchor, head);\n    }\n    /// Extend this range to cover at least `from` to `to`.\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return new SelectionRange(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return new SelectionRange(this.anchor, head);\n    }\n    /// Compare this range to another range.\n    eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /// Return a JSON-serializable object representing the range.\n    toJSON() { return this; }\n    /// Convert a JSON representation of a range to a `SelectionRange`\n    /// instance.\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return new SelectionRange(json.anchor, json.head);\n    }\n    /// @internal FIXME export?\n    static groupAt(state, pos, bias = 1) {\n        // FIXME at some point, take language-specific identifier characters into account\n        let line = state.doc.lineAt(pos), linePos = pos - line.start;\n        if (line.length == 0)\n            return new SelectionRange(pos);\n        if (linePos == 0)\n            bias = 1;\n        else if (linePos == line.length)\n            bias = -1;\n        let read = linePos + (bias < 0 ? -1 : 0), type = charType(line.slice(read, read + 1));\n        let from = pos, to = pos;\n        for (let lineFrom = linePos; lineFrom > 0 && charType(line.slice(lineFrom - 1, lineFrom)) == type; lineFrom--)\n            from--;\n        for (let lineTo = linePos; lineTo < line.length && charType(line.slice(lineTo, lineTo + 1)) == type; lineTo++)\n            to++;\n        return new SelectionRange(to, from);\n    }\n}\n/// An editor selection holds one or more selection ranges.\nclass EditorSelection {\n    /// @internal\n    constructor(\n    /// The ranges in the selection, sorted by position. Ranges cannot\n    /// overlap (but they may touch, if they aren't empty).\n    ranges, \n    /// The index of the _primary_ range in the selection (which is\n    /// usually the range that was added last).\n    primaryIndex = 0) {\n        this.ranges = ranges;\n        this.primaryIndex = primaryIndex;\n    }\n    /// Map a selection through a mapping. Mostly used to adjust the\n    /// selection position for changes.\n    map(mapping) {\n        return EditorSelection.create(this.ranges.map(r => r.map(mapping)), this.primaryIndex);\n    }\n    /// Compare this selection to another selection.\n    eq(other) {\n        if (this.ranges.length != other.ranges.length ||\n            this.primaryIndex != other.primaryIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i]))\n                return false;\n        return true;\n    }\n    /// Get the primary selection range. Usually, you should make sure\n    /// your code applies to _all_ ranges, by using transaction methods\n    /// like [`forEachRange`](#state.transaction.forEachRange).\n    get primary() { return this.ranges[this.primaryIndex]; }\n    /// Make sure the selection only has one range. Returns a selection\n    /// holding only the primary range from this selection.\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.primary]);\n    }\n    /// Extend this selection with an extra range.\n    addRange(range, primary = true) {\n        return EditorSelection.create([range].concat(this.ranges), primary ? 0 : this.primaryIndex + 1);\n    }\n    /// Replace a given range with another range, and then normalize the\n    /// selection to merge and sort ranges if necessary.\n    replaceRange(range, which = this.primaryIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.primaryIndex);\n    }\n    /// Convert this selection to an object that can be serialized to\n    /// JSON.\n    toJSON() {\n        return this.ranges.length == 1 ? this.ranges[0].toJSON() :\n            { ranges: this.ranges.map(r => r.toJSON()), primaryIndex: this.primaryIndex };\n    }\n    /// Create a selection from a JSON representation.\n    static fromJSON(json) {\n        if (json && Array.isArray(json.ranges)) {\n            if (typeof json.primaryIndex != \"number\" || json.primaryIndex >= json.ranges.length)\n                throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n            return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.primaryIndex);\n        }\n        return new EditorSelection([SelectionRange.fromJSON(json)]);\n    }\n    /// Create a selection holding a single range.\n    static single(anchor, head = anchor) {\n        return new EditorSelection([new SelectionRange(anchor, head)], 0);\n    }\n    /// Sort and merge the given set of ranges, creating a valid\n    /// selection.\n    static create(ranges, primaryIndex = 0) {\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return normalized(ranges.slice(), primaryIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, primaryIndex);\n    }\n}\nfunction normalized(ranges, primaryIndex = 0) {\n    let primary = ranges[primaryIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    primaryIndex = ranges.indexOf(primary);\n    for (let i = 1; i < ranges.length; i++) {\n        let range = ranges[i], prev = ranges[i - 1];\n        if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n            let from = prev.from, to = Math.max(range.to, prev.to);\n            if (i <= primaryIndex)\n                primaryIndex--;\n            ranges.splice(--i, 2, range.anchor > range.head ? new SelectionRange(to, from) : new SelectionRange(from, to));\n        }\n    }\n    return new EditorSelection(ranges, primaryIndex);\n}\nfunction checkSelection(selection, doc) {\n    for (let range of selection.ranges)\n        if (range.to > doc.length)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/// A facet is a value that is assicated with a state and can be\n/// influenced by any number of extensions. Extensions can provide\n/// input values for the facet, and the facet combines those into an\n/// output value.\n///\n/// Examples of facets are the theme styles associated with an editor\n/// (which are all stored) or the tab size (which is reduced to a\n/// single value, using the input with the hightest precedence).\nclass Facet {\n    constructor(\n    /// @internal\n    combine, \n    /// @internal\n    compareInput, \n    /// @internal\n    compare, isStatic) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /// @internal\n        this.id = nextID++;\n        this.default = combine([]);\n    }\n    /// Define a new facet.\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static);\n    }\n    /// Returns an extension that adds the given value for this facet.\n    of(value) {\n        return new FacetProvider([], this, 0 /* Static */, value);\n    }\n    /// Create an extension that computes a value for the facet from a\n    /// state. You must take care to declare the parts of the state that\n    /// this value depends on, since your function is only called again\n    /// for a new state when one of those parts changed.\n    ///\n    /// In most cases, you'll want to use\n    /// [`StateField.provide`](#state.StateField^provide) instead.\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Single */, get);\n    }\n    /// Create an extension that computes zero or more values for this\n    /// facet from a state.\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Multi */, get);\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let idx = addresses[this.id] >> 1, multi = this.type == 2 /* Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((addresses[dep.id] & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return (state, tr) => {\n            if (!tr || tr.reconfigured) {\n                state.values[idx] = getter(state);\n                return 1 /* Changed */;\n            }\n            else {\n                let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selectionSet)) ||\n                    depAddrs.some(addr => (ensureAddr(state, addr) & 1 /* Changed */) > 0);\n                if (!depChanged)\n                    return 0;\n                let newVal = getter(state), oldVal = tr.startState.values[idx];\n                if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))\n                    return 0;\n                state.values[idx] = newVal;\n                return 1 /* Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    return (state, tr) => {\n        let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;\n        let changed = oldAddr == null;\n        for (let dynAddr of dynamic) {\n            if (ensureAddr(state, dynAddr) & 1 /* Changed */)\n                changed = true;\n        }\n        if (!changed)\n            return 0;\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        let newVal = facet.combine(values);\n        if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))\n            return 0;\n        state.values[idx] = newVal;\n        return 1 /* Changed */;\n    };\n}\n/// Fields can store additional information in an editor state, and\n/// keep it in sync with the rest of the state.\nclass StateField {\n    constructor(\n    /// @internal\n    id, createF, updateF, compareF, \n    /// @internal\n    facets) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.facets = facets;\n    }\n    /// Define a state field.\n    static define(config) {\n        return new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), []);\n    }\n    provide(facet, get, prec) {\n        let provider = facet.compute([this], get ? state => get(state.field(this)) : state => state.field(this));\n        return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)));\n    }\n    /// Extends the field to provide zero or more input values for the\n    /// given facet.\n    provideN(facet, get, prec) {\n        let provider = facet.computeN([this], state => get(state.field(this)));\n        return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)));\n    }\n    /// @internal\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return (state, tr) => {\n            let oldIdx = !tr ? null : tr.reconfigured ? tr.startState.config.address[this.id] >> 1 : idx;\n            if (oldIdx == null) {\n                state.values[idx] = this.createF(state);\n                return 1 /* Changed */;\n            }\n            else {\n                let oldVal = tr.startState.values[oldIdx], value = this.updateF(oldVal, tr, state);\n                if (this.compareF(oldVal, value))\n                    return 0;\n                state.values[idx] = value;\n                return 1 /* Changed */;\n            }\n        };\n    }\n}\n/// By default extensions are registered in the order they are\n/// provided in a flattening of the nested arrays that were provided.\n/// Individual extension values can be assigned a precedence to\n/// override this. Extensions that do not have a precedence set get\n/// the precedence of the nearest parent with a precedence, or\n/// [`Default`](#state.Precedence.Default) if there is no such parent.\n/// The final ordering of extensions is determined by first sorting by\n/// precedence and then by order within each precedence.\nclass Precedence {\n    constructor(\n    /// @internal\n    val) {\n        this.val = val;\n    }\n    /// Tag an extension with this precedence.\n    set(extension) {\n        return new PrecExtension(extension, this.val);\n    }\n}\n/// A precedence below the default precedence, which will cause\n/// default-precedence extensions to override it even if they are\n/// specified later in the extension ordering.\nPrecedence.Fallback = new Precedence(3);\n/// The regular default precedence.\nPrecedence.Default = new Precedence(2);\n/// A higher-than-default precedence.\nPrecedence.Extend = new Precedence(1);\n/// Precedence above the `Default` and `Extend` precedences.\nPrecedence.Override = new Precedence(0);\nfunction maybePrec(prec, ext) {\n    return prec == null ? ext : prec.set(ext);\n}\nclass PrecExtension {\n    constructor(e, prec) {\n        this.e = e;\n        this.prec = prec;\n    }\n}\nclass GroupExtension {\n    constructor(extension, group) {\n        this.extension = extension;\n        this.group = group;\n    }\n}\n/// Extension groups can be used to make a configuration dynamic.\n/// [Wrapping](#state.ExtensionGroup.of) an extension in a group\n/// allows you to later replace it with\n/// [`Transaction.replaceExtension`](#state.Transaction.replaceExtension).\n/// A given group may only occur once within a given configuration.\nclass ExtensionGroup {\n    /// Define a new group. The name is used only for debugging\n    /// purposes.\n    constructor(name) {\n        this.name = name;\n    }\n    /// Tag the given extension with this group.\n    of(extension) { return new GroupExtension(extension, this); }\n}\nclass Configuration {\n    constructor(source, replacements, dynamicSlots, address, staticValues) {\n        this.source = source;\n        this.replacements = replacements;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < staticValues.length)\n            this.statusTemplate.push(0 /* Uninitialized */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(extension, replacements = new Map, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        for (let ext of flatten(extension, replacements)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            if (providers.every(p => p.type == 0 /* Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                let value = facet.combine(providers.map(p => p.value));\n                let oldAddr = oldState ? oldState.config.address[facet.id] : null;\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (facet.compare(value, oldVal))\n                        value = oldVal;\n                }\n                staticValues.push(value);\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        return new Configuration(extension, replacements, dynamicSlots.map(f => f(address)), address, staticValues);\n    }\n}\nfunction flatten(extension, replacements) {\n    let result = [[], [], [], []];\n    let seen = new Set();\n    let groupsSeen = new Set();\n    (function inner(ext, prec) {\n        if (seen.has(ext))\n            return;\n        seen.add(ext);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof GroupExtension) {\n            if (groupsSeen.has(ext.group))\n                throw new RangeError(`Duplicate use of group '${ext.group.name}' in extensions`);\n            groupsSeen.add(ext.group);\n            inner(replacements.get(ext.group) || ext.extension, prec);\n        }\n        else if (ext.extension) {\n            inner(ext.extension, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.e, ext.prec);\n        }\n        else {\n            result[prec].push(ext);\n            if (ext instanceof StateField)\n                inner(ext.facets, prec);\n        }\n    })(extension, Precedence.Default.val);\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* Computed */)\n        return status;\n    state.status[idx] = 4 /* Computing */;\n    let changed = state.config.dynamicSlots[idx](state, state.applying);\n    return state.status[idx] = 2 /* Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst allowMultipleSelections = Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nlet annotationID = 0;\n/// Annotations are tagged values that are used to add metadata to\n/// transactions in an extensible way.\nclass Annotation {\n    constructor() {\n        /// @internal\n        this.id = annotationID++;\n    }\n    /// Define a new type of annotation.\n    static define() { return new Annotation(); }\n}\n/// A node prop that can be stored on a grammar's top node to\n/// associate information with the language. Different extension might\n/// use different properties from this object (which they typically\n/// export as an interface).\nconst languageData = new NodeProp();\n// FIXME add a view plugin that schedules background parsing\n// FIXME add a way to be notified when the document is fully parsed\n\nconst empty = [];\n/// Distinguishes different ways in which positions can be mapped.\nvar MapMode;\n(function (MapMode) {\n    /// Map a position to a valid new position, even when its context\n    /// was deleted.\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /// Return a negative number if a deletion happens across the\n    /// position. This number will be `-(newPos + 1)`, where `newPos` is\n    /// the result you'd get with `MapMode.Simple`.\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /// Return a negative number if the character _before_ the position\n    /// is deleted. The result is encoded the same way as with\n    /// `MapMode.TrackDel`.\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /// Return a negative number if the character _after_ the position is\n    /// deleted.\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n})(MapMode || (MapMode = {}));\n/// A change description describes a document change. This is usually\n/// used as a superclass of [`Change`](#state.Change), but can be used\n/// to store change data without storing the replacement string\n/// content.\nclass ChangeDesc {\n    /// Create a description that replaces the text between positions\n    /// `from` and `to` with a new string of length `length`.\n    constructor(\n    /// The start position of the change.\n    from, \n    /// The end of the change (as a pre-change document position).\n    to, \n    /// The length of the replacing content.\n    length) {\n        this.from = from;\n        this.to = to;\n        this.length = length;\n    }\n    /// Get the change description of the inverse of this change.\n    get invertedDesc() { return new ChangeDesc(this.from, this.from + this.length, this.to - this.from); }\n    /// @internal\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        let { from, to, length } = this;\n        if (pos < from)\n            return pos;\n        if (pos > to)\n            return pos + (length - (to - from));\n        if (pos == to || pos == from) {\n            if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)\n                return -pos - 1;\n            return (from == to ? bias <= 0 : pos == from) ? from : from + length;\n        }\n        pos = from + (bias <= 0 ? 0 : length);\n        return mode != MapMode.Simple ? -pos - 1 : pos;\n    }\n    /// Return a JSON-serializeable object representing this value.\n    toJSON() { return this; }\n    /// Create a change description from its JSON representation.\n    static fromJSON(json) {\n        if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.length != \"number\")\n            throw new RangeError(\"Invalid JSON representation for ChangeDesc\");\n        return new ChangeDesc(json.from, json.to, json.length);\n    }\n}\n/// Change objects describe changes to the document.\nclass Change extends ChangeDesc {\n    /// Create a change that replaces `from` to `to` with `text`. The\n    /// text is given as an array of lines. When it doesn't span lines,\n    /// the array has a single element. When it does, a new element is\n    /// added for every line. It should never have zero elements.\n    constructor(from, to, \n    /// The replacement content.\n    text) {\n        super(from, to, textLength(text));\n        this.from = from;\n        this.to = to;\n        this.text = text;\n    }\n    /// Create the inverse of this change when applied to the given\n    /// document. `change.invert(doc).apply(change.apply(doc))` gets you\n    /// the same document as the original `doc`.\n    invert(doc) {\n        return new Change(this.from, this.from + this.length, doc.sliceLines(this.from, this.to));\n    }\n    /// Apply this change to the given content, returning an updated\n    /// version of the document.\n    apply(doc) {\n        return doc.replace(this.from, this.to, this.text);\n    }\n    /// Map this change through a mapping, producing a new change that\n    /// can be applied to a post-mapping document. May return null if\n    /// the mapping completely replaces the region this change would\n    /// apply to.\n    map(mapping) {\n        let from = mapping.mapPos(this.from, 1), to = mapping.mapPos(this.to, -1);\n        return from > to ? null : new Change(from, to, this.text);\n    }\n    /// A change description for this change.\n    get desc() { return new ChangeDesc(this.from, this.to, this.length); }\n    /// Produce a JSON-serializable object representing this change.\n    toJSON() {\n        return { from: this.from, to: this.to, text: this.text };\n    }\n    /// Read a change instance from its JSON representation.\n    static fromJSON(json) {\n        if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            !Array.isArray(json.text) || json.text.length == 0 || json.text.some((val) => typeof val != \"string\"))\n            throw new RangeError(\"Invalid JSON representation for Change\");\n        return new Change(json.from, json.to, json.text);\n    }\n}\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\n/// A change set holds a sequence of changes or change descriptions.\nclass ChangeSet {\n    /// @internal\n    constructor(\n    /// The changes in this set.\n    changes, \n    /// @internal\n    mirror = empty) {\n        this.changes = changes;\n        this.mirror = mirror;\n        this._changedRanges = null;\n    }\n    /// The number of changes in the set.\n    get length() {\n        return this.changes.length;\n    }\n    /// Change sets can track which changes are inverses of each other,\n    /// to allow robust position mapping in situations where changes are\n    /// undone and then redone again. This queries which change is the\n    /// mirror image of a given change (by index).\n    getMirror(n) {\n        for (let i = 0; i < this.mirror.length; i++)\n            if (this.mirror[i] == n)\n                return this.mirror[i + (i % 2 ? -1 : 1)];\n        return null;\n    }\n    /// Append a change to this set, returning an extended set. `mirror`\n    /// may be the index of a change already in the set, which\n    /// [mirrors](#state.ChangeSet.getMirror) the new change.\n    append(change, mirror) {\n        return new ChangeSet(this.changes.concat(change), mirror != null ? this.mirror.concat(this.length, mirror) : this.mirror);\n    }\n    /// Append another change set to this one.\n    appendSet(changes) {\n        return changes.length == 0 ? this :\n            this.length == 0 ? changes :\n                new ChangeSet(this.changes.concat(changes.changes), this.mirror.concat(changes.mirror.map(i => i + this.length)));\n    }\n    /// @internal\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        return this.mapInner(pos, bias, mode, 0, this.length);\n    }\n    /// @internal\n    mapInner(pos, bias, mode, fromI, toI) {\n        let dir = toI < fromI ? -1 : 1;\n        let recoverables = null;\n        let hasMirrors = this.mirror.length > 0, rec, mirror, deleted = false;\n        for (let i = fromI - (dir < 0 ? 1 : 0), endI = toI - (dir < 0 ? 1 : 0); i != endI; i += dir) {\n            let { from, to, length } = this.changes[i];\n            if (dir < 0) {\n                let len = to - from;\n                to = from + length;\n                length = len;\n            }\n            if (pos < from)\n                continue;\n            if (pos > to) {\n                pos += length - (to - from);\n                continue;\n            }\n            // Change touches this position\n            if (recoverables && (rec = recoverables[i]) != null) { // There's a recovery for this change, and it applies\n                pos = from + rec;\n                continue;\n            }\n            if (hasMirrors && (mirror = this.getMirror(i)) != null &&\n                (dir > 0 ? mirror > i && mirror < toI : mirror < i && mirror >= toI)) { // A mirror exists\n                if (pos > from && pos < to) { // If this change deletes the position, skip forward to the mirror\n                    i = mirror;\n                    pos = this.changes[i].from + (pos - from);\n                    continue;\n                }\n                (recoverables || (recoverables = {}))[mirror] = pos - from;\n            }\n            if (pos > from && pos < to) {\n                if (mode != MapMode.Simple)\n                    deleted = true;\n                pos = bias <= 0 ? from : from + length;\n            }\n            else {\n                if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)\n                    deleted = true;\n                pos = (from == to ? bias <= 0 : pos == from) ? from : from + length;\n            }\n        }\n        return deleted ? -pos - 1 : pos;\n    }\n    /// Check whether these changes touch a given range. When one of the\n    /// changes entirely covers the range, the string `\"cover\"` is\n    /// returned.\n    touchesRange(from, to) {\n        let result = false;\n        for (let change of this.changes) {\n            if (change.to >= from && change.from <= to) {\n                if (change.from < from && change.to > to)\n                    return \"cover\";\n                result = true;\n            }\n            let diff = change.length - (change.to - change.from);\n            if (from > change.from)\n                from += diff;\n            if (to > change.to)\n                to += diff;\n        }\n        return result;\n    }\n    /// Get a partial [mapping](#state.Mapping) covering part of this\n    /// change set.\n    partialMapping(from, to = this.length) {\n        if (from == 0 && to == this.length)\n            return this;\n        return new PartialMapping(this, from, to);\n    }\n    /// Summarize this set of changes as a minimal sequence of changed\n    /// ranges, sored by position. For example, if you have changes\n    /// deleting between 1 and 4 and inserting a character at 1, the\n    /// result would be a single range saying 1 to 4 in the old doc was\n    /// replaced with range 1 to 2 in the new doc.\n    changedRanges() {\n        if (this._changedRanges)\n            return this._changedRanges;\n        let set = [];\n        for (let i = 0; i < this.length; i++) {\n            let change = this.changes[i];\n            let fromA = change.from, toA = change.to, fromB = change.from, toB = change.from + change.length;\n            if (i < this.length - 1) {\n                let mapping = this.partialMapping(i + 1);\n                fromB = mapping.mapPos(fromB, 1);\n                toB = mapping.mapPos(toB, -1);\n            }\n            if (i > 0) {\n                let mapping = this.partialMapping(i, 0);\n                fromA = mapping.mapPos(fromA, 1);\n                toA = mapping.mapPos(toA, -1);\n            }\n            new ChangedRange(fromA, toA, fromB, toB).addToSet(set);\n        }\n        return this._changedRanges = set;\n    }\n    /// Convert a set of changes to a set of change descriptions.\n    get desc() {\n        if (this.changes.length == 0 || this.changes[0] instanceof ChangeDesc)\n            return this;\n        return new ChangeSet(this.changes.map(ch => ch.desc), this.mirror);\n    }\n    /// Create a JSON-serializable representation of this change set.\n    toJSON() {\n        let changes = this.changes.map(change => change.toJSON());\n        return this.mirror.length == 0 ? changes : { mirror: this.mirror, changes };\n    }\n    /// Read a change set from its JSON representation.\n    static fromJSON(ChangeType, json) {\n        let mirror, changes;\n        if (Array.isArray(json)) {\n            mirror = empty;\n            changes = json;\n        }\n        else if (!json || !Array.isArray(json.mirror) || !Array.isArray(json.changes)) {\n            throw new RangeError(\"Invalid JSON representation for ChangeSet\");\n        }\n        else {\n            ({ mirror, changes } = json);\n        }\n        return new ChangeSet(changes.map((ch) => ChangeType.fromJSON(ch)), mirror);\n    }\n}\n/// The empty change set.\nChangeSet.empty = new ChangeSet(empty);\nclass PartialMapping {\n    constructor(changes, from, to) {\n        this.changes = changes;\n        this.from = from;\n        this.to = to;\n    }\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        return this.changes.mapInner(pos, bias, mode, this.from, this.to);\n    }\n}\n/// A changed range represents a replacement as two absolute ranges,\n/// one pointing into the old document (the replaced content) and one\n/// pointing into the new document (the content that replaces it).\nclass ChangedRange {\n    // FIXME store unchanged ranges instead?\n    constructor(\n    /// The start of the replaced range in the old document.\n    fromA, \n    /// The end of the replaced range in the old document.\n    toA, \n    /// The start of the replacing range in the new document.\n    fromB, \n    /// The end of the replacing range in the new document.\n    toB) {\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    /// @internal\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    /// @internal\n    // FIXME used by view. Document?\n    addToSet(set) {\n        let i = set.length, me = this;\n        for (; i > 0; i--) {\n            let range = set[i - 1];\n            if (range.fromA > me.toA)\n                continue;\n            if (range.toA < me.fromA)\n                break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    /// The difference in document length created by this change\n    /// (positive when the document grew).\n    get lenDiff() { return (this.toB - this.fromB) - (this.toA - this.fromA); }\n    /// @internal\n    static mapPos(pos, bias, changes) {\n        let off = 0;\n        for (let range of changes) {\n            if (pos < range.fromA)\n                break;\n            if (pos <= range.toA) {\n                let side = range.toA == range.fromA ? bias : pos == range.fromA ? -1 : pos == range.toA ? 1 : bias;\n                return side < 0 ? range.fromB : range.toB;\n            }\n            off = range.toB - range.toA;\n        }\n        return pos + off;\n    }\n}\n\n/// Changes to the editor state are grouped into transactions.\n/// Usually, a user action creates a single transaction, which may\n/// contain zero or more document changes. Create a transaction by\n/// calling [`EditorState.t`](#state.EditorState.t).\n///\n/// Transactions are mutable, and usually built up piece by piece with\n/// updating methods and method chaining (most methods return the\n/// transaction itself). Once they are\n/// [applied](#state.Transaction.apply), they can't be updated\n/// anymore.\nclass Transaction {\n    /// @internal\n    constructor(\n    /// The state from which the transaction starts.\n    startState, time = Date.now()) {\n        this.startState = startState;\n        /// The document changes made by this transaction.\n        this.changes = ChangeSet.empty;\n        /// The document versions after each of the changes.\n        this.docs = [];\n        this._annotations = Object.create(null);\n        this.flags = 0;\n        /// @internal\n        this.reconfigureData = null;\n        this.state = null;\n        this.selection = startState.selection;\n        this._annotations[Transaction.time.id] = time;\n    }\n    /// The document at the end of the transaction.\n    get doc() {\n        let last = this.docs.length - 1;\n        return last < 0 ? this.startState.doc : this.docs[last];\n    }\n    /// Add annotations to this transaction. Annotations can provide\n    /// additional information about the transaction.\n    annotate(annotation, value) {\n        this.ensureOpen();\n        this._annotations[annotation.id] = value;\n        return this;\n    }\n    /// Get the value of the given annotation type, if any.\n    annotation(annotation) {\n        return this._annotations[annotation.id];\n    }\n    /// Add a change to this transaction. If `mirror` is given, it\n    /// should be the index (in `this.changes.changes`) at which the\n    /// mirror image of this change sits.\n    change(change, mirror) {\n        this.ensureOpen();\n        if (change.from == change.to && change.length == 0)\n            return this;\n        if (change.from < 0 || change.to < change.from || change.to > this.doc.length)\n            throw new RangeError(`Invalid change ${change.from} to ${change.to}`);\n        this.changes = this.changes.append(change, mirror);\n        this.docs.push(change.apply(this.doc));\n        this.selection = this.selection.map(change);\n        return this;\n    }\n    /// Indicates whether the transaction changed the document.\n    get docChanged() {\n        return this.changes.length > 0;\n    }\n    /// Add a change replacing the given document range with the given\n    /// content.\n    replace(from, to, text) {\n        return this.change(new Change(from, to, typeof text == \"string\" ? this.startState.splitLines(text) : text));\n    }\n    /// Replace all selection ranges with the given content.\n    replaceSelection(text) {\n        let content = typeof text == \"string\" ? this.startState.splitLines(text) : text;\n        return this.forEachRange(range => {\n            let change = new Change(range.from, range.to, content);\n            this.change(change);\n            return new SelectionRange(range.from + change.length);\n        });\n    }\n    /// Run the given function for each selection range. The method will\n    /// map the ranges to reflect deletions/insertions that happen\n    /// before them. At the end, set the new selection to the ranges\n    /// returned by the function (again, automatically mapped to for\n    /// changes that happened after them).\n    forEachRange(f) {\n        let sel = this.selection, start = this.changes.length, newRanges = [];\n        for (let range of sel.ranges) {\n            let before = this.changes.length;\n            let result = f(range.map(this.changes.partialMapping(start)), this);\n            if (this.changes.length > before) {\n                let mapping = this.changes.partialMapping(before);\n                for (let i = 0; i < newRanges.length; i++)\n                    newRanges[i] = newRanges[i].map(mapping);\n            }\n            newRanges.push(result);\n        }\n        return this.setSelection(EditorSelection.create(newRanges, sel.primaryIndex));\n    }\n    /// Update the selection.\n    setSelection(selection) {\n        this.ensureOpen();\n        if (!this.startState.facet(allowMultipleSelections))\n            selection = selection.asSingle();\n        checkSelection(selection, this.doc);\n        this.selection = selection;\n        this.flags |= 1 /* SelectionSet */;\n        return this;\n    }\n    /// Tells you whether this transaction explicitly sets a new\n    /// selection (as opposed to just mapping the selection through\n    /// changes).\n    get selectionSet() {\n        return (this.flags & 1 /* SelectionSet */) > 0;\n    }\n    /// Set a flag on this transaction that indicates that the editor\n    /// should scroll the selection into view after applying it.\n    scrollIntoView() {\n        this.ensureOpen();\n        this.flags |= 2 /* ScrollIntoView */;\n        return this;\n    }\n    /// Query whether the selection should be scrolled into view after\n    /// applying this transaction.\n    get scrolledIntoView() {\n        return (this.flags & 2 /* ScrollIntoView */) > 0;\n    }\n    /// Provice new content for a given [extension\n    /// group](#state.ExtensionGroup) in the current configuration. (If\n    /// the group isn't present in the configuration, this will not have\n    /// any effect.)\n    replaceExtension(group, content) {\n        this.ensureOpen();\n        if (!this.reconfigureData) {\n            let replaced = new Map();\n            this.startState.config.replacements.forEach((ext, group) => replaced.set(group, ext));\n            this.reconfigureData = { base: this.startState.config.source, replaced };\n        }\n        this.reconfigureData.replaced.set(group, content);\n        return this;\n    }\n    /// Move to an entirely new state configuration.\n    reconfigure(extension) {\n        this.ensureOpen();\n        this.reconfigureData = { base: extension, replaced: new Map };\n        return this;\n    }\n    /// Indicates whether the transaction reconfigures the state.\n    get reconfigured() {\n        return this.reconfigureData != null;\n    }\n    ensureOpen() {\n        if (this.state)\n            throw new Error(\"Transactions may not be modified after being applied\");\n    }\n    /// Apply this transaction, computing a new editor state. May be\n    /// called multiple times (the result is cached). The transaction\n    /// cannot be further modified after this has been called.\n    apply() {\n        return this.state || (this.state = this.startState.applyTransaction(this));\n    }\n    /// Create a set of changes that undo the changes made by this\n    /// transaction.\n    invertedChanges() {\n        if (!this.changes.length)\n            return ChangeSet.empty;\n        let changes = [], set = this.changes;\n        for (let i = set.length - 1; i >= 0; i--)\n            changes.push(set.changes[i].invert(i == 0 ? this.startState.doc : this.docs[i - 1]));\n        return new ChangeSet(changes, set.mirror.length ? set.mirror.map(i => set.length - i - 1) : set.mirror);\n    }\n}\n/// Annotation used to store transaction timestamps.\nTransaction.time = Annotation.define();\n/// Annotation used to indicate that this transaction shouldn't\n/// clear the goal column, which is used during vertical cursor\n/// motion (so that moving over short lines doesn't reset the\n/// horizontal position to the end of the shortest line). Should\n/// generally only be set by commands that perform vertical motion.\nTransaction.preserveGoalColumn = Annotation.define();\n/// Annotation used to associate a transaction with a user interface\n/// event. The view will set this to...\n///\n///  - `\"paste\"` when pasting content\n///  - `\"cut\"` when cutting\n///  - `\"drop\"` when content is inserted via drag-and-drop\n///  - `\"keyboard\"` when moving the selection via the keyboard\n///  - `\"pointer\"` when moving the selection through the pointing device\nTransaction.userEvent = Annotation.define();\n/// Annotation indicating whether a transaction should be added to\n/// the undo history or not.\nTransaction.addToHistory = Annotation.define();\n\nconst DefaultIndentUnit = 2, DefaultTabsize = 4, DefaultSplit = /\\r\\n?|\\n/;\n/// The editor state class is a persistent (immutable) data structure.\n/// To update a state, you [create](#state.EditorState.t) and\n/// [apply](#state.Transaction.apply) a\n/// [transaction](#state.Transaction), which produces a _new_ state\n/// instance, without modifying the original object.\n///\n/// As such, _never_ mutate properties of a state directly. That'll\n/// just break things.\nclass EditorState {\n    /// @internal\n    constructor(\n    /// @internal\n    config, \n    /// The current document.\n    doc, \n    /// The current selection.\n    selection, tr = null) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        /// @internal\n        this.applying = null;\n        this.status = config.statusTemplate.slice();\n        if (tr && !tr.reconfigured) {\n            this.values = tr.startState.values.slice();\n        }\n        else {\n            this.values = config.dynamicSlots.map(_ => null);\n            // Copy over old values for shared facets/fields if this is a reconfigure\n            if (tr)\n                for (let id in config.address) {\n                    let cur = config.address[id], prev = tr.startState.config.address[id];\n                    if (prev != null && (cur & 1) == 0)\n                        this.values[cur >> 1] = getAddr(tr.startState, prev);\n                }\n        }\n        this.applying = tr;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.applying = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Start a new transaction from this state. When not given, the\n    /// timestamp defaults to\n    /// [`Date.now()`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now).\n    t(timestamp) {\n        return new Transaction(this, timestamp);\n    }\n    /// Join an array of lines using the state's [line\n    /// separator](#state.EditorState^lineSeparator).\n    joinLines(text) { return text.join(this.facet(EditorState.lineSeparator) || \"\\n\"); }\n    /// Split a string into lines using the state's [line\n    /// separator](#state.EditorState^lineSeparator).\n    splitLines(text) { return text.split(this.facet(EditorState.lineSeparator) || DefaultSplit); }\n    /// Get the value of a state [behavior](#extension.Behavior).\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Convert this state to a JSON-serializable object.\n    toJSON() {\n        // FIXME plugin state serialization\n        return {\n            doc: this.joinLines(this.doc.sliceLines(0, this.doc.length)),\n            selection: this.selection.toJSON()\n        };\n    }\n    /// Deserialize a state from its JSON representation.\n    static fromJSON(json, config = {}) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions\n        });\n    }\n    /// @internal\n    applyTransaction(tr) {\n        let reconf = tr.reconfigureData, config = reconf ? Configuration.resolve(reconf.base, reconf.replaced, this) : this.config;\n        return new EditorState(config, tr.doc, tr.selection, tr);\n    }\n    /// Create a new state. You'll usually only need this when\n    /// initializing an editorupdated states are created by applying\n    /// transactions.\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || []);\n        let doc = config.doc instanceof Text ? config.doc\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = config.selection || EditorSelection.single(0);\n        checkSelection(selection, doc);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection);\n    }\n    /// The size (in columns) of a tab in the document, determined by\n    /// the [`tabSize`](#state.EditorState^tabSize) behavior.\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /// The size of an indent unit in the document. Determined by the\n    /// [`indentUnit`](#state.EditorState^indentUnit) facet.\n    get indentUnit() { return this.facet(EditorState.indentUnit); }\n    /// Get the syntax tree for this state, which is the current\n    /// (possibly incomplete) parse tree of the [syntax](#state.Syntax)\n    /// with the highest precedence, or the empty tree if there is no\n    /// syntax available.\n    get tree() {\n        let syntax = this.facet(EditorState.syntax);\n        return syntax.length ? syntax[0].getTree(this) : Tree.empty;\n    }\n}\n/// A facet that, when enabled, causes the editor to allow multiple\n/// ranges to be selected. You should probably not use this\n/// directly, but let a plugin like\n/// [multiple-selections](#multiple-selections) handle it (which\n/// also makes sure the selections are visible in the view).\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/// Facet that defines a way to query for automatic indentation\n/// depth at the start of a given line.\nEditorState.indentation = Facet.define();\n/// Configures the tab size to use in this state. The first\n/// (highest-precedence) value of the behavior is used.\nEditorState.tabSize = Facet.define({\n    combine: values => values.length ? values[0] : DefaultTabsize\n});\n/// The line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\n/// and `\"\\r\"` is treated as a separator when splitting lines, and\n/// lines are joined with `\"\\n\"`.\n///\n/// When you configure a value here, only that precise separator\n/// will be used, allowing you to round-trip documents through the\n/// editor without normalizing line separators.\nEditorState.lineSeparator = Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\n/// Facet for overriding the unit (in columns) by which\n/// indentation happens. When not set, this defaults to 2.\nEditorState.indentUnit = Facet.define({\n    combine: values => values.length ? values[0] : DefaultIndentUnit\n});\n/// Facet that registers a parsing service for the state.\nEditorState.syntax = Facet.define();\n/// A facet that registers a code folding service. When called\n/// with the extent of a line, it'll return a range object when a\n/// foldable that starts on that line (but continues beyond it) can\n/// be found.\nEditorState.foldable = Facet.define();\n\n/// Utility function for combining behaviors to fill in a config\n/// object from an array of provided configs. Will, by default, error\n/// when a field gets two values that aren't ===-equal, but you can\n/// provide combine functions per field to do something else.\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n/// Defaults the fields in a configuration object to values given in\n/// `defaults` if they are not already present.\nfunction fillConfig(config, defaults) {\n    let result = {};\n    for (let key in config)\n        result[key] = config[key];\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\nexport { Annotation, Change, ChangeDesc, ChangeSet, ChangedRange, EditorSelection, EditorState, ExtensionGroup, Facet, MapMode, Precedence, SelectionRange, StateField, Transaction, combineConfig, fillConfig, languageData };\n","function sym(name, random) {\n  return typeof Symbol == \"undefined\"\n    ? \"__\" + name + (random ? Math.floor(Math.random() * 1e8) : \"\")\n    : random ? Symbol(name) : Symbol.for(name)\n}\n\nconst COUNT = sym(\"\\u037c\"), SET = sym(\"styleSet\", 1), RULES = sym(\"rules\", 1)\nconst top = typeof global == \"undefined\" ? window : global\n\n// :: (Object<Style>, ?{generateClasses: ?boolean})  StyleModule\n// Instances of this class bind the property names from `spec` to CSS\n// class names that assign the styles in the corresponding property\n// values, unless `generateClasses` is `false`, in which case the\n// property names in the spec are treated as plain CSS selectors.\n//\n// A style module can only be used in a given DOM root after it has\n// been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nexport function StyleModule(spec, options) {\n  this[RULES] = []\n  for (let name in spec) {\n    let style = spec[name], specificity = style.specificity || 0\n    let id = StyleModule.newName(), selector = name\n    if ((options && options.generateClasses) !== false) {\n      let className = id\n      selector = \".\" + id\n      for (let i = 0; i < specificity; i++) {\n        let name = \"\\u037c_\" + (i ? i.toString(36) : \"\")\n        selector += \".\" + name\n        className += \" \" + name\n      }\n      this[name] = className\n    }\n    renderStyle(selector, spec[name], this[RULES])\n  }\n}\n\n// :: ()  string\n// Generate a new unique CSS class name.\nStyleModule.newName = () => {\n  let id = top[COUNT] || 1\n  top[COUNT] = id + 1\n  return \"\\u037c\" + id.toString(36)\n}\n\nStyleModule.prototype = Object.create(null)\n\n// :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n//\n// Mount the given set of modules in the given DOM root, which ensures\n// that the CSS rules defined by the module are available in that\n// context.\n//\n// Rules are only added to the document once per root.\n//\n// Rule order will follow the order of the modules, so that rules from\n// modules later in the array take precedence of those from earlier\n// modules. If you call this function multiple times for the same root\n// in a way that changes the order of already mounted modules, the old\n// order will be changed.\nStyleModule.mount = function(root, modules) {\n  (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\n}\n\nclass StyleSet {\n  constructor(root) {\n    this.root = root\n    root[SET] = this\n    this.styleTag = (root.ownerDocument || root).createElement(\"style\")\n    let target = root.head || root\n    target.insertBefore(this.styleTag, target.firstChild)\n    this.modules = []\n  }\n\n  mount(modules) {\n    let sheet = this.styleTag.sheet, reset = !sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (!reset) for (let k = 0; k < mod[RULES].length; k++)\n          sheet.insertRule(mod[RULES][k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++][RULES].length\n        pos += mod[RULES].length\n        j++\n      }\n    }\n\n    if (reset) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i][RULES].join(\"\\n\") + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n}\n\nfunction renderStyle(selector, spec, output) {\n  if (typeof spec != \"object\") throw new RangeError(\"Expected style object, got \" + JSON.stringify(spec))\n  let props = []\n  for (let prop in spec) {\n    if (/^@/.test(prop)) {\n      let local = []\n      renderStyle(selector, spec[prop], local)\n      output.push(prop + \" {\" + local.join(\" \") + \"}\")\n    } else if (/&/.test(prop)) {\n      renderStyle(prop.replace(/&/g, selector), spec[prop], output)\n    } else if (prop != \"specificity\") {\n      if (typeof spec[prop] == \"object\") throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n      props.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + spec[prop])\n    }\n  }\n  if (props.length) output.push(selector + \" {\" + props.join(\"; \") + \"}\")\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-casethe library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property called `specificity` has a special meaning: if it holds\n// a number _N_, greater than 0, the selector for the class will have\n// _N_ extra dummy classes added, and those dummy classes will also be\n// present in the class name string created for the style. This allows\n// you to create rules that take precedence over other rules, even\n// when they are defined earlier.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n","import { MapMode } from '../../state';\n\n/// Each range is associated with a value, which must inherit from\n/// this class.\nclass RangeValue {\n    /// Compare this value with another value. The default\n    /// implementation compares by identity.\n    eq(other) { return this == other; }\n    /// Create a [range](#rangeset.Range) with this value.\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.startMapMode = RangeValue.prototype.endMapMode = MapMode.TrackDel;\n/// A range associates a value with a range of positions.\nclass Range {\n    /// @internal\n    constructor(\n    /// The range's start position.\n    from, \n    /// Its end position.\n    to, \n    /// The value associated with this range.\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\n// The maximum amount of ranges to store in a single chunk\nconst ChunkSize = 250, \n// Chunks with points of this size are never skipped during\n// compare, since moving past those points is likely to speed\n// up, rather than slow down, the comparison.\nBigPointSize = 500, \n// A large (fixnum) value to use for max/min values.\nFar = 1e9;\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * Far, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i];\n            let newFrom = changes.mapPos(this.from[i] + offset, val.startSide, val.startMapMode);\n            let newTo = changes.mapPos(this.to[i] + offset, val.endSide, val.endMapMode);\n            if (newTo < 0) {\n                if (newFrom < 0)\n                    continue;\n                newTo = -(newTo + 1);\n            }\n            if (newFrom < 0)\n                newFrom = -(newFrom + 1);\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/// A range set stores a collection of [ranges](#rangeset.Range) in a\n/// way that makes them efficient to [map](#rangeset.RangeSet.map) and\n/// [update](#rangeset.RangeSet.update). This is an immutable data\n/// structure.\nclass RangeSet {\n    /// @internal\n    constructor(\n    /// @internal\n    chunkPos, \n    /// @internal\n    chunk, \n    /// @internal\n    nextLayer = RangeSet.empty, \n    /// @internal\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /// @internal\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /// @internal\n    get size() {\n        if (this == RangeSet.empty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /// @internal\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /// Update the range set, optionally adding new ranges or filtering\n    /// out existing ones.\n    update({ add = [], sort = false, filter, filterFrom = 0, filterTo = this.length }) {\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this == RangeSet.empty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /// Map this range set through a set of changes, return the new set.\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /// Iterate over the ranges that touch the region `from` to `to`,\n    /// calling `f` for each. There is no guarantee that the ranges will\n    /// be reported in any order. When the callback returns `false`,\n    /// iteration stops.\n    between(from, to, f) {\n        if (this == RangeSet.empty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /// Iterate over the ranges in the set that touch the area between\n    /// from and to, ordered by their start position and side.\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /// Iterate over two groups of sets, calling methods on `comparator`\n    /// to notify it of possible differences. `textDiff` indicates how\n    /// the underlying data changed between these ranges, and is needed\n    /// to synchronize the iteration. `from` and `to` are coordinates in\n    /// the _new_ space, after these changes.\n    static compare(oldSets, newSets, textDiff, length, comparator) {\n        var _a;\n        let minPoint = (_a = comparator.minPointSize, (_a !== null && _a !== void 0 ? _a : -1));\n        let a = oldSets.filter(set => set.maxPoint >= BigPointSize ||\n            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPoint);\n        let b = newSets.filter(set => set.maxPoint >= BigPointSize ||\n            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPoint);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPoint);\n        let sideB = new SpanCursor(b, sharedChunks, minPoint);\n        let posA = 0, posB = 0;\n        for (let range of textDiff) {\n            compare(sideA, posA, sideB, posB, range.fromB - posB, comparator);\n            posA = range.toA;\n            posB = range.toB;\n        }\n        compare(sideA, posA, sideB, posB, length - posB, comparator);\n    }\n    /// Iterate over a group of range sets at the same time, notifying\n    /// the iterator about the ranges covering every given piece of\n    /// content.\n    static spans(sets, from, to, iterator) {\n        var _a;\n        let cursor = new SpanCursor(sets, null, (_a = iterator.minPointSize, (_a !== null && _a !== void 0 ? _a : -1))).goto(from), pos = from;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point)\n                iterator.point(pos, curTo, cursor.point, cursor.pointFrom < from, cursor.to > to);\n            else if (curTo > pos)\n                iterator.span(pos, curTo, cursor.active);\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /// Create a range set for the given range or array of ranges. By\n    /// default, this expects the ranges to be _sorted_ (by start\n    /// position and, if two start at the same position,\n    /// `value.startSide`). You can pass `true` as second argument to\n    /// cause the method to sort them.\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/// The empty set of ranges.\nRangeSet.empty = new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/// A range set builder is a data structure that helps build up a\n/// [range set](#rangeset.RangeSet) directly, without first allocating\n/// an array of [`Range`](#rangeset.Range) objects.\nclass RangeSetBuilder {\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -Far;\n        this.lastTo = -Far;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /// Add a range. Ranges should be added in sorted (by `from` and\n    /// `value.startSide`) order.\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /// @internal\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == ChunkSize)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /// @internal\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /// Finish the range set. Returns the new set. The builder can't be\n    /// used anymore after this has been called.\n    finish() { return this.finishInner(RangeSet.empty); }\n    /// @internal\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < BigPointSize)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -Far) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = Far;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let set of sets)\n            for (let cur = set; cur != RangeSet.empty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint));\n            }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -Far) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = Far;\n            this.value = null;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.to = -Far;\n        this.endSide = 0;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -Far) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to;\n        this.point = null;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = Far;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.active.push(nextVal);\n                    this.activeTo.push(this.cursor.to);\n                    this.minActive = findMinIndex(this.active, this.activeTo);\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameSet(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    outer: for (let i = 0; i < a.length; i++) {\n        for (let j = 0; j < b.length; j++)\n            if (a[i] == b[i] || a[i].eq(b[j]))\n                continue outer;\n        return false;\n    }\n    return true;\n}\nfunction remove(array, index) {\n    let last = array.pop();\n    if (index != array.length)\n        array[index] = last;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = Far;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n","import { MapMode, Facet, ChangeSet, ChangedRange, SelectionRange, EditorSelection, Change, Transaction, EditorState, Precedence } from '../../state';\nimport { StyleModule } from 'style-mod';\nimport { RangeValue, RangeSet } from '../../rangeset';\nexport { Range } from '../../rangeset';\nimport { Text, countColumn, findColumn, isExtendingChar } from '../../text';\n\nlet [nav, doc] = typeof navigator != \"undefined\"\n    ? [navigator, document]\n    : [{ userAgent: \"\", vendor: \"\", platform: \"\" }, { documentElement: { style: {} } }];\nconst ie_edge = /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = !ie && 'WebkitAppearance' in doc.documentElement.style;\nvar browser = {\n    mac: /Mac/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +(/Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios: !ie && /AppleWebKit/.test(nav.userAgent) && /Mobile\\/\\w+/.test(nav.userAgent),\n    android: /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari: /Apple Computer/.test(nav.vendor),\n    webkit_version: webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\n\nfunction getSelection(root) {\n    return (root.getSelection ? root.getSelection() : document.getSelection());\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nfunction selectionCollapsed(domSel) {\n    let collapsed = domSel.isCollapsed;\n    if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n        collapsed = false;\n    return collapsed;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return dom.contains(selection.anchorNode.nodeType == 3 ? selection.anchorNode.parentNode : selection.anchorNode);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) {\n        let range = document.createRange();\n        range.setEnd(dom, dom.nodeValue.length);\n        range.setStart(dom, 0);\n        return range.getClientRects();\n    }\n    else if (dom.nodeType == 1) {\n        return dom.getClientRects();\n    }\n    else {\n        return [];\n    }\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\n}\nfunction domIndex(node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\")\n                return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1)\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            off = dir < 0 ? maxOffset(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction windowRect(win) {\n    return { left: 0, right: win.innerWidth,\n        top: 0, bottom: win.innerHeight };\n}\nconst ScrollSpace = 5;\nfunction scrollRectIntoView(dom, rect) {\n    let doc = dom.ownerDocument, win = doc.defaultView;\n    for (let cur = dom.parentNode; cur;) {\n        if (cur.nodeType == 1) { // Element\n            let bounding, top = cur == document.body;\n            if (top) {\n                bounding = windowRect(win);\n            }\n            else {\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth,\n                    top: rect.top, bottom: rect.top + cur.clientHeight };\n            }\n            let moveX = 0, moveY = 0;\n            if (rect.top < bounding.top)\n                moveY = -(bounding.top - rect.top + ScrollSpace);\n            else if (rect.bottom > bounding.bottom)\n                moveY = rect.bottom - bounding.bottom + ScrollSpace;\n            if (rect.left < bounding.left)\n                moveX = -(bounding.left - rect.left + ScrollSpace);\n            else if (rect.right > bounding.right)\n                moveX = rect.right - bounding.right + ScrollSpace;\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                }\n                else {\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY;\n                        moveY = cur.scrollTop - start;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX;\n                        moveX = cur.scrollLeft - start;\n                    }\n                    rect = { left: rect.left - moveX, top: rect.top - moveY,\n                        right: rect.right - moveX, bottom: rect.bottom - moveY };\n                }\n            }\n            if (top)\n                break;\n            cur = cur.parentNode;\n        }\n        else if (cur.nodeType == 11) { // A shadow root\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n}\nclass DOMSelection {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    set(domSel) {\n        this.anchorNode = domSel.anchorNode;\n        this.anchorOffset = domSel.anchorOffset;\n        this.focusNode = domSel.focusNode;\n        this.focusOffset = domSel.focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stack = [];\n    for (let cur = dom; cur; cur = cur.parentNode) {\n        stack.push(cur, dom.scrollTop, dom.scrollLeft);\n        if (cur == cur.ownerDocument)\n            break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for (let i = 0; i < stack.length;) {\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top)\n                elt.scrollTop = top;\n            if (elt.scrollLeft != left)\n                elt.scrollLeft = left;\n        }\n    }\n}\n\nclass DOMPos {\n    constructor(node, offset, precise = true) {\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\n}\nconst none = [];\nclass ContentView {\n    constructor() {\n        this.parent = null;\n        this.dom = null;\n        this.dirty = 2 /* Node */;\n    }\n    get editorView() {\n        if (!this.parent)\n            throw new Error(\"Accessing view in orphan content view\");\n        return this.parent.editorView;\n    }\n    get overrideDOMText() { return null; }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children) {\n            if (child == view)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    coordsAt(pos) { return null; }\n    sync() {\n        if (this.dirty & 2 /* Node */) {\n            let parent = this.dom, pos = parent.firstChild;\n            for (let child of this.children) {\n                if (child.dirty) {\n                    if (pos && !child.dom && !ContentView.get(pos)) {\n                        let prev = pos.previousSibling;\n                        if (child.reuseDOM(pos))\n                            pos = prev ? prev.nextSibling : parent.firstChild;\n                    }\n                    child.sync();\n                    child.dirty = 0 /* Not */;\n                }\n                pos = syncNodeInto(parent, pos, child.dom);\n            }\n            while (pos)\n                pos = rm(pos);\n        }\n        else if (this.dirty & 1 /* Child */) {\n            for (let child of this.children)\n                if (child.dirty) {\n                    child.sync();\n                    child.dirty = 0 /* Not */;\n                }\n        }\n    }\n    reuseDOM(dom) { return false; }\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        }\n        else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for (;;) {\n                let parent = node.parentNode;\n                if (parent == this.dom)\n                    break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild)\n                        bias = -1;\n                    else\n                        bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0)\n                after = node;\n            else\n                after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild)\n            return 0;\n        while (after && !ContentView.get(after))\n            after = after.nextSibling;\n        if (!after)\n            return this.length;\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i];\n            if (child.dom == after)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for (let i = 0, pos = offset; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to)\n                return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (end >= to && toI == -1) {\n                toI = i;\n                toEnd = end;\n                break;\n            }\n            pos = end + child.breakAfter;\n        }\n        return { from: fromStart, to: toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length - 1 ? this.children[toI + 1].dom : null };\n    }\n    // FIXME track precise dirty ranges, to avoid full DOM sync on every touched node?\n    markDirty(andParent = false) {\n        if (this.dirty & 2 /* Node */)\n            return;\n        this.dirty |= 2 /* Node */;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for (let parent = this.parent; parent; parent = parent.parent) {\n            if (childList)\n                parent.dirty |= 2 /* Node */;\n            if (parent.dirty & 1 /* Child */)\n                return;\n            parent.dirty |= 1 /* Child */;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.dirty)\n                this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for (let v = this;;) {\n            let parent = v.parent;\n            if (!parent)\n                return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = none) {\n        this.markDirty();\n        for (let i = from; i < to; i++)\n            this.children[i].parent = null;\n        this.children.splice(from, to - from, ...children);\n        for (let i = 0; i < children.length; i++)\n            children[i].setParent(this);\n    }\n    ignoreMutation(rec) { return false; }\n    ignoreEvent(event) { return false; }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\n            (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) { return node.cmView; }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nfunction syncNodeInto(parent, pos, dom) {\n    if (dom.parentNode == parent) {\n        while (pos != dom)\n            pos = rm(pos);\n        pos = dom.nextSibling;\n    }\n    else {\n        parent.insertBefore(dom, pos);\n    }\n    return pos;\n}\nclass ChildCursor {\n    constructor(children, pos, i) {\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for (;;) {\n            if (pos > this.pos || pos == this.pos &&\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\n\nfunction combineAttrs(source, target) {\n    for (let name in source) {\n        if (name == \"class\" && target.class)\n            target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style)\n            target.style += \";\" + source.style;\n        else\n            target[name] = source[name];\n    }\n    return target;\n}\nfunction attrsEq(a, b) {\n    if (a == b)\n        return true;\n    if (!a || !b)\n        return false;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length != keysB.length)\n        return false;\n    for (let key of keysA) {\n        if (keysB.indexOf(key) == -1 || a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    if (prev)\n        for (let name in prev)\n            if (!(attrs && name in attrs))\n                dom.removeAttribute(name);\n    if (attrs)\n        for (let name in attrs)\n            if (!(prev && prev[name] == attrs[name]))\n                dom.setAttribute(name, attrs[name]);\n}\n\nconst none$1 = [];\nclass InlineView extends ContentView {\n    match(other) { return false; }\n    get children() { return none$1; }\n    getSide() { return 0; }\n}\nconst MaxJoinLen = 256;\nclass TextView extends InlineView {\n    constructor(text, tagName, clss, attrs) {\n        super();\n        this.text = text;\n        this.tagName = tagName;\n        this.attrs = attrs;\n        this.textDOM = null;\n        this.class = clss;\n    }\n    get length() { return this.text.length; }\n    createDOM(textDOM) {\n        let tagName = this.tagName || (this.attrs || this.class ? \"span\" : null);\n        this.textDOM = textDOM || document.createTextNode(this.text);\n        if (tagName) {\n            let dom = document.createElement(tagName);\n            dom.appendChild(this.textDOM);\n            if (this.class)\n                dom.className = this.class;\n            if (this.attrs)\n                for (let name in this.attrs)\n                    dom.setAttribute(name, this.attrs[name]);\n            this.setDOM(dom);\n        }\n        else {\n            this.setDOM(this.textDOM);\n        }\n    }\n    sync() {\n        if (!this.dom)\n            this.createDOM();\n        if (this.textDOM.nodeValue != this.text) {\n            this.textDOM.nodeValue = this.text;\n            let dom = this.dom;\n            if (this.textDOM != dom && (this.dom.firstChild != this.textDOM || dom.lastChild != this.textDOM)) {\n                while (dom.firstChild)\n                    dom.removeChild(dom.firstChild);\n                dom.appendChild(this.textDOM);\n            }\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType != 3)\n            return false;\n        this.createDOM(dom);\n        return true;\n    }\n    merge(from, to = this.length, source = null) {\n        if (source &&\n            (!(source instanceof TextView) ||\n                source.tagName != this.tagName || source.class != this.class ||\n                !attrsEq(source.attrs, this.attrs) || this.length - (to - from) + source.length > MaxJoinLen))\n            return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    slice(from, to = this.length) {\n        return new TextView(this.text.slice(from, to), this.tagName, this.class, this.attrs);\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.textDOM ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) { return new DOMPos(this.textDOM, pos); }\n    domBoundsAround(from, to, offset) {\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n    }\n    coordsAt(pos) {\n        return textCoords(this.textDOM, pos);\n    }\n}\nfunction textCoords(text, pos) {\n    let range = document.createRange();\n    if (browser.chrome || browser.gecko) {\n        // These browsers reliably return valid rectangles for empty ranges\n        range.setEnd(text, pos);\n        range.setStart(text, pos);\n        return range.getBoundingClientRect();\n    }\n    else {\n        // Otherwise, get the rectangle around a character and take one side\n        let extend = pos == 0 ? 1 : -1;\n        range.setEnd(text, pos + (extend > 0 ? 1 : 0));\n        range.setStart(text, pos - (extend < 0 ? 1 : 0));\n        let rect = range.getBoundingClientRect();\n        let x = extend < 0 ? rect.right : rect.left;\n        return { left: x, right: x, top: rect.top, bottom: rect.bottom };\n    }\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends InlineView {\n    constructor(widget, length, side, open) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.open = open;\n    }\n    static create(widget, length, side, open = 0) {\n        return new (widget.customView || WidgetView)(widget, length, side, open);\n    }\n    slice(from, to = this.length) { return WidgetView.create(this.widget, to - from, this.side); }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() { return this.side; }\n    merge(from, to = this.length, source = null) {\n        if (source) {\n            if (!(source instanceof WidgetView) || !source.open ||\n                from > 0 && !(source.open & 1 /* Start */) ||\n                to < this.length && !(source.open & 2 /* End */))\n                return false;\n            if (!this.widget.compare(source.widget))\n                throw new Error(\"Trying to merge incompatible widgets\");\n        }\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    match(other) {\n        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n            if (this.widget.constructor == other.widget.constructor) {\n                if (!this.widget.eq(other.widget.value))\n                    this.markDirty(true);\n                this.widget = other.widget;\n                return true;\n            }\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get overrideDOMText() {\n        if (this.length == 0)\n            return [\"\"];\n        let top = this;\n        while (top.parent)\n            top = top.parent;\n        let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.sliceLines(start, start + this.length) : [\"\"];\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() { return null; }\n    coordsAt(pos) {\n        let rects = this.dom.getClientRects();\n        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {\n            let rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\n                return rects[i];\n        }\n        return null;\n    }\n}\nclass CompositionView extends WidgetView {\n    domAtPos(pos) { return new DOMPos(this.widget.value.text, pos); }\n    sync() { if (!this.dom)\n        this.setDOM(this.widget.toDOM(this.editorView)); }\n    ignoreMutation() { return false; }\n    get overrideDOMText() { return null; }\n    coordsAt(pos) { return textCoords(this.widget.value.text, pos); }\n}\n\n/// Widgets added to the content are described by subclasses of this\n/// class. This makes it possible to delay creating of the DOM\n/// structure for a widget until it is needed, and to avoid redrawing\n/// widgets even when the decorations that define them are recreated.\n/// `T` can be a type of value passed to instances of the widget type.\nclass WidgetType {\n    /// Create an instance of this widget type.\n    constructor(\n    /// @internal\n    value) {\n        this.value = value;\n    }\n    /// Compare this instance to another instance of the same class. By\n    /// default, it'll compare the instances' parameters with `===`.\n    eq(value) { return this.value === value; }\n    /// Update a DOM element created by a widget of the same type but\n    /// with a different value to reflect this widget. May return true\n    /// to indicate that it could update, false to indicate it couldn't\n    /// (in which case the widget will be redrawn). The default\n    /// implementation just returns false.\n    updateDOM(_dom) { return false; }\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other.value);\n    }\n    /// The estimated height this widget will have, to be used when\n    /// estimating the height of content that hasn't been drawn. May\n    /// return -1 to indicate you don't know. The default implementation\n    /// returns -1.\n    get estimatedHeight() { return -1; }\n    /// Can be used to configure which kinds of events inside the widget\n    /// should be ignored by the editor. The default is to ignore all\n    /// events.\n    ignoreEvent(_event) { return true; }\n    //// @internal\n    get customView() { return null; }\n}\n/// The different types of blocks that can occur in an editor view.\nvar BlockType;\n(function (BlockType) {\n    /// A line of text.\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /// A block widget associated with the position after it.\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /// A block widget associated with the position before it.\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /// A block widget [replacing](#view.Decoration^replace) a range of content.\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n})(BlockType || (BlockType = {}));\n/// A decoration provides information on how to draw or style a piece\n/// of content. You'll usually use it wrapped in a\n/// [`Range`](#rangeset.Range), which adds a start and\n/// end position.\nclass Decoration extends RangeValue {\n    /// @internal\n    constructor(\n    /// @internal\n    startSide, \n    /// @internal\n    endSide, \n    /// @internal\n    widget, \n    /// The config object used to create this decoration.\n    spec) {\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /// @internal\n    get point() { return false; }\n    /// @internal\n    get heightRelevant() { return false; }\n    /// Create a mark decoration, which influences the styling of the\n    /// text in its range.\n    static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /// Create a widget decoration, which adds an element at the given\n    /// position.\n    static widget(spec) {\n        let side = spec.side || 0;\n        if (spec.block)\n            side += (200000000 /* BigBlock */ + 1) * (side > 0 ? 1 : -1);\n        return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);\n    }\n    /// Create a replace decoration which replaces the given range with\n    /// a widget, or simply hides it.\n    static replace(spec) {\n        let block = !!spec.block;\n        let { start, end } = getInclusive(spec);\n        let startSide = block ? -200000000 /* BigBlock */ * (start ? 2 : 1) : 100000000 /* BigInline */ * (start ? -1 : 1);\n        let endSide = block ? 200000000 /* BigBlock */ * (end ? 2 : 1) : 100000000 /* BigInline */ * (end ? 1 : -1);\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /// Create a line decoration, which can add DOM attributes to the\n    /// line starting at the given position.\n    static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /// Build a [`DecorationSet`](#view.DecorationSet) from the given\n    /// decorated range or ranges.\n    static set(of, sort = false) {\n        return RangeSet.of(of, sort);\n    }\n    /// @internal\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\n}\n/// The empty set of decorations.\nDecoration.none = RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec) {\n        let { start, end } = getInclusive(spec);\n        super(100000000 /* BigInline */ * (start ? -1 : 1), 100000000 /* BigInline */ * (end ? 1 : -1), null, spec);\n    }\n    eq(other) {\n        return this == other ||\n            other instanceof MarkDecoration &&\n                this.spec.tagName == other.spec.tagName &&\n                this.spec.class == other.spec.class &&\n                attrsEq(this.spec.attributes || null, other.spec.attributes || null);\n    }\n    range(from, to = from) {\n        if (from >= to)\n            throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nclass LineDecoration extends Decoration {\n    constructor(spec) {\n        super(-100000000 /* BigInline */, -100000000 /* BigInline */, null, spec);\n    }\n    get point() { return true; }\n    eq(other) {\n        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from)\n            throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.startMapMode = LineDecoration.prototype.endMapMode = MapMode.TrackBefore;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace) {\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        if (block) {\n            this.startMapMode = startSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;\n            this.endMapMode = endSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;\n        }\n        else {\n            this.startMapMode = this.endMapMode = MapMode.TrackDel;\n        }\n    }\n    get point() { return true; }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide < this.endSide ? BlockType.WidgetRange\n            : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }\n    eq(other) {\n        return other instanceof PointDecoration &&\n            widgetsEq(this.widget, other.widget) &&\n            this.block == other.block &&\n            this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide < 0)))\n            throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from)\n            throw new RangeError(\"Widget decorations can only create zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nfunction getInclusive(spec) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null)\n        start = spec.inclusive;\n    if (end == null)\n        end = spec.inclusive;\n    return { start: start || false, end: end || false };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nconst MinRangeGap = 4;\nfunction addRange(from, to, ranges) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + MinRangeGap > from)\n        ranges[last] = Math.max(ranges[last], to);\n    else\n        ranges.push(from, to);\n}\n\nconst theme = Facet.define();\nconst baseThemeID = StyleModule.newName();\nfunction buildTheme(id, spec) {\n    let styles = Object.create(null);\n    for (let prop in spec) {\n        let parts = prop.split(\".\"), selector = \".\" + id + (parts[0] == \"wrap\" ? \"\" : \" \");\n        for (let i = 1; i <= parts.length; i++)\n            selector += \".cm-\" + parts.slice(0, i).join(\"-\");\n        styles[selector] = spec[prop];\n    }\n    return new StyleModule(styles, { generateClasses: false });\n}\n/// Create a set of CSS class names for the given theme selector,\n/// which can be added to a DOM element within an editor to make\n/// themes able to style it. Theme selectors can be single words or\n/// words separated by dot characters. In the latter case, the\n/// returned classes combine those that match the full name and those\n/// that match some prefixfor example `\"panel.search\"` will match\n/// both the theme styles specified as `\"panel.search\"` and those with\n/// just `\"panel\"`. More specific theme styles (with more dots) take\n/// precedence.\nfunction themeClass(selector) {\n    let parts = selector.split(\".\"), result = \"\";\n    for (let i = 1; i <= parts.length; i++)\n        result += (result ? \" \" : \"\") + \"cm-\" + parts.slice(0, i).join(\"-\");\n    return result;\n}\nconst baseTheme = buildTheme(baseThemeID, {\n    wrap: {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // FIXME it would be great if we could directly use the browser's\n            // default focus outline, but it appears we can't, so this tries to\n            // approximate that\n            outline_fallback: \"1px dotted #212121\",\n            outline: \"5px auto -webkit-focus-ring-color\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    scroller: {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\"\n    },\n    content: {\n        margin: 0,\n        flexGrow: 2,\n        minHeight: \"100%\",\n        display: \"block\",\n        whiteSpace: \"pre\",\n        boxSizing: \"border-box\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        caretColor: \"black\",\n    },\n    line: {\n        display: \"block\",\n        padding: \"0 2px 0 4px\"\n    }\n});\n\nconst LineClass = themeClass(\"line\");\nclass LineView extends ContentView {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, takeDeco) {\n        if (source) {\n            if (!(source instanceof LineView))\n                return false;\n            if (!this.dom)\n                source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (takeDeco)\n            this.setDeco(source ? source.attrs : null);\n        let elts = source ? source.children : [];\n        let cur = this.childCursor();\n        let { i: toI, off: toOff } = cur.findPos(to, 1);\n        let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n        let dLen = from - to;\n        for (let view of elts)\n            dLen += view.length;\n        this.length += dLen;\n        // Both from and to point into the same text view\n        if (fromI == toI && fromOff) {\n            let start = this.children[fromI];\n            // Maybe just update that view and be done\n            if (elts.length == 1 && start.merge(fromOff, toOff, elts[0]))\n                return true;\n            if (elts.length == 0) {\n                start.merge(fromOff, toOff, null);\n                return true;\n            }\n            // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards\n            let after = start.slice(toOff);\n            if (after.merge(0, 0, elts[elts.length - 1]))\n                elts[elts.length - 1] = after;\n            else\n                elts.push(after);\n            toI++;\n            toOff = 0;\n        }\n        // Make sure start and end positions fall on node boundaries\n        // (fromOff/toOff are no longer used after this), and that if the\n        // start or end of the elts can be merged with adjacent nodes,\n        // this is done\n        if (toOff) {\n            let end = this.children[toI];\n            if (elts.length && end.merge(0, toOff, elts[elts.length - 1]))\n                elts.pop();\n            else\n                end.merge(0, toOff, null);\n        }\n        else if (toI < this.children.length && elts.length &&\n            this.children[toI].merge(0, 0, elts[elts.length - 1])) {\n            elts.pop();\n        }\n        if (fromOff) {\n            let start = this.children[fromI];\n            if (elts.length && start.merge(fromOff, undefined, elts[0]))\n                elts.shift();\n            else\n                start.merge(fromOff, undefined, null);\n            fromI++;\n        }\n        else if (fromI && elts.length && this.children[fromI - 1].merge(this.children[fromI - 1].length, undefined, elts[0])) {\n            elts.shift();\n        }\n        // Then try to merge any mergeable nodes at the start and end of\n        // the changed range\n        while (fromI < toI && elts.length && this.children[toI - 1].match(elts[elts.length - 1])) {\n            elts.pop();\n            toI--;\n        }\n        while (fromI < toI && elts.length && this.children[fromI].match(elts[0])) {\n            elts.shift();\n            fromI++;\n        }\n        // And if anything remains, splice the child array to insert the new elts\n        if (elts.length || fromI != toI)\n            this.replaceChildren(fromI, toI, elts);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0)\n            return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].slice(off));\n            this.children[i].merge(off, undefined, null);\n            i++;\n        }\n        for (let j = i; j < this.children.length; j++)\n            end.append(this.children[j]);\n        while (i > 0 && this.children[i - 1].length == 0) {\n            this.children[i - 1].parent = null;\n            i--;\n        }\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom)\n            return;\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    // Only called when building a line view in ContentBuilder\n    append(child) {\n        this.children.push(child);\n        child.setParent(this);\n        this.length += child.length;\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes;\n        if (attrs)\n            this.attrs = combineAttrs(attrs, this.attrs || {});\n    }\n    domAtPos(pos) {\n        let i = 0;\n        for (let off = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = off + child.length;\n            if (end == off && child.getSide() <= 0)\n                continue;\n            if (pos > off && pos < end && child.dom.parentNode == this.dom)\n                return child.domAtPos(pos - off);\n            if (pos <= off)\n                break;\n            off = end;\n        }\n        for (; i > 0; i--) {\n            let before = this.children[i - 1].dom;\n            if (before.parentNode == this.dom)\n                return DOMPos.after(before);\n        }\n        return new DOMPos(this.dom, 0);\n    }\n    // FIXME might need another hack to work around Firefox's behavior\n    // of not actually displaying the cursor even though it's there in\n    // the DOM\n    sync() {\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = LineClass;\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(LineClass);\n            this.prevAttrs = undefined;\n        }\n        super.sync();\n        let last = this.dom.lastChild;\n        if (!last || (last.nodeName != \"BR\" && !(ContentView.get(last) instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20)\n            return null;\n        let totalWidth = 0;\n        for (let child of this.children) {\n            if (!(child instanceof TextView))\n                return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1)\n                return null;\n            totalWidth += rects[0].width;\n        }\n        return { lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length };\n    }\n    coordsAt(pos) {\n        for (let off = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = off + child.length;\n            if (end >= pos)\n                return child.coordsAt(pos - off);\n            off = end;\n        }\n        return this.dom.lastChild.getBoundingClientRect();\n    }\n    match(other) { return false; }\n    get type() { return BlockType.Text; }\n}\nconst none$2 = [];\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, type, \n    // This is set by the builder and used to distinguish between\n    // adjacent widgets and parts of the same widget when calling\n    // `merge`. It's kind of silly that it's an instance variable, but\n    // it's hard to route there otherwise.\n    open = 0) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.type = type;\n        this.open = open;\n        this.breakAfter = 0;\n    }\n    merge(from, to, source) {\n        if (!(source instanceof BlockWidgetView) || !source.open ||\n            from > 0 && !(source.open & 1 /* Start */) ||\n            to < this.length && !(source.open & 2 /* End */))\n            return false;\n        if (!this.widget.compare(source.widget))\n            throw new Error(\"Trying to merge an open widget with an incompatible node\");\n        this.length = from + source.length + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        return new BlockWidgetView(this.widget, len, this.type);\n    }\n    get children() { return none$2; }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.sliceLines(this.posAtStart, this.posAtEnd) : [\"\"];\n    }\n    domBoundsAround() { return null; }\n    match(other) {\n        if (other instanceof BlockWidgetView && other.type == this.type &&\n            other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.eq(this.widget.value))\n                this.markDirty(true);\n            this.widget = other.widget;\n            this.length = other.length;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n}\n\nclass ContentBuilder {\n    constructor(doc, pos, end) {\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0)\n            return !this.breakAtStart && this.doc.lineAt(this.pos).start != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n    getLine() {\n        if (!this.curLine)\n            this.content.push(this.curLine = new LineView);\n        return this.curLine;\n    }\n    addWidget(view) {\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish() {\n        if (!this.posCovered())\n            this.getLine();\n    }\n    buildText(length, tagName, clss, attrs, _ranges) {\n        while (length > 0) {\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done)\n                    throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered())\n                        this.getLine();\n                    if (this.content.length)\n                        this.content[this.content.length - 1].breakAfter = 1;\n                    else\n                        this.breakAtStart = 1;\n                    this.curLine = null;\n                    length--;\n                    continue;\n                }\n                else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length);\n            this.getLine().append(new TextView(this.text.slice(this.textOff, this.textOff + take), tagName, clss, attrs));\n            length -= take;\n            this.textOff += take;\n        }\n    }\n    span(from, to, active) {\n        let tagName = null, clss = null;\n        let attrs = null;\n        for (let { spec } of active) {\n            if (spec.tagName)\n                tagName = spec.tagName;\n            if (spec.class)\n                clss = clss ? clss + \" \" + spec.class : spec.class;\n            if (spec.attributes)\n                for (let name in spec.attributes) {\n                    let value = spec.attributes[name];\n                    if (value == null)\n                        continue;\n                    if (name == \"class\") {\n                        clss = clss ? clss + \" \" + value : value;\n                    }\n                    else {\n                        if (!attrs)\n                            attrs = {};\n                        if (name == \"style\" && attrs.style)\n                            value = attrs.style + \";\" + value;\n                        attrs[name] = value;\n                    }\n                }\n        }\n        this.buildText(to - from, tagName, clss, attrs, active);\n        this.pos = to;\n    }\n    point(from, to, deco, openStart, openEnd) {\n        let open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                let { type } = deco;\n                if (type == BlockType.WidgetAfter && !this.posCovered())\n                    this.getLine();\n                this.addWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type, open));\n            }\n            else {\n                this.getLine().append(WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide, open));\n            }\n        }\n        else if (this.doc.lineAt(this.pos).start == this.pos) { // Line decoration\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            }\n            else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n    }\n    static build(text, from, to, decorations) {\n        let builder = new ContentBuilder(text, from, to);\n        RangeSet.spans(decorations, from, to, builder);\n        builder.finish();\n        return builder;\n    }\n}\nclass NullWidget extends WidgetType {\n    toDOM() { return document.createElement(this.value); }\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.value; }\n}\n\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\"];\nclass HeightOracle {\n    constructor() {\n        this.doc = Text.empty;\n        this.lineWrapping = false;\n        this.direction = \"ltr\";\n        this.heightSamples = {};\n        this.lineHeight = 14;\n        this.charWidth = 7;\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping)\n            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping)\n            return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) { this.doc = doc; return this; }\n    mustRefresh(lineHeights, whiteSpace, direction) {\n        let newHeight = false;\n        for (let i = 0; i < lineHeights.length; i++) {\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            }\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight || (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping || this.direction != direction;\n    }\n    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) ||\n            this.lineWrapping != lineWrapping ||\n            this.direction != direction;\n        this.lineWrapping = lineWrapping;\n        this.direction = direction;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for (let i = 0; i < knownHeights.length; i++) {\n                let h = knownHeights[i];\n                if (h < 0)\n                    i++;\n                else\n                    this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights) {\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() { return this.index < this.heights.length; }\n}\n/// Record used to represent information about a block-level element\n/// in the editor view.\nclass BlockInfo {\n    /// @internal\n    constructor(\n    /// The start of the element in the document.\n    from, \n    /// The length of the element.\n    length, \n    /// The top position of the element.\n    top, \n    /// Its height.\n    height, \n    /// The type of element this is. When querying lines, this may be\n    /// an array of all the blocks that make up the line.\n    type) {\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this.type = type;\n    }\n    /// The end of the element as a document position.\n    get to() { return this.from + this.length; }\n    /// The bottom position of the element.\n    get bottom() { return this.top + this.height; }\n    /// @internal\n    join(other) {\n        let detail = (Array.isArray(this.type) ? this.type : [this])\n            .concat(Array.isArray(other.type) ? other.type : [other]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n    }\n}\nvar QueryType;\n(function (QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n})(QueryType || (QueryType = {}));\nclass HeightMap {\n    constructor(length, // The number of characters covered\n    height, // Height of this part of the document\n    flags = 2 /* Outdated */) {\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() { return (this.flags & 2 /* Outdated */) > 0; }\n    set outdated(value) { this.flags = (value ? 2 /* Outdated */ : 0) | (this.flags & ~2 /* Outdated */); }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            this.height = height;\n            oracle.heightChanged = true;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) { result.push(this); }\n    decomposeRight(_from, result) { result.push(this); }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this;\n        for (let i = changes.length - 1; i >= 0; i--) {\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while (i > 0 && start.from <= changes[i - 1].toA) {\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from)\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() { return new HeightMapText(0, 0); }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1)\n            return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for (;;) {\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break)\n                        nodes.splice(--i, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                }\n                else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break)\n                        nodes.splice(j, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (before < after) {\n                let next = nodes[i++];\n                if (next)\n                    before += next.size;\n            }\n            else {\n                let next = nodes[--j];\n                if (next)\n                    after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        }\n        else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, type) {\n        super(length, height);\n        this.type = type;\n    }\n    blockAt(_height, _doc, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.type);\n    }\n    lineAt(_value, _type, doc, top, offset) {\n        return this.blockAt(0, doc, top, offset);\n    }\n    forEachLine(_from, _to, doc, top, offset, f) {\n        f(this.blockAt(0, doc, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() { return `block(${this.length})`; }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height) {\n        super(length, height, BlockType.Text);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n    }\n    replace(_from, _to, nodes) {\n        if (nodes.length == 1 && nodes[0] instanceof HeightMapText && Math.abs(this.length - nodes[0].length) < 10) {\n            nodes[0].height = this.height;\n            return nodes[0];\n        }\n        else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated)\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length) { super(length, 0); }\n    lines(doc, offset) {\n        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\n        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };\n    }\n    blockAt(height, doc, top, offset) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n        let { start, length } = doc.line(firstLine + line);\n        return new BlockInfo(start, length, top + lineHeight * line, lineHeight, BlockType.Text);\n    }\n    lineAt(value, type, doc, top, offset) {\n        if (type == QueryType.ByHeight)\n            return this.blockAt(value, doc, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { start, end } = doc.lineAt(value);\n            return new BlockInfo(start, end - start, 0, 0, BlockType.Text);\n        }\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        let { start, length, number } = doc.lineAt(value);\n        return new BlockInfo(start, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        for (let line = firstLine; line <= lastLine; line++) {\n            let { start, end } = doc.line(line);\n            if (start > to)\n                break;\n            if (end >= from)\n                f(new BlockInfo(start, end - start, top, top += lineHeight, BlockType.Text));\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap)\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else\n                nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap)\n                nodes[0] = new HeightMapGap(from + first.length);\n            else\n                nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(to == this.length ? this : new HeightMapGap(to));\n    }\n    decomposeRight(from, result) {\n        result.push(from == 0 ? this : new HeightMapGap(this.length - from));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from);\n            if (measured.from > offset)\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while (pos <= end && measured.more) {\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length)\n                    nodes.push(null);\n                let line = new HeightMapText(len, measured.heights[measured.index++]);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end)\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            oracle.heightChanged = true;\n            return HeightMap.of(nodes);\n        }\n        else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() { return `gap(${this.length})`; }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right) {\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Outdated */ : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() { return this.flags & 1 /* Break */; }\n    blockAt(height, doc, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset)\n            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, doc, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, doc, top, offset)\n            : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\n            return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left)\n            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));\n        else\n            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset)\n                this.left.forEachLine(from, to, doc, top, offset, f);\n            if (to >= rightOffset)\n                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n        }\n        else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n            if (from < mid.from)\n                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n            if (mid.to >= from && mid.from <= to)\n                f(mid);\n            if (to > mid.to)\n                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart)\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length)\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0)\n            this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)\n            result.push(node);\n        if (from > 0)\n            mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left)\n            return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left)\n                result.push(null);\n        }\n        if (to > left)\n            this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right)\n            return this.right.decomposeRight(from - right, result);\n        if (from < left)\n            this.left.decomposeRight(from, result);\n        if (this.break && from < right)\n            result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more)\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else\n            left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more)\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else\n            right.updateHeight(oracle, rightStart, force);\n        if (rebalance)\n            return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null &&\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\n        (after = nodes[around + 1]) instanceof HeightMapGap)\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle) {\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText)\n                last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered)\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco.type));\n            }\n            else if (len || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, len);\n            }\n        }\n        else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).end;\n    }\n    enterLine() {\n        if (this.lineStart > -1)\n            return;\n        let { start, end } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = start;\n        this.lineEnd = end;\n        if (this.writtenTo < start) {\n            if (this.writtenTo < start - 1 || this.nodes[this.nodes.length - 1] == null)\n                this.nodes.push(new HeightMapGap(start - this.writtenTo - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > start)\n            this.nodes.push(new HeightMapText(this.pos - start, -1));\n        this.writtenTo = this.pos;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText)\n            return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        if (block.type == BlockType.WidgetAfter && !this.isCovered)\n            this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (block.type != BlockType.WidgetBefore)\n            this.covering = block;\n    }\n    addLineDeco(height, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\n            this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null)\n            this.nodes.push(new HeightMapGap(this.pos - this.writtenTo));\n        let pos = from;\n        for (let node of this.nodes) {\n            if (node instanceof HeightMapText)\n                node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        RangeSet.spans(decorations, from, to, builder);\n        return builder.finish(from);\n    }\n    get minPointSize() { return 0; }\n}\nfunction heightRelevantDecoChanges(a, b, diff, length) {\n    let comp = new DecorationComparator();\n    RangeSet.compare(a, b, diff, length, comp);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange() { }\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant)\n            addRange(from, to, this.changes);\n    }\n    get minPointSize() { return 0; }\n}\n\nconst none$3 = [];\nconst domEventHandlers = Facet.define();\nconst clickAddsSelectionRange = Facet.define();\nconst dragMovesSelection = Facet.define();\n/// Plugin fields are a mechanism for allowing plugins to provide\n/// values that can be retrieved through the\n/// [`pluginValues`](#view.EditorView.pluginValues) view method.\nclass PluginField {\n    static define() { return new PluginField(); }\n}\n/// Plugins can provide additional scroll margins (space around the\n/// sides of the scrolling element that should be considered\n/// invisible) through this field. This can be useful when the\n/// plugin introduces elements that cover part of that element (for\n/// example a horizontally fixed gutter).\nPluginField.scrollMargins = PluginField.define();\nlet nextPluginID = 0;\nconst viewPlugin = Facet.define();\n/// View plugins associate stateful values with a view. They can\n/// influence the way the content is drawn, and are notified of things\n/// that happen in the view.\nclass ViewPlugin {\n    constructor(\n    /// @internal\n    id, \n    /// @internal\n    create, \n    /// @internal\n    fields) {\n        this.id = id;\n        this.create = create;\n        this.fields = fields;\n        this.extension = viewPlugin.of(this);\n    }\n    /// Define a plugin from a constructor function that creates the\n    /// plugin's value, given an editor view.\n    static define(create) {\n        return new ViewPlugin(nextPluginID++, create, []);\n    }\n    /// Create a plugin for a class whose constructor takes a single\n    /// editor view as argument.\n    static fromClass(cls) {\n        return ViewPlugin.define(view => new cls(view));\n    }\n    /// Create a new version of this plugin that provides a given\n    /// [plugin field](#view.PluginField).\n    provide(field, get) {\n        return new ViewPlugin(this.id, this.create, this.fields.concat({ field, get }));\n    }\n    decorations(get) {\n        return this.provide(pluginDecorations, get || ((value) => value.decorations));\n    }\n}\n// FIXME somehow ensure that no replacing decorations end up in here\nconst pluginDecorations = PluginField.define();\nclass PluginInstance {\n    constructor(value, spec) {\n        this.value = value;\n        this.spec = spec;\n        this.updateFunc = this.value.update ? this.value.update.bind(this.value) : () => undefined;\n    }\n    static create(spec, view) {\n        let value;\n        try {\n            value = spec.create(view);\n        }\n        catch (e) {\n            console.error(\"CodeMirror plugin crashed:\", e);\n            return PluginInstance.dummy;\n        }\n        return new PluginInstance(value, spec);\n    }\n    takeField(type, target) {\n        for (let { field, get } of this.spec.fields)\n            if (field == type)\n                target.push(get(this.value));\n    }\n    update(update) {\n        try {\n            this.updateFunc(update);\n            return this;\n        }\n        catch (e) {\n            console.error(\"CodeMirror plugin crashed:\", e);\n            if (this.value.destroy)\n                try {\n                    this.value.destroy();\n                }\n                catch (_) { }\n            return PluginInstance.dummy;\n        }\n    }\n    destroy() {\n        try {\n            if (this.value.destroy)\n                this.value.destroy();\n        }\n        catch (e) {\n            console.error(\"CodeMirror plugin crashed:\", e);\n        }\n    }\n}\nPluginInstance.dummy = new PluginInstance({}, ViewPlugin.define(() => ({})));\nconst editorAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst contentAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\n// Provide decorations\nconst decorations = Facet.define();\nconst styleModule = Facet.define();\nconst phrases = Facet.define();\n/// View [plugins](#view.ViewPlugin) are given instances of this\n/// class, which describe what happened, whenever the view is updated.\nclass ViewUpdate {\n    /// @internal\n    constructor(\n    /// The editor view that the update is associated with.\n    view, \n    /// The new editor state.\n    state, \n    /// The transactions involved in the update. May be empty.\n    transactions = none$3) {\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /// @internal\n        this.flags = 0;\n        this.changes = transactions.reduce((chs, tr) => chs.appendSet(tr.changes), ChangeSet.empty);\n        this.prevState = view.state;\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            view.inputState.notifiedFocused = focus;\n            this.flags != 1 /* Focus */;\n        }\n        if (this.docChanged)\n            this.flags |= 2 /* Height */;\n    }\n    /// Tells you whether the viewport changed in this update.\n    get viewportChanged() {\n        return (this.flags & 4 /* Viewport */) > 0;\n    }\n    /// Indicates whether the line height in the editor changed in this update.\n    get heightChanged() {\n        return (this.flags & 2 /* Height */) > 0;\n    }\n    /// True when this update indicates a focus change.\n    get focusChanged() {\n        return (this.flags & 1 /* Focus */) > 0;\n    }\n    /// Whether the document changed in this update.\n    get docChanged() {\n        return this.transactions.some(tr => tr.docChanged);\n    }\n    /// Whether the selection was explicitly set in this update.\n    get selectionSet() {\n        return this.transactions.some(tr => tr.selectionSet);\n    }\n    /// @internal\n    get empty() { return this.flags == 0 && this.transactions.length == 0; }\n}\n\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);\n    for (let parent = dom.parentNode; parent;) { // (Cast to any because TypeScript is useless with Node types)\n        if (parent.nodeType == 1) {\n            if (parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) {\n                let parentRect = parent.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(bottom, parentRect.bottom);\n            }\n            parent = parent.parentNode;\n        }\n        else if (parent.nodeType == 11) { // Shadow root\n            parent = parent.host;\n        }\n        else {\n            break;\n        }\n    }\n    return { left: left - rect.left, right: right - rect.left,\n        top: top - (rect.top + paddingTop), bottom: bottom - (rect.top + paddingTop) };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size) {\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)\n                return false;\n        }\n        return true;\n    }\n    draw(wrapping) {\n        return Decoration.replace({ widget: new LineGapWidget({ size: this.size, vertical: wrapping }) }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.value.vertical) {\n            elt.style.height = this.value.size + \"px\";\n        }\n        else {\n            elt.style.width = this.value.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    eq(other) { return this.value.size == other.size && this.value.vertical == other.vertical; }\n    get estimatedHeight() { return this.value.vertical ? this.value.size : -1; }\n}\nclass ViewState {\n    constructor(state) {\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };\n        this.paddingTop = 0;\n        this.paddingBottom = 0;\n        this.heightOracle = new HeightOracle;\n        this.heightMap = HeightMap.empty();\n        this.scrollTo = -1;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        this.visibleRanges = [];\n        this.heightMap = this.heightMap.applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n        this.viewport = this.getViewport(0, -1);\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\n        this.computeVisibleRanges();\n    }\n    update(update, scrollTo = -1) {\n        let prev = this.state;\n        this.state = update.state;\n        let newDeco = this.state.facet(decorations);\n        let contentChanges = update.changes.changedRanges();\n        let heightChanges = extendWithRanges(contentChanges, heightRelevantDecoChanges(update.prevState.facet(decorations), newDeco, update ? contentChanges : [], this.state.doc.length));\n        let prevHeight = this.heightMap.height;\n        this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight)\n            update.flags |= 2 /* Height */;\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (!viewport || scrollTo > -1 && (scrollTo < viewport.from || scrollTo > viewport.to) ||\n            !this.viewportIsCovering(viewport))\n            viewport = this.getViewport(0, scrollTo);\n        if (!viewport.eq(this.viewport)) {\n            this.viewport = viewport;\n            update.flags |= 4 /* Viewport */;\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        this.computeVisibleRanges();\n        if (scrollTo > -1)\n            this.scrollTo = scrollTo;\n    }\n    measure(docView, repeated) {\n        let dom = docView.dom, whiteSpace = \"\", direction = \"ltr\";\n        if (!repeated) {\n            // Vertical padding\n            let style = window.getComputedStyle(dom);\n            whiteSpace = style.whiteSpace, direction = (style.direction || \"ltr\");\n            this.paddingTop = parseInt(style.paddingTop) || 0;\n            this.paddingBottom = parseInt(style.paddingBottom) || 0;\n        }\n        // Pixel viewport\n        let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        if (this.pixelViewport.bottom <= this.pixelViewport.top ||\n            this.pixelViewport.right <= this.pixelViewport.left)\n            return 0;\n        let lineHeights = docView.measureVisibleLineHeights();\n        let refresh = false, bias = 0;\n        if (!repeated) {\n            if (this.heightOracle.mustRefresh(lineHeights, whiteSpace, direction)) {\n                let { lineHeight, charWidth } = docView.measureTextSize();\n                refresh = this.heightOracle.refresh(whiteSpace, direction, lineHeight, charWidth, (docView.dom).clientWidth / charWidth, lineHeights);\n                if (refresh)\n                    docView.minWidth = 0;\n            }\n            if (dTop > 0 && dBottom > 0)\n                bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0)\n                bias = Math.min(dTop, dBottom);\n        }\n        this.heightOracle.heightChanged = false;\n        this.heightMap = this.heightMap.updateHeight(this.heightOracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));\n        let result = this.heightOracle.heightChanged ? 2 /* Height */ : 0;\n        let scrollTo = this.scrollTo;\n        this.scrollTo = -1;\n        if (!this.viewportIsCovering(this.viewport, bias) ||\n            scrollTo > -1 && (scrollTo < this.viewport.from || scrollTo > this.viewport.to)) {\n            this.viewport = this.getViewport(bias, scrollTo);\n            result |= 4 /* Viewport */;\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));\n        this.computeVisibleRanges();\n        if (scrollTo > -1)\n            docView.scrollPosIntoView(scrollTo); // FIXME return instead?\n        return result;\n    }\n    getViewport(bias, scrollTo) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* Margin */ / 2));\n        let map = this.heightMap, doc = this.state.doc, { top, bottom } = this.pixelViewport;\n        let viewport = new Viewport(map.lineAt(top - marginTop * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(bottom + (1 - marginTop) * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).to);\n        // If scrollTo is > -1, make sure the viewport includes that position\n        if (scrollTo > -1) {\n            if (scrollTo < viewport.from) {\n                let { top: newTop } = map.lineAt(scrollTo, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newTop - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (bottom - top) + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n            else if (scrollTo > viewport.to) {\n                let { bottom: newBottom } = map.lineAt(scrollTo, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newBottom - (bottom - top) - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        if ((to - from) - (viewport.to - viewport.from) > 100)\n            return null; // Grew too much, recompute\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n    }\n    viewportIsCovering({ from, to }, bias = 0) {\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\n        return (from == 0 || top <= this.pixelViewport.top - Math.max(10 /* MinCoverMargin */, Math.min(-bias, 250 /* MaxCoverMargin */))) &&\n            (to == this.state.doc.length ||\n                bottom >= this.pixelViewport.bottom + Math.max(10 /* MinCoverMargin */, Math.min(bias, 250 /* MaxCoverMargin */)));\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || !changes.changes.length)\n            return gaps;\n        let mapped = [];\n        for (let gap of gaps)\n            if (!changes.touchesRange(gap.from, gap.to))\n                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current) {\n        let gaps = [];\n        // This won't work at all in predominantly right-to-left text.\n        if (this.heightOracle.direction != \"ltr\")\n            return gaps;\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {\n            if (line.length < 10000 /* Margin */)\n                return;\n            let structure = lineStructure(line.from, line.to, this.state);\n            if (structure.total < 10000 /* Margin */)\n                return;\n            let viewFrom, viewTo;\n            if (this.heightOracle.lineWrapping) {\n                if (line.from != this.viewport.from)\n                    viewFrom = line.from;\n                else\n                    viewFrom = findPosition(structure, (this.pixelViewport.top - line.top) / line.height);\n                if (line.to != this.viewport.to)\n                    viewTo = line.to;\n                else\n                    viewTo = findPosition(structure, (this.pixelViewport.bottom - line.top) / line.height);\n            }\n            else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);\n                viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);\n            }\n            let sel = this.state.selection.primary;\n            // Make sure the gap doesn't cover a selection end\n            if (sel.from <= viewFrom && sel.to >= line.from)\n                viewFrom = sel.from;\n            if (sel.from <= line.to && sel.to >= viewTo)\n                viewTo = sel.to;\n            let gapTo = viewFrom - 10000 /* Margin */, gapFrom = viewTo + 10000 /* Margin */;\n            if (gapTo > line.from + 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000 /* HalfMargin */ && gap.to < gapTo + 5000 /* HalfMargin */) ||\n                    new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));\n            if (gapFrom < line.to - 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000 /* HalfMargin */ &&\n                    gap.from < gapFrom + 5000 /* HalfMargin */) ||\n                    new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));\n        });\n        return gaps;\n    }\n    gapSize(line, pos, start, structure) {\n        if (this.heightOracle.lineWrapping) {\n            let height = line.height * findFraction(structure, pos);\n            return start ? height : line.height - height;\n        }\n        else {\n            let ratio = findFraction(structure, pos);\n            return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\n            return 16 /* LineGaps */;\n        }\n        return 0;\n    }\n    computeVisibleRanges() {\n        let deco = this.state.facet(decorations);\n        if (this.lineGaps.length)\n            deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span(from, to) { ranges.push({ from, to }); },\n            point() { },\n            minPointSize: 20\n        });\n        this.visibleRanges = ranges;\n    }\n    lineAt(pos, editorTop) {\n        return this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    lineAtHeight(height, editorTop) {\n        return this.heightMap.lineAt(height, QueryType.ByHeight, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    blockAtHeight(height, editorTop) {\n        return this.heightMap.blockAt(height, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    forEachLine(from, to, f, editorTop) {\n        return this.heightMap.forEachLine(from, to, this.state.doc, editorTop + this.paddingTop, 0, f);\n    }\n}\n/// Indicates the range of the document that is in the visible\n/// viewport.\nclass Viewport {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n    eq(b) { return this.from == b.from && this.to == b.to; }\n}\nfunction extendWithRanges(diff, ranges) {\n    if (ranges.length == 0)\n        return diff;\n    let result = [];\n    for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n        let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n        let end = next ? next.fromB : 1e9;\n        while (rI < ranges.length && ranges[rI] < end) {\n            let from = ranges[rI], to = ranges[rI + 1];\n            let fromB = Math.max(posB, from), toB = Math.min(end, to);\n            if (fromB <= toB)\n                new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n            if (to > end)\n                break;\n            else\n                rI += 2;\n        }\n        if (!next)\n            return result;\n        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n        posA = next.toA;\n        posB = next.toB;\n    }\n}\nfunction lineStructure(from, to, state) {\n    let ranges = [], pos = 0, total = 0;\n    RangeSet.spans(state.facet(decorations), from, to, {\n        span() { },\n        point(from, to) {\n            if (from > pos) {\n                ranges.push({ from: pos, to: from });\n                total += to - pos;\n            }\n            pos = to;\n        },\n        minPointSize: 20 // We're only interested in collapsed ranges of a significant size\n    });\n    if (pos < to) {\n        ranges.push({ from: pos, to });\n        total += to - pos;\n    }\n    return { total, ranges };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0)\n        return ranges[0].from;\n    if (ratio >= 1)\n        return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for (let i = 0;; i++) {\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size)\n            return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges) {\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)\n        if (f(val))\n            return val;\n    return undefined;\n}\n\nconst none$4 = [];\nclass DocView extends ContentView {\n    constructor(view) {\n        super();\n        this.view = view;\n        this.viewports = none$4;\n        this.compositionDeco = Decoration.none;\n        this.decorations = [];\n        this.selectionDirty = null;\n        // Track a minimum width for the editor. When measuring sizes in\n        // checkLayout, this is updated to point at the width of a given\n        // element and its extent in the document. When a change happens in\n        // that range, these are reset. That way, once we've seen a\n        // line/element of a given length, we keep the editor wide enough to\n        // fit at least that element, until it is changed, at which point we\n        // forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.setDOM(view.contentDOM);\n        this.children = [new LineView];\n        this.children[0].setParent(this);\n        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);\n    }\n    get root() { return this.view.root; }\n    get editorView() { return this.view; }\n    get length() { return this.view.state.doc.length; }\n    // Update the document view to a given state. scrollIntoView can be\n    // used as a hint to compute a new viewport that includes that\n    // position, if we know the editor is going to scroll that position\n    // into view.\n    update(update) {\n        var _a;\n        let changedRanges = update.changes.changedRanges();\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = 0;\n            }\n            else {\n                this.minWidthFrom = ChangedRange.mapPos(this.minWidthFrom, 1, changedRanges);\n                this.minWidthTo = ChangedRange.mapPos(this.minWidthTo, 1, changedRanges);\n            }\n        }\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        let forceSelection = browser.chrome && !this.compositionDeco.size && update &&\n            update.changes.changes.some(ch => ch.text.length > 1);\n        if (!((_a = this.view.inputState) === null || _a === void 0 ? void 0 : _a.composing))\n            this.compositionDeco = Decoration.none;\n        else if (update.transactions.length)\n            this.compositionDeco = computeCompositionDeco(this.view, changedRanges);\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, changedRanges, update.state.doc.length);\n        changedRanges = extendWithRanges(changedRanges, decoDiff);\n        if (this.dirty == 0 /* Not */ && changedRanges.length == 0 &&\n            !(update.flags & (4 /* Viewport */ | 16 /* LineGaps */)) &&\n            update.state.selection.primary.from >= this.view.viewport.from &&\n            update.state.selection.primary.to <= this.view.viewport.to) {\n            this.updateSelection(forceSelection);\n            return false;\n        }\n        else {\n            this.updateInner(changedRanges, deco, update.prevState.doc.length, forceSelection);\n            return true;\n        }\n    }\n    // Used both by update and checkLayout do perform the actual DOM\n    // update\n    updateInner(changes, deco, oldLength, forceSelection = false) {\n        this.updateChildren(changes, deco, oldLength);\n        this.view.observer.ignore(() => {\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.heightMap.height + \"px\";\n            this.dom.style.minWidth = this.minWidth ? this.minWidth + \"px\" : \"\";\n            this.sync();\n            this.dirty = 0 /* Not */;\n            this.updateSelection(forceSelection);\n            this.dom.style.height = \"\";\n        });\n    }\n    updateChildren(changes, deco, oldLength) {\n        let cursor = this.childCursor(oldLength);\n        for (let i = changes.length - 1;; i--) {\n            let next = i >= 0 ? changes[i] : null;\n            if (!next)\n                break;\n            let { fromA, toA, fromB, toB } = next;\n            let { content, breakAtStart } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart);\n        }\n    }\n    replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart) {\n        let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;\n        let breakAtEnd = last ? last.breakAfter : breakAtStart;\n        // Change within a single line\n        if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 &&\n            before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0))\n            return;\n        let after = this.children[toI];\n        // Make sure the end of the line after the update is preserved in `after`\n        if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {\n            // If we're splitting a line, separate part of the start line to\n            // avoid that being mangled when updating the start line.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true)) {\n                content[content.length - 1] = after;\n            }\n            else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && after.children[0].length == 0)\n                    after.merge(0, toOff, null, false);\n                content.push(after);\n            }\n        }\n        else if (after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last)\n                last.breakAfter = 1;\n            else\n                breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false)) {\n                before.breakAfter = content.shift().breakAfter;\n            }\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false);\n            }\n            fromI++;\n        }\n        // Try to merge widgets on the boundaries of the replacement\n        while (fromI < toI && content.length) {\n            if (this.children[toI - 1].match(content[content.length - 1]))\n                toI--, content.pop();\n            else if (this.children[fromI].match(content[0]))\n                fromI++, content.shift();\n            else\n                break;\n        }\n        if (fromI < toI || content.length)\n            this.replaceChildren(fromI, toI, content);\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(force = false) {\n        this.clearSelectionDirty();\n        if (this.root.activeElement != this.dom)\n            return;\n        let primary = this.view.state.selection.primary;\n        // FIXME need to handle the case where the selection falls inside a block range\n        let anchor = this.domAtPos(primary.anchor);\n        let head = this.domAtPos(primary.head);\n        let domSel = getSelection(this.root);\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force ||\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.view.observer.ignore(() => {\n                // Selection.extend can be used to create an 'inverted' selection\n                // (one where the focus is before the anchor), but not all\n                // browsers support it yet.\n                if (domSel.extend) {\n                    domSel.collapse(anchor.node, anchor.offset);\n                    if (!primary.empty)\n                        domSel.extend(head.node, head.offset);\n                }\n                else {\n                    let range = document.createRange();\n                    if (primary.anchor > primary.head)\n                        [anchor, head] = [head, anchor];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    domSel.removeAllRanges();\n                    domSel.addRange(range);\n                }\n            });\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    nearest(dom) {\n        for (let cur = dom; cur;) {\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this)\n                return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view)\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for (; i < this.children.length - 1;) {\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView)\n                break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos) {\n        for (let off = this.length, i = this.children.length - 1;; i--) {\n            let child = this.children[i], start = off - child.breakAfter - child.length;\n            if (pos >= start && child.type != BlockType.WidgetAfter)\n                return child.coordsAt(pos - start);\n            off = start;\n        }\n    }\n    measureVisibleLineHeights() {\n        let result = [], { from, to } = this.view.viewState.viewport;\n        let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end > to)\n                break;\n            if (pos >= from) {\n                result.push(child.dom.getBoundingClientRect().height);\n                let width = child.dom.scrollWidth;\n                if (width > minWidth) {\n                    this.minWidth = minWidth = width;\n                    this.minWidthFrom = pos;\n                    this.minWidthTo = end;\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    measureTextSize() {\n        for (let child of this.children) {\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure)\n                    return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth;\n        dummy.className = \"cm-line\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(() => {\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            dummy.remove();\n        });\n        return { lineHeight, charWidth };\n    }\n    clearSelectionDirty() {\n        if (this.selectionDirty != null) {\n            cancelAnimationFrame(this.selectionDirty);\n            this.selectionDirty = null;\n        }\n    }\n    setSelectionDirty() {\n        this.view.observer.clearSelection();\n        if (this.selectionDirty == null)\n            this.selectionDirty = requestAnimationFrame(() => this.updateSelection());\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i)\n            pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let visible = this.view.viewState.viewport, viewports = [visible];\n        let { head, anchor } = this.view.state.selection.primary;\n        if (head < visible.from || head > visible.to) {\n            let { from, to } = this.view.viewState.lineAt(head, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        if (!viewports.some(({ from, to }) => anchor >= from && anchor <= to)) {\n            let { from, to } = this.view.viewState.lineAt(anchor, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        this.viewports = viewports.sort((a, b) => a.from - b.from);\n        let deco = [];\n        for (let pos = 0, i = 0;; i++) {\n            let next = i == viewports.length ? null : viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = this.view.viewState.lineAt(end, 0).bottom - this.view.viewState.lineAt(pos, 0).top;\n                deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));\n            }\n            if (!next)\n                break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        return this.decorations = [\n            ...this.view.state.facet(decorations),\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco,\n            this.compositionDeco,\n            ...this.view.pluginField(pluginDecorations)\n        ];\n    }\n    scrollPosIntoView(pos) {\n        let rect = this.coordsAt(pos);\n        if (!rect)\n            return;\n        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;\n        for (let margins of this.view.pluginField(PluginField.scrollMargins))\n            if (margins) {\n                let { left, right, top, bottom } = margins;\n                if (left != null)\n                    mLeft = Math.max(mLeft, left);\n                if (right != null)\n                    mRight = Math.max(mRight, right);\n                if (top != null)\n                    mTop = Math.max(mTop, top);\n                if (bottom != null)\n                    mBottom = Math.max(mBottom, bottom);\n            }\n        scrollRectIntoView(this.dom, {\n            left: rect.left - mLeft, top: rect.top - mTop,\n            right: rect.right + mRight, bottom: rect.bottom + mBottom\n        });\n    }\n}\n// Browsers appear to reserve a fixed amount of bits for height\n// styles, and ignore or clip heights above that. For Chrome and\n// Firefox, this is in the 20 million range, so we try to stay below\n// that.\nconst MaxNodeHeight = 1e7;\nclass BlockGapWidget extends WidgetType {\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    updateDOM(elt) {\n        if (this.value < MaxNodeHeight) {\n            while (elt.lastChild)\n                elt.lastChild.remove();\n            elt.style.height = this.value + \"px\";\n        }\n        else {\n            elt.style.height = \"\";\n            for (let remaining = this.value; remaining > 0; remaining -= MaxNodeHeight) {\n                let fill = elt.appendChild(document.createElement(\"div\"));\n                fill.style.height = Math.min(remaining, MaxNodeHeight) + \"px\";\n            }\n        }\n        return true;\n    }\n    get estimatedHeight() { return this.value; }\n}\nfunction computeCompositionDeco(view, changes) {\n    let sel = getSelection(view.root);\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset);\n    if (!textNode)\n        return Decoration.none;\n    let cView = view.docView.nearest(textNode);\n    let from, to, topNode = textNode;\n    if (cView instanceof InlineView) {\n        from = cView.posAtStart;\n        to = from + cView.length;\n        topNode = cView.dom;\n    }\n    else if (cView instanceof LineView) {\n        while (topNode.parentNode != cView.dom)\n            topNode = topNode.parentNode;\n        let prev = topNode.previousSibling;\n        while (prev && !ContentView.get(prev))\n            prev = prev.previousSibling;\n        from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n    }\n    else {\n        return Decoration.none;\n    }\n    let newFrom = ChangedRange.mapPos(from, 1, changes), newTo = Math.max(newFrom, ChangedRange.mapPos(to, -1, changes));\n    let text = textNode.nodeValue, doc = view.state.doc;\n    if (newTo - newFrom < text.length) {\n        if (doc.slice(newFrom, Math.min(doc.length, newFrom + text.length)) == text)\n            newTo = newFrom + text.length;\n        else if (doc.slice(Math.max(0, newTo - text.length), newTo) == text)\n            newFrom = newTo - text.length;\n        else\n            return Decoration.none;\n    }\n    else if (doc.slice(newFrom, newTo) != text) {\n        return Decoration.none;\n    }\n    return Decoration.set(Decoration.replace({ widget: new CompositionWidget({ top: topNode, text: textNode }) }).range(newFrom, newTo));\n}\nclass CompositionWidget extends WidgetType {\n    eq(value) { return this.value.top == value.top && this.value.text == value.text; }\n    toDOM() { return this.value.top; }\n    ignoreEvent() { return false; }\n    get customView() { return CompositionView; }\n}\nfunction nearbyTextNode(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\nclass DecorationComparator$1 {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange(from, to) { addRange(from, to, this.changes); }\n    comparePoint(from, to) { addRange(from, to, this.changes); }\n}\nfunction findChangedDeco(a, b, diff, length) {\n    let comp = new DecorationComparator$1;\n    RangeSet.compare(a, b, diff, length, comp);\n    return comp.changes;\n}\n\n// FIXME rename \"word\" to something more descriptive of what it actually does?\nfunction movePos(view, start, direction, granularity = \"character\", action) {\n    let sel = getSelection(view.root);\n    let context = LineContext.get(view, start);\n    let dir = direction == \"forward\" || direction == \"right\" ? 1 : -1;\n    // Can only query native behavior when Selection.modify is\n    // supported, the cursor is well inside the rendered viewport, and\n    // we're not doing by-line motion on Gecko (which will mess up goal\n    // column motion)\n    if (sel.modify && context && !context.nearViewportEnd(view) && view.hasFocus &&\n        granularity != \"word\" &&\n        !(granularity == \"line\" && (browser.gecko || view.state.selection.ranges.length > 1))) {\n        return view.observer.ignore(() => {\n            let prepared = context.prepareForQuery(view, start);\n            let startDOM = view.docView.domAtPos(start);\n            let equiv = (!browser.chrome || prepared.lines.length == 0) &&\n                isEquivalentPosition(startDOM.node, startDOM.offset, sel.focusNode, sel.focusOffset) && false;\n            // Firefox skips an extra character ahead when extending across\n            // an uneditable element (but not when moving)\n            if (prepared.atWidget && browser.gecko && action == \"extend\")\n                action = \"move\";\n            if (action == \"move\" && !(equiv && sel.isCollapsed))\n                sel.collapse(startDOM.node, startDOM.offset);\n            else if (action == \"extend\" && !equiv)\n                sel.extend(startDOM.node, startDOM.offset);\n            sel.modify(action, direction, granularity);\n            view.docView.setSelectionDirty();\n            let result = view.docView.posFromDOM(sel.focusNode, sel.focusOffset);\n            context.undoQueryPreparation(view, prepared);\n            return result;\n        });\n    }\n    else if (granularity == \"character\") {\n        return moveCharacterSimple(start, dir, context, view.state.doc);\n    }\n    else if (granularity == \"lineboundary\") {\n        if (context)\n            return context.start + (dir < 0 ? 0 : context.line.length);\n        let line = view.state.doc.lineAt(start);\n        return dir < 0 ? line.start : line.end;\n    }\n    else if (granularity == \"line\") {\n        if (context && !context.nearViewportEnd(view, dir)) {\n            let startCoords = view.coordsAtPos(start);\n            let goal = getGoalColumn(view, start, startCoords.left);\n            for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, dist = 5; dist < 50; dist += 10) {\n                let pos = posAtCoords(view, { x: goal.column, y: startY + dist * dir }, dir);\n                if (pos < 0)\n                    break;\n                if (pos != start) {\n                    goal.pos = pos;\n                    return pos;\n                }\n            }\n        }\n        // Can't do a precise one based on DOM positions, fall back to per-column\n        return moveLineByColumn(view.state.doc, view.state.tabSize, start, dir);\n    }\n    else if (granularity == \"word\") {\n        return moveWord(view, start, direction);\n    }\n    else {\n        throw new RangeError(\"Invalid move granularity: \" + granularity);\n    }\n}\nfunction moveLineByColumn(doc, tabSize, pos, dir) {\n    let line = doc.lineAt(pos);\n    // FIXME also needs goal column?\n    let col = 0;\n    for (const iter = doc.iterRange(line.start, pos); !iter.next().done;)\n        col = countColumn(iter.value, col, tabSize);\n    if (dir < 0 && line.start == 0)\n        return 0;\n    else if (dir > 0 && line.end == doc.length)\n        return line.end;\n    let otherLine = doc.line(line.number + dir);\n    let result = otherLine.start;\n    let seen = 0;\n    for (const iter = doc.iterRange(otherLine.start, otherLine.end); seen >= col && !iter.next().done;) {\n        const { offset, leftOver } = findColumn(iter.value, seen, col, tabSize);\n        seen = col - leftOver;\n        result += offset;\n    }\n    return result;\n}\nfunction moveCharacterSimple(start, dir, context, doc) {\n    if (context == null) {\n        for (let pos = start;; pos += dir) {\n            if (dir < 0 && pos == 0 || dir > 0 && pos == doc.length)\n                return pos;\n            if (!isExtendingChar((dir < 0 ? doc.slice(pos - 1, pos) : doc.slice(pos, pos + 1)).charCodeAt(0))) {\n                if (dir < 0)\n                    return pos - 1;\n                else if (pos != start)\n                    return pos;\n            }\n        }\n    }\n    for (let { i, off } = context.line.childPos(start - context.start), { children } = context.line, pos = start;;) {\n        if (off == (dir < 0 || i == children.length ? 0 : children[i].length)) {\n            i += dir;\n            if (i < 0 || i >= children.length) // End/start of line\n                return Math.max(0, Math.min(doc.length, pos + (start == pos ? dir : 0)));\n            off = dir < 0 ? children[i].length : 0;\n        }\n        let inline = children[i];\n        if (inline instanceof TextView) {\n            if (!isExtendingChar(inline.text.charCodeAt(off - (dir < 0 ? 1 : 0)))) {\n                if (dir < 0)\n                    return pos - 1;\n                else if (pos != start)\n                    return pos;\n            }\n            off += dir;\n            pos += dir;\n        }\n        else if (inline.length > 0) {\n            return pos - off + (dir < 0 ? 0 : inline.length);\n        }\n    }\n}\nfunction moveWord(view, start, direction) {\n    let { doc } = view.state;\n    for (let pos = start, i = 0;; i++) {\n        let next = movePos(view, pos, direction, \"character\", \"move\");\n        if (next == pos)\n            return pos; // End of document\n        if (doc.sliceLines(Math.min(next, pos), Math.max(next, pos)).length > 1)\n            return next; // Crossed a line boundary\n        let group = SelectionRange.groupAt(view.state, next, next > pos ? -1 : 1);\n        let away = pos < group.from && pos > group.to;\n        // If the group is away from its start position, we jumped over a\n        // bidi boundary, and should take the side closest (in index\n        // coordinates) to the start position\n        let start = away ? pos < group.head : group.from == pos ? false : group.to == pos ? true : next < pos;\n        pos = start ? group.from : group.to;\n        if (i > 0 || /\\S/.test(doc.slice(group.from, group.to)))\n            return pos;\n        next = Math.max(0, Math.min(doc.length, pos + (start ? -1 : 1)));\n    }\n}\nfunction getGoalColumn(view, pos, column) {\n    for (let goal of view.inputState.goalColumns)\n        if (goal.pos == pos)\n            return goal;\n    let goal = { pos: 0, column };\n    view.inputState.goalColumns.push(goal);\n    return goal;\n}\nclass LineContext {\n    constructor(line, start, index) {\n        this.line = line;\n        this.start = start;\n        this.index = index;\n    }\n    static get(view, pos) {\n        for (let i = 0, off = 0;; i++) {\n            let line = view.docView.children[i], end = off + line.length;\n            if (end >= pos) {\n                if (line instanceof LineView)\n                    return new LineContext(line, off, i);\n                if (line.length)\n                    return null;\n            }\n            off = end + 1;\n        }\n    }\n    nearViewportEnd(view, side = 0) {\n        for (let { from, to } of view.docView.viewports)\n            if (from > 0 && from == this.start && side <= 0 ||\n                to < view.state.doc.length && to == this.start + this.line.length && side >= 0)\n                return true;\n        return false;\n    }\n    // FIXME limit the amount of work in character motion in non-bidi\n    // context? or not worth it?\n    prepareForQuery(view, pos) {\n        let linesToSync = [], atWidget = false;\n        function maybeHide(view) {\n            if (!(view instanceof TextView))\n                atWidget = true;\n            if (view.length > 0)\n                return false;\n            view.dom.remove();\n            if (linesToSync.indexOf(view.parent) < 0)\n                linesToSync.push(view.parent);\n            return true;\n        }\n        let { i, off } = this.line.childPos(pos - this.start);\n        if (off == 0) {\n            for (let j = i; j < this.line.children.length; j++)\n                if (!maybeHide(this.line.children[j]))\n                    break;\n            for (let j = i; j > 0; j--)\n                if (!maybeHide(this.line.children[j - 1]))\n                    break;\n        }\n        function addForLine(line, omit = -1) {\n            if (line.children.length == 0)\n                return;\n            for (let i = 0, off = 0; i <= line.children.length; i++) {\n                let next = i == line.children.length ? null : line.children[i];\n                if ((!next || !(next instanceof TextView)) && off != omit &&\n                    (i == 0 || !(line.children[i - 1] instanceof TextView))) {\n                    line.dom.insertBefore(document.createTextNode(\"\\u200b\"), next ? next.dom : null);\n                    if (linesToSync.indexOf(line) < 0)\n                        linesToSync.push(line);\n                }\n                if (next)\n                    off += next.length;\n            }\n        }\n        if (this.index > 0)\n            addForLine(this.line.parent.children[this.index - 1]);\n        addForLine(this.line, pos - this.start);\n        if (this.index < this.line.parent.children.length - 1)\n            addForLine(this.line.parent.children[this.index + 1]);\n        return { lines: linesToSync, atWidget };\n    }\n    undoQueryPreparation(view, toSync) {\n        for (let line of toSync.lines) {\n            line.dirty = 2 /* Node */;\n            line.sync();\n            line.dirty = 0 /* Not */;\n        }\n    }\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\n// FIXME holding arrow-up/down at the end of the viewport is a rather\n// common use case that will repeatedly trigger this code. Maybe\n// introduce some element of binary search after all?\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY;\n    let above, below, aboveRect, belowRect;\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        let rects = clientRectsFor(child);\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect))\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0)\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                }\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            }\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            }\n            else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    }\n    else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest)\n        return { node: parent, offset: 0 };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3)\n        return domPosInText(closest, clipX, y);\n    if (!closestX && closest.contentEditable == \"true\")\n        domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return { node: parent, offset };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length, range = document.createRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rects = range.getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (rect.top == rect.bottom)\n                continue;\n            if (rect.left - 1 <= x && rect.right + 1 >= x &&\n                rect.top - 1 <= y && rect.bottom + 1 >= y) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    range.setEnd(node, i);\n                    let rectBefore = range.getBoundingClientRect();\n                    if (rectBefore.left == rect.right)\n                        after = !right;\n                }\n                return { node, offset: i + (after ? 1 : 0) };\n            }\n        }\n    }\n    return { node, offset: 0 };\n}\nfunction posAtCoords(view, { x, y }, bias = -1) {\n    let content = view.contentDOM.getBoundingClientRect(), block;\n    let halfLine = view.defaultLineHeight / 2;\n    for (let bounced = false;;) {\n        block = view.blockAtHeight(y, content.top);\n        if (block.top > y || block.bottom < y) {\n            bias = block.top > y ? -1 : 1;\n            y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));\n            if (bounced)\n                return -1;\n            else\n                bounced = true;\n        }\n        if (block.type == BlockType.Text)\n            break;\n        y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n    }\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from)\n        return view.viewport.from == 0 ? 0 : -1;\n    if (lineStart > view.viewport.to)\n        return view.viewport.to == view.state.doc.length ? view.state.doc.length : -1;\n    // Clip x to the viewport sides\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    let root = view.root, element = root.elementFromPoint(x, y);\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {\n        if (root.caretPositionFromPoint) {\n            let pos = root.caretPositionFromPoint(x, y);\n            if (pos)\n                ({ offsetNode: node, offset } = pos);\n        }\n        else if (root.caretRangeFromPoint) {\n            let range = root.caretRangeFromPoint(x, y);\n            if (range)\n                ({ startContainer: node, startOffset: offset } = range);\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node) {\n        let { line } = LineContext.get(view, lineStart);\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    return view.docView.posFromDOM(node, offset);\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n    constructor(view) {\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.registeredEvents = [];\n        this.customHandlers = [];\n        this.composing = false;\n        this.goalColumns = [];\n        this.mouseSelection = null;\n        for (let type in handlers) {\n            let handler = handlers[type];\n            view.contentDOM.addEventListener(type, (event) => {\n                if (!eventBelongsToEditor(view, event))\n                    return;\n                if (this.runCustomHandlers(type, view, event))\n                    event.preventDefault();\n                else\n                    handler(view, event);\n            });\n            this.registeredEvents.push(type);\n        }\n        // Must always run, even if a custom handler handled the event\n        view.contentDOM.addEventListener(\"keydown\", (event) => {\n            view.inputState.lastKeyCode = event.keyCode;\n            view.inputState.lastKeyTime = Date.now();\n        });\n        if (view.root.activeElement == view.contentDOM)\n            view.dom.classList.add(\"cm-focused\");\n        this.notifiedFocused = view.hasFocus;\n        this.ensureHandlers(view);\n    }\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    ensureHandlers(view) {\n        let handlers = view.state.facet(domEventHandlers);\n        if (handlers == this.customHandlers)\n            return;\n        this.customHandlers = handlers;\n        for (let set of handlers) {\n            for (let type in set)\n                if (this.registeredEvents.indexOf(type) < 0) {\n                    this.registeredEvents.push(type);\n                    (type != \"scroll\" ? view.contentDOM : view.scrollDOM).addEventListener(type, (event) => {\n                        if (!eventBelongsToEditor(view, event))\n                            return;\n                        if (this.runCustomHandlers(type, view, event))\n                            event.preventDefault();\n                    });\n                }\n        }\n    }\n    runCustomHandlers(type, view, event) {\n        for (let handlers of this.customHandlers) {\n            let handler = handlers[type];\n            if (handler) {\n                try {\n                    if (handler(view, event) || event.defaultPrevented)\n                        return true;\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n        }\n        return false;\n    }\n    startMouseSelection(view, event, update) {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n        this.mouseSelection = new MouseSelection(this, view, event, update);\n    }\n    update(update) {\n        if (this.mouseSelection)\n            this.mouseSelection.map(update.changes);\n        this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n    }\n}\nclass MouseSelection {\n    constructor(inputState, view, event, update) {\n        this.inputState = inputState;\n        this.view = view;\n        this.update = update;\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = event.shiftKey;\n        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, event);\n        this.dragMove = dragMovesSelection$1(view, event);\n        this.startSelection = view.state.selection;\n        let { pos, bias } = this.queryPos(event);\n        this.startPos = this.curPos = pos;\n        this.startBias = this.curBias = bias;\n        this.dragging = isInPrimarySelection(view, this.startPos, event) ? null : false;\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) {\n            event.preventDefault();\n            this.select();\n        }\n    }\n    queryPos(event) {\n        let pos = this.view.posAtCoords({ x: event.clientX, y: event.clientY });\n        let coords = pos < 0 ? null : this.view.coordsAtPos(pos);\n        let bias = !coords ? 1 :\n            coords.top > event.clientY ? -1 :\n                coords.bottom < event.clientY ? 1 :\n                    coords.left > event.clientX ? -1 : 1;\n        return { pos, bias };\n    }\n    move(event) {\n        if (event.buttons == 0)\n            return this.destroy();\n        if (this.dragging !== false)\n            return;\n        let { pos, bias } = this.queryPos(event);\n        if (pos == this.curPos && bias == this.curBias)\n            return;\n        this.curPos = pos;\n        this.curBias = bias;\n        this.select();\n    }\n    up(event) {\n        if (this.dragging == null)\n            this.select();\n        this.destroy();\n    }\n    destroy() {\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.inputState.mouseSelection = null;\n    }\n    select() {\n        let selection = this.update(this.view, this.startSelection, this.startPos, this.startBias, this.curPos, this.curBias, this.extend, this.multiple);\n        if (!selection.eq(this.view.state.selection))\n            this.view.dispatch(this.view.state.t().setSelection(selection)\n                .annotate(Transaction.userEvent, \"pointer\")\n                .scrollIntoView());\n    }\n    map(changes) {\n        if (changes.length) {\n            this.startSelection = this.startSelection.map(changes);\n            this.startPos = changes.mapPos(this.startPos);\n            this.curPos = changes.mapPos(this.curPos);\n        }\n        if (this.dragging)\n            this.dragging = this.dragging.map(changes);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection$1(view, event) {\n    let facet = view.state.facet(dragMovesSelection);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, pos, event) {\n    let { primary } = view.state.selection;\n    if (primary.empty)\n        return false;\n    if (pos < primary.from || pos > primary.to)\n        return false;\n    if (pos > primary.from && pos < primary.to)\n        return true;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (sel.rangeCount == 0)\n        return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\n            return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)\n        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))\n            return false;\n    return true;\n}\nconst handlers = Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n    (browser.ios && browser.webkit_version < 604);\nfunction capturePaste(view) {\n    let doc = view.dom.ownerDocument;\n    let target = doc.body.appendChild(doc.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        doc.body.removeChild(target);\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, text) {\n    view.dispatch(view.state.t().replaceSelection(text)\n        .annotate(Transaction.userEvent, \"paste\").scrollIntoView());\n}\nfunction mustCapture(event) {\n    let mods = (event.ctrlKey ? 1 /* Ctrl */ : 0) | (event.metaKey ? 8 /* Meta */ : 0) |\n        (event.altKey ? 2 /* Alt */ : 0) | (event.shiftKey ? 4 /* Shift */ : 0);\n    let code = event.keyCode, macCtrl = browser.mac && mods == 1 /* Ctrl */;\n    return code == 8 || (macCtrl && code == 72) || // Backspace, Ctrl-h on Mac\n        code == 46 || (macCtrl && code == 68) || // Delete, Ctrl-d on Mac\n        code == 27 || // Esc\n        (mods == (browser.mac ? 8 /* Meta */ : 1 /* Ctrl */) && // Ctrl/Cmd-[biyz]\n            (code == 66 || code == 73 || code == 89 || code == 90));\n}\nhandlers.keydown = (view, event) => {\n    if (mustCapture(event))\n        event.preventDefault();\n    view.inputState.setSelectionOrigin(\"keyboard\");\n};\nhandlers.touchdown = handlers.touchmove = (view, event) => {\n    view.inputState.setSelectionOrigin(\"pointer\");\n};\nhandlers.mousedown = (view, event) => {\n    if (event.button == 0)\n        view.startMouseSelection(event, updateMouseSelection(event.detail));\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) { // Single click\n        return new SelectionRange(pos);\n    }\n    else if (type == 2) { // Double click\n        return SelectionRange.groupAt(view.state, pos, bias);\n    }\n    else { // Triple click\n        let context = LineContext.get(view, pos);\n        if (context)\n            return new SelectionRange(context.start + context.line.length, context.start);\n        let { start, end } = view.state.doc.lineAt(pos);\n        return new SelectionRange(start, end);\n    }\n}\nfunction updateMouseSelection(type) {\n    return (view, startSelection, startPos, startBias, curPos, curBias, extend, multiple) => {\n        let range = rangeForClick(view, curPos, curBias, type);\n        if (startPos != curPos && !extend) {\n            let startRange = rangeForClick(view, startPos, startBias, type);\n            let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n            range = from < range.from ? new SelectionRange(from, to) : new SelectionRange(to, from);\n        }\n        if (extend)\n            return startSelection.replaceRange(startSelection.primary.extend(range.from, range.to));\n        else if (multiple)\n            return startSelection.addRange(range);\n        else\n            return EditorSelection.create([range]);\n    };\n}\nhandlers.dragstart = (view, event) => {\n    let { doc, selection: { primary } } = view.state;\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection)\n        mouseSelection.dragging = primary;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", doc.slice(primary.from, primary.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n};\nhandlers.drop = (view, event) => {\n    if (!event.dataTransfer)\n        return;\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    let text = event.dataTransfer.getData(\"Text\");\n    if (dropPos < 0 || !text)\n        return;\n    event.preventDefault();\n    let tr = view.state.t();\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection && mouseSelection.dragging && mouseSelection.dragMove) {\n        tr.replace(mouseSelection.dragging.from, mouseSelection.dragging.to, \"\");\n        dropPos = tr.changes.mapPos(dropPos);\n    }\n    let change = new Change(dropPos, dropPos, view.state.splitLines(text));\n    tr.change(change)\n        .setSelection(EditorSelection.single(dropPos, dropPos + change.length))\n        .annotate(Transaction.userEvent, \"drop\");\n    view.focus();\n    view.dispatch(tr);\n};\nhandlers.paste = (view, event) => {\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = data && data.getData(\"text/plain\");\n    if (text) {\n        doPaste(view, text);\n        event.preventDefault();\n    }\n    else {\n        capturePaste(view);\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let doc = view.dom.ownerDocument;\n    let target = doc.body.appendChild(doc.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(() => {\n        doc.body.removeChild(target);\n        view.focus();\n    }, 50);\n}\nhandlers.copy = handlers.cut = (view, event) => {\n    let range = view.state.selection.primary;\n    if (range.empty)\n        return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = view.state.joinLines(view.state.doc.sliceLines(range.from, range.to));\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, text);\n    }\n    if (event.type == \"cut\") {\n        view.dispatch(view.state.t().replaceSelection([\"\"]).scrollIntoView().annotate(Transaction.userEvent, \"cut\"));\n    }\n};\nhandlers.focus = handlers.blur = view => {\n    setTimeout(() => {\n        if (view.hasFocus != view.inputState.notifiedFocused)\n            view.update([]);\n    }, 10);\n};\nhandlers.beforeprint = view => {\n    view.viewState.printing = true;\n    view.requestMeasure();\n    setTimeout(() => {\n        view.viewState.printing = false;\n        view.requestMeasure();\n    }, 2000);\n};\nfunction forceClearComposition(view) {\n    if (view.docView.compositionDeco.size)\n        view.update([]);\n}\nhandlers.compositionstart = handlers.compositionupdate = view => {\n    if (!view.inputState.composing) {\n        if (view.docView.compositionDeco.size) {\n            view.observer.flush();\n            forceClearComposition(view);\n        }\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = true;\n    }\n};\nhandlers.compositionend = view => {\n    view.inputState.composing = false;\n    setTimeout(() => {\n        if (!view.inputState.composing)\n            forceClearComposition(view);\n    }, 50);\n};\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view, onChange, onScrollChanged) {\n        this.view = view;\n        this.onChange = onChange;\n        this.onScrollChanged = onScrollChanged;\n        this.active = false;\n        this.ignoreSelection = new DOMSelection;\n        this.charDataQueue = [];\n        this.charDataTimeout = null;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.intersecting = false;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver(mutations => this.flush(mutations));\n        if (useCharData)\n            this.onCharData = (event) => {\n                this.charDataQueue.push({ target: event.target,\n                    type: \"characterData\",\n                    oldValue: event.prevValue });\n                if (this.charDataTimeout == null)\n                    this.charDataTimeout = setTimeout(() => this.flush(), 20);\n            };\n        this.onSelectionChange = () => {\n            if (this.view.root.activeElement == this.dom)\n                this.flush();\n        };\n        this.start();\n        this.onScroll = this.onScroll.bind(this);\n        window.addEventListener(\"scroll\", this.onScroll);\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver(entries => {\n                if (this.parentCheck < 0)\n                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    this.onScroll();\n                }\n            }, {});\n            this.intersection.observe(this.dom);\n        }\n        this.listenForScroll();\n    }\n    onScroll() {\n        if (this.intersecting) {\n            this.flush();\n            this.onScrollChanged();\n        }\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for (let dom = this.dom; dom;) {\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\n                    i++;\n                else if (!changed)\n                    changed = this.scrollTargets.slice(0, i);\n                if (changed)\n                    changed.push(dom);\n                dom = dom.parentNode;\n            }\n            else if (dom.nodeType == 11) { // Shadow root\n                dom = dom.host;\n            }\n            else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed)\n            changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)\n                dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)\n                dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active)\n            return f();\n        try {\n            this.stop();\n            return f();\n        }\n        finally {\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active)\n            return;\n        this.observer.observe(this.dom, observeOptions);\n        // FIXME is this shadow-root safe?\n        this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active)\n            return;\n        this.active = false;\n        this.observer.disconnect();\n        this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    takeCharRecords() {\n        let result = this.charDataQueue;\n        if (result.length) {\n            this.charDataQueue = [];\n            clearTimeout(this.charDataTimeout);\n            this.charDataTimeout = null;\n        }\n        return result;\n    }\n    clearSelection() {\n        this.ignoreSelection.set(getSelection(this.view.root));\n    }\n    // Throw away any pending changes\n    clear() {\n        this.observer.takeRecords();\n        this.takeCharRecords();\n        this.clearSelection();\n    }\n    // Apply pending changes, if any\n    flush(records = this.observer.takeRecords()) {\n        if (this.charDataQueue.length)\n            records = records.concat(this.takeCharRecords());\n        let selection = getSelection(this.view.root);\n        let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);\n        if (records.length == 0 && !newSel)\n            return;\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records) {\n            let range = this.readMutation(record);\n            if (!range)\n                continue;\n            if (range.typeOver)\n                typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            }\n            else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        let apply = from > -1 || newSel;\n        if (!apply || !this.onChange(from, to, typeOver)) {\n            if (this.view.docView.dirty) {\n                this.ignore(() => this.view.docView.sync());\n                this.view.docView.dirty = 0 /* Not */;\n            }\n            this.view.docView.updateSelection();\n        }\n        this.clearSelection();\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec))\n            return null;\n        cView.markDirty();\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\n        }\n        else { // \"characterData\"\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\n        }\n    }\n    destroy() {\n        this.stop();\n        if (this.intersection)\n            this.intersection.disconnect();\n        for (let dom of this.scrollTargets)\n            dom.removeEventListener(\"scroll\", this.onScroll);\n        window.removeEventListener(\"scroll\", this.onScroll);\n        clearTimeout(this.parentCheck);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while (dom) {\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView)\n            return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n\nconst LineSep = \"\\ufdda\"; // A Unicode 'non-character', used to denote newlines internally\nfunction applyDOMChange(view, start, end, typeOver) {\n    let change, newSel;\n    let sel = view.state.selection.primary, bounds;\n    if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {\n        let { from, to } = bounds;\n        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view.contentDOM, view.root);\n        let reader = new DOMReader(selPoints);\n        reader.readRange(bounds.startDOM, bounds.endDOM);\n        newSel = selectionFromPoints(selPoints, from);\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed\n        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.slice(from, to, LineSep), reader.text, preferredPos - from, preferredSide);\n        if (diff)\n            change = new Change(from + diff.from, from + diff.toA, reader.text.slice(diff.from, diff.toB).split(LineSep));\n    }\n    else if (view.hasFocus) {\n        let domSel = getSelection(view.root);\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ? view.state.selection.primary.head\n            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset\n            ? view.state.selection.primary.anchor\n            : selectionCollapsed(domSel) ? head : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n        if (head != sel.head || anchor != sel.anchor)\n            newSel = EditorSelection.single(anchor, head);\n    }\n    if (!change && !newSel)\n        return false;\n    // Heuristic to notice typing over a selected character\n    if (!change && typeOver && !sel.empty && newSel && newSel.primary.empty)\n        change = new Change(sel.from, sel.to, view.state.doc.sliceLines(sel.from, sel.to));\n    if (change) {\n        let startState = view.state;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events.\n        if (browser.android &&\n            ((change.from == sel.from && change.to == sel.to &&\n                change.length == 1 && change.text.length == 2 &&\n                dispatchKey(view, \"Enter\", 10)) ||\n                (change.from == sel.from - 1 && change.to == sel.to && change.length == 0 &&\n                    dispatchKey(view, \"Backspace\", 8)) ||\n                (change.from == sel.from && change.to == sel.to + 1 && change.length == 0 &&\n                    dispatchKey(view, \"Delete\", 46))))\n            return view.state != startState;\n        let tr = startState.t();\n        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3) {\n            let before = sel.from < change.from ? startState.doc.slice(sel.from, change.from, LineSep) : \"\";\n            let after = sel.to > change.to ? startState.doc.slice(change.to, sel.to, LineSep) : \"\";\n            tr.replaceSelection((before + change.text.join(LineSep) + after).split(LineSep));\n        }\n        else {\n            tr.change(change);\n            if (newSel && !tr.selection.primary.eq(newSel.primary))\n                tr.setSelection(tr.selection.replaceRange(newSel.primary));\n        }\n        view.dispatch(tr.scrollIntoView().annotate(Transaction.userEvent, \"input\"));\n        return true;\n    }\n    else if (newSel && !newSel.primary.eq(sel)) {\n        let tr = view.state.t().setSelection(newSel);\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"keyboard\")\n                tr.scrollIntoView();\n            else\n                tr.annotate(Transaction.userEvent, view.inputState.lastSelectionOrigin);\n        }\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\n        from++;\n    if (from == minLen && a.length == b.length)\n        return null;\n    let toA = a.length, toB = b.length;\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    }\n    else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return { from, toA, toB };\n}\nclass DOMReader {\n    constructor(points) {\n        this.points = points;\n        this.text = \"\";\n    }\n    readRange(start, end) {\n        if (!start)\n            return;\n        let parent = start.parentNode;\n        for (let cur = start;;) {\n            this.findPointBefore(parent, cur);\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end)\n                break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if ((view ? view.breakAfter : isBlockElement(cur)) ||\n                ((nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == \"BR\" && !cur.cmIgnore)))\n                this.text += LineSep;\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n    }\n    readNode(node) {\n        if (node.cmIgnore)\n            return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        let text;\n        if (fromView != null)\n            text = fromView.join(LineSep);\n        else if (node.nodeType == 3)\n            text = node.nodeValue;\n        else if (node.nodeName == \"BR\")\n            text = node.nextSibling ? LineSep : \"\";\n        else if (node.nodeType == 1)\n            this.readRange(node.firstChild, null);\n        if (text != null) {\n            this.findPointIn(node, text.length);\n            this.text += text;\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)\n            if (point.node == node && node.childNodes[point.offset] == next)\n                point.pos = this.text.length;\n    }\n    findPointIn(node, maxLen) {\n        for (let point of this.points)\n            if (point.node == node)\n                point.pos = this.text.length + Math.min(point.offset, maxLen);\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset) {\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nfunction selectionPoints(dom, root) {\n    let result = [];\n    if (root.activeElement != dom)\n        return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = getSelection(root);\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\n            result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0)\n        return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base, head + base) : null;\n}\nfunction dispatchKey(view, name, code) {\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\n    let down = new KeyboardEvent(\"keydown\", options);\n    view.contentDOM.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    view.contentDOM.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle  Updating  Idle (unchecked)  Measuring  Idle\n//                                               \n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/// An editor view represents the editor's user interface. It holds\n/// the editable DOM surface, and possibly other elements such as the\n/// line number gutter. It handles events and dispatches state\n/// transactions for editing actions.\nclass EditorView {\n    /// Construct a new view. You'll usually want to put `view.dom` into\n    /// your document after creating a view, so that the user can see\n    /// it.\n    constructor(config = {}) {\n        this.plugins = [];\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        /// @internal\n        this.updateState = 2 /* Updating */;\n        /// @internal\n        this.measureScheduled = -1;\n        /// @internal\n        this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.className = themeClass(\"scroller\");\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.scrollDOM);\n        this.dispatch = config.dispatch || ((tr) => this.update([tr]));\n        this.root = (config.root || document);\n        this.viewState = new ViewState(config.state || EditorState.create());\n        this.plugins = this.state.facet(viewPlugin).map(spec => PluginInstance.create(spec, this));\n        this.observer = new DOMObserver(this, (from, to, typeOver) => applyDOMChange(this, from, to, typeOver), () => this.measure());\n        this.docView = new DocView(this);\n        this.inputState = new InputState(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        ensureGlobalHandler();\n        this.requestMeasure();\n    }\n    /// The current editor state.\n    get state() { return this.viewState.state; }\n    /// To be able to display large documents without consuming too much\n    /// memory or overloading the browser, CodeMirror only draws the\n    /// code that is visible (plus a margin around it) to the DOM. This\n    /// property tells you the extent of the current drawn viewport, in\n    /// document positions.\n    get viewport() { return this.viewState.viewport; }\n    /// When there are, for example, large collapsed ranges in the\n    /// viewport, its size can be a lot bigger than the actual visible\n    /// content. Thus, if you are doing something like styling the\n    /// content in the viewport, it is preferable to only do so for\n    /// these ranges, which are the subset of the viewport that is\n    /// actually drawn.\n    get visibleRanges() { return this.viewState.visibleRanges; }\n    /// Update the view for the given array of transactions. This will\n    /// update the visible document and selection to match the state\n    /// produced by the transactions, and notify view plugins of the\n    /// change.\n    update(transactions) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        this.updateState = 2 /* Updating */;\n        let state = this.state;\n        for (let tr of transactions) {\n            if (tr.startState != state)\n                throw new RangeError(\"Trying to update state with a transaction that doesn't start from the current state.\");\n            state = tr.apply();\n        }\n        let update = new ViewUpdate(this, state, transactions);\n        if (state.doc != this.state.doc || transactions.some(tr => tr.selectionSet && !tr.annotation(Transaction.preserveGoalColumn)))\n            this.inputState.goalColumns.length = 0;\n        let scrollTo = transactions.some(tr => tr.scrolledIntoView) ? state.selection.primary.head : -1;\n        this.viewState.update(update, scrollTo);\n        if (!update.empty)\n            this.updatePlugins(update);\n        let redrawn = this.docView.update(update);\n        this.inputState.ensureHandlers(this);\n        if (this.state.facet(styleModule) != this.styleModules)\n            this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        if (redrawn || scrollTo > -1)\n            this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.prevState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [], reused = [];\n            for (let spec of specs) {\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(PluginInstance.create(spec, this));\n                }\n                else {\n                    let plugin = this.plugins[found].update(update);\n                    reused.push(plugin);\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)\n                if (plugin.destroy && reused.indexOf(plugin) < 0)\n                    plugin.destroy();\n            this.plugins = newPlugins;\n        }\n        else {\n            for (let i = 0; i < this.plugins.length; i++)\n                this.plugins[i] = this.plugins[i].update(update);\n        }\n    }\n    /// @internal\n    measure() {\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n        this.measureScheduled = 1; // Prevent requestMeasure calls from scheduling another animation frame\n        for (let i = 0;; i++) {\n            this.updateState = 1 /* Measuring */;\n            let changed = this.viewState.measure(this.docView, i > 0);\n            let measuring = this.measureRequests;\n            if (!changed && !measuring.length)\n                break;\n            this.measureRequests = [];\n            if (i > 5) {\n                console.warn(\"Viewport failed to stabilize\");\n                break;\n            }\n            let measured = measuring.map(m => m.read(this));\n            let update = new ViewUpdate(this, this.state);\n            update.flags |= changed;\n            this.updateState = 2 /* Updating */;\n            this.updatePlugins(update);\n            if (changed)\n                this.docView.update(update);\n            for (let i = 0; i < measuring.length; i++)\n                measuring[i].write(measured[i], this);\n            if (!(changed & 4 /* Viewport */) && this.measureRequests.length == 0)\n                break;\n        }\n        this.updateState = 0 /* Idle */;\n        this.measureScheduled = -1;\n    }\n    updateAttrs() {\n        let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {\n            class: themeClass(\"wrap\") + (this.hasFocus ? \" cm-focused \" : \" \") +\n                baseThemeID + \" \" + this.state.facet(theme).join(\" \")\n        });\n        updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n        this.editorAttrs = editorAttrs;\n        let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {\n            spellcheck: \"false\",\n            contenteditable: \"true\",\n            class: themeClass(\"content\"),\n            style: `${browser.tabSize}: ${this.state.tabSize}`\n        });\n        updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n        this.contentAttrs = contentAttrs;\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());\n    }\n    /// Look up a translation for the given phrase (via the\n    /// [`phrases`](#view.EditorView^phrases) facet), or return the\n    /// original string if no translation is found.\n    phrase(phrase) {\n        for (let map of this.state.facet(phrases)) {\n            if (Object.prototype.hasOwnProperty.call(map, phrase))\n                return map[phrase];\n        }\n        return phrase;\n    }\n    /// Find the DOM parent node and offset (child offset if `node` is\n    /// an element, character offset when it is a text node) at the\n    /// given document position.\n    domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /// Find the document position at the given DOM node. Can be useful\n    /// for associating positions with DOM events. Will raise an error\n    /// when `node` isn't part of the editor content.\n    posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* Updating */)\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* Idle */ && this.measureScheduled > -1)\n            this.measure();\n    }\n    /// Make sure plugins get a chance to measure the DOM before the\n    /// next frame. Calling this is preferable to messing with the DOM\n    /// directly from, for example, an even handler, because it'll make\n    /// sure measuring and drawing done by other components is\n    /// synchronized, avoiding unnecessary DOM layout computations.\n    requestMeasure(request) {\n        if (this.measureScheduled < 0)\n            this.measureScheduled = requestAnimationFrame(() => this.measure());\n        if (request) {\n            if (request.key != null)\n                for (let i = 0; i < this.measureRequests.length; i++) {\n                    if (this.measureRequests[i].key === request.key) {\n                        this.measureRequests[i] = request;\n                        return;\n                    }\n                }\n            this.measureRequests.push(request);\n        }\n    }\n    /// Collect all values provided by the active plugins for a given\n    /// field.\n    pluginField(field) {\n        // FIXME make this error when called during plugin updating\n        let result = [];\n        for (let plugin of this.plugins)\n            plugin.takeField(field, result);\n        return result;\n    }\n    /// Get the value of a specific plugin, if present. Note that\n    /// plugins that crash can be dropped from a view, so even when you\n    /// know you registered a given plugin, it is recommended to check\n    /// the return value of this method.\n    plugin(plugin) {\n        for (let inst of this.plugins)\n            if (inst.spec == plugin)\n                return inst.value;\n        return null;\n    }\n    /// Find the line or block widget at the given vertical position.\n    /// `editorTop`, if given, provides the vertical position of the top\n    /// of the editor. It defaults to the editor's screen position\n    /// (which will force a DOM layout).\n    blockAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.blockAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find information for the line at the given vertical position.\n    /// The resulting block info might hold another array of block info\n    /// structs in its `type` field if this line consists of more than\n    /// one block.\n    lineAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.lineAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find the height information for the given line.\n    lineAt(pos, editorTop) {\n        this.readMeasured();\n        return this.viewState.lineAt(pos, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Iterate over the height information of the lines in the\n    /// viewport.\n    viewportLines(f, editorTop) {\n        let { from, to } = this.viewport;\n        this.viewState.forEachLine(from, to, f, ensureTop(editorTop, this.contentDOM));\n    }\n    /// The editor's total content height.\n    get contentHeight() {\n        return this.viewState.heightMap.height + this.viewState.paddingTop + this.viewState.paddingBottom;\n    }\n    /// Compute cursor motion from the given position, in the given\n    /// direction, by the given unit. Since this might involve\n    /// temporarily mutating the DOM selection, you can pass the action\n    /// type this will be used for to, in case the editor selection is\n    /// set to the new position right away, avoid an extra DOM selection\n    /// change.\n    movePos(start, direction, granularity = \"character\", action = \"move\") {\n        return movePos(this, start, direction, granularity, action);\n    }\n    /// Get the document position at the given screen coordinates.\n    /// Returns -1 if no valid position could be found.\n    posAtCoords(coords) {\n        this.readMeasured();\n        return posAtCoords(this, coords);\n    }\n    /// Get the screen coordinates at the given document position.\n    coordsAtPos(pos) {\n        this.readMeasured();\n        return this.docView.coordsAt(pos);\n    }\n    /// The default width of a character in the editor. May not\n    /// accurately reflect the width of all characters.\n    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }\n    /// The default height of a line in the editor.\n    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }\n    /// The text direction (`direction` CSS property) of the editor.\n    get textDirection() { return this.viewState.heightOracle.direction; }\n    /// Start a custom mouse selection event.\n    startMouseSelection(event, update) {\n        this.focus();\n        this.inputState.startMouseSelection(this, event, update);\n    }\n    /// Check whether the editor has focus.\n    get hasFocus() {\n        return this.root.activeElement == this.contentDOM;\n    }\n    /// Put focus on the editor.\n    focus() {\n        this.observer.ignore(() => {\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /// Clean up this editor view, removing its element from the\n    /// document, unregistering event handlers, and notifying\n    /// plugins. The view instance can no longer be used after\n    /// calling this.\n    destroy() {\n        for (let plugin of this.plugins)\n            plugin.destroy();\n        this.inputState.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n    }\n    /// Create a theme extension. The argument object should map [theme\n    /// selectors](#view.themeClass) to styles, which are (potentially\n    /// nested) [style\n    /// declarations](https://github.com/marijnh/style-mod#documentation)\n    /// providing the CSS styling for the selector.\n    static theme(spec) {\n        let prefix = StyleModule.newName();\n        return [theme.of(prefix), styleModule.of(buildTheme(prefix, spec))];\n    }\n    /// Create an extension that adds styles to the base theme.\n    static baseTheme(spec) {\n        return Precedence.Fallback.set(styleModule.of(buildTheme(baseThemeID, spec)));\n    }\n}\n/// Facet that registers [view plugins](#view.ViewPlugin). Usually,\n/// it is more convenient to use\n/// [`ViewPlugin.register`](#view.ViewPlugin^register).\nEditorView.plugin = viewPlugin;\n/// Facet to add a [style\n/// module](https://github.com/marijnh/style-mod#readme) to an editor\n/// view. The view will ensure that the module is registered in its\n/// [document root](#view.EditorConfig.root).\nEditorView.styleModule = styleModule;\n/// Facet that can be used to add DOM event handlers. The value\n/// should be an object mapping event names to handler functions. The\n/// first such function to return true will be assumed to have handled\n/// that event, and no other handlers or built-in behavior will be\n/// activated for it.\nEditorView.domEventHandlers = domEventHandlers;\n/// Facet used to configure whether a given selection drag event\n/// should move or copy the selection. The given predicate will be\n/// called with the `mousedown` event, and can return `true` when\n/// the drag should move the content.\nEditorView.dragMovesSelection = dragMovesSelection;\n/// Facet used to configure whether a given selecting click adds\n/// a new range to the existing selection or replaces it entirely.\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/// A facet that determines which [decorations](#view.Decoration)\n/// are shown in the view. See also [view\n/// plugins](#view.EditorView^decorations), which have a separate\n/// mechanism for providing decorations.\nEditorView.decorations = decorations;\n/// Registers translation phrases. The\n/// [`phrase`](#view.EditorView.phrase) method will look through all\n/// objects registered with this facet to find translations for\n/// its argument.\nEditorView.phrases = phrases;\n/// Facet that provides attributes for the editor's editable DOM\n/// element.\nEditorView.contentAttributes = contentAttributes;\n/// Facet that provides editor DOM attributes for the editor's\n/// outer element.\nEditorView.editorAttributes = editorAttributes;\nfunction ensureTop(given, dom) {\n    return given == null ? dom.getBoundingClientRect().top : given;\n}\nlet resizeDebounce = -1;\nfunction ensureGlobalHandler() {\n    window.addEventListener(\"resize\", () => {\n        if (resizeDebounce == -1)\n            resizeDebounce = setTimeout(handleResize, 50);\n    });\n}\nfunction handleResize() {\n    resizeDebounce = -1;\n    let found = document.querySelectorAll(\".cm-content\");\n    for (let i = 0; i < found.length; i++) {\n        let docView = ContentView.get(found[i]);\n        if (docView)\n            docView.editorView.requestMeasure();\n    }\n}\n\n/// @internal\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType };\n\nexport { BlockInfo, BlockType, Decoration, EditorView, PluginField, ViewPlugin, ViewUpdate, WidgetType, __test, themeClass };\n","import { NodeProp, NodeType } from 'lezer-tree';\nimport { StyleModule } from 'style-mod';\nimport { ViewPlugin, EditorView, Decoration } from '../../view';\nimport { EditorState } from '../../state';\nimport { RangeSetBuilder } from '../../rangeset';\n\nconst Inherit = 1;\n/// A tag system defines a set of node (token) tags used for\n/// highlighting. You'll usually want to use the\n/// [default](#highlight.defaultTags) set, but it is possible to\n/// define your own custom system when that doesn't fit your use case.\nclass TagSystem {\n    /// Define a tag system. Each tag identifies a type of syntactic\n    /// element, which can have a single type and any number of flags.\n    /// The `flags` argument should be an array of flag names, and the\n    /// `types` argument an array of type names. Type names may have a\n    /// `\"name=parentName\"` format to specify that this type is an\n    /// instance of some other type, which means that, if no styling for\n    /// the type itself is provided, it'll fall back to the parent\n    /// type's styling.\n    ///\n    /// You can specify a `subtypes` property to assign a given number\n    /// of sub-types to each type. These are automatically generated\n    /// types with the base type name suffixed with `#1` to `#`_`N`_\n    /// (where _N_ is the number given in the `subtypes` field) that\n    /// have the base type as parent type.\n    constructor(options) {\n        /// @internal\n        this.typeNames = [\"\"];\n        /// @internal\n        this.typeIDs = Object.create(null);\n        /// A [node\n        /// prop](https://lezer.codemirror.net/docs/ref#tree.NodeProp) used\n        /// to associate styling tag information with syntax tree nodes.\n        this.prop = new NodeProp();\n        this.flags = options.flags;\n        this.types = options.types;\n        this.flagMask = Math.pow(2, this.flags.length) - 1;\n        this.typeShift = this.flags.length + 1;\n        let subtypes = options.subtypes || 0;\n        let parentNames = [undefined];\n        this.typeIDs[\"\"] = 0;\n        let typeID = 1;\n        for (let type of options.types) {\n            let match = /^([\\w\\-]+)(?:=([\\w-]+))?$/.exec(type);\n            if (!match)\n                throw new RangeError(\"Invalid type name \" + type);\n            let id = typeID++;\n            this.typeNames[id] = match[1];\n            this.typeIDs[match[1]] = id;\n            parentNames[id] = match[2];\n            for (let i = 0; i < subtypes; i++) {\n                let subID = typeID++, name = match[1] + \"#\" + (i + 1);\n                this.typeNames[subID] = name;\n                this.typeIDs[name] = subID;\n                parentNames[subID] = match[1];\n            }\n        }\n        this.parents = parentNames.map(name => {\n            if (name == null)\n                return 0;\n            let id = this.typeIDs[name];\n            if (id == null)\n                throw new RangeError(`Unknown parent type '${name}' specified`);\n            return id;\n        });\n        if (this.flags.length > 29 || this.typeNames.length > Math.pow(2, 29 - this.flags.length))\n            throw new RangeError(\"Too many style tag flags to fit in a 30-bit integer\");\n    }\n    /// Parse a tag name into a numeric ID. Only necessary if you are\n    /// manually defining [node properties](#highlight.TagSystem.prop)\n    /// for this system.\n    get(name) {\n        let value = name.charCodeAt(0) == 43 ? 1 : 0; // Check for leading '+'\n        for (let part of (value ? name.slice(1) : name).split(\" \"))\n            if (part) {\n                let flag = this.flags.indexOf(part);\n                if (flag > -1) {\n                    value += 1 << (flag + 1);\n                }\n                else {\n                    let typeID = this.typeIDs[part];\n                    if (typeID == null)\n                        throw new RangeError(`Unknown tag type '${part}'`);\n                    if (value >> this.typeShift)\n                        throw new RangeError(`Multiple tag types specified in '${name}'`);\n                    value += typeID << this.typeShift;\n                }\n            }\n        return value;\n    }\n    /// Create a\n    /// [`PropSource`](https://lezer.codemirror.net/docs/ref#tree.PropSource)\n    /// that adds node properties for this system. `tags` should map\n    /// node type\n    /// [selectors](https://lezer.codemirror.net/docs/ref#tree.NodeType^match)\n    /// to tag names.\n    add(tags) {\n        let match = NodeType.match(tags);\n        return this.prop.add((type) => {\n            let found = match(type);\n            return found == null ? undefined : this.get(found);\n        });\n    }\n    /// Create a highlighter extension for this system, styling the\n    /// given tags using the given CSS objects.\n    highlighter(spec) {\n        let styling = new Styling(this, spec);\n        return [\n            ViewPlugin.define(view => new Highlighter(view, this.prop, styling)).decorations(),\n            EditorView.styleModule.of(styling.module)\n        ];\n    }\n    /// @internal\n    specificity(tag) {\n        let flags = tag & this.flagMask, spec = 0;\n        for (let i = 1; i <= this.flags.length; i++)\n            if (flags & (1 << i))\n                spec++;\n        for (let type = tag >> (this.flags.length + 1); type; type = this.parents[type])\n            spec += 1000;\n        return spec;\n    }\n}\n/// The set of highlighting tags used by regular language packages and\n/// themes.\nconst defaultTags = new TagSystem({\n    flags: [\"invalid\", \"meta\",\n        \"link\", \"strong\", \"emphasis\", \"monospace\",\n        \"changed\", \"inserted\", \"deleted\",\n        \"definition\", \"constant\", \"control\"],\n    subtypes: 7,\n    types: [\n        \"comment\",\n        \"lineComment=comment\",\n        \"blockComment=comment\",\n        \"name\",\n        \"variableName=name\",\n        \"typeName=name\",\n        \"propertyName=name\",\n        \"className=name\",\n        \"labelName=name\",\n        \"namespace=name\",\n        \"literal\",\n        \"string=literal\",\n        \"character=string\",\n        \"number=literal\",\n        \"integer=number\",\n        \"float=number\",\n        \"regexp=literal\",\n        \"escape=literal\",\n        \"color=literal\",\n        \"content\",\n        \"heading=content\",\n        \"list=content\",\n        \"quote=content\",\n        \"keyword\",\n        \"self=keyword\",\n        \"null=keyword\",\n        \"atom=keyword\",\n        \"unit=keyword\",\n        \"modifier=keyword\",\n        \"operatorKeyword=keyword\",\n        \"operator\",\n        \"derefOperator=operator\",\n        \"arithmeticOperator=operator\",\n        \"logicOperator=operator\",\n        \"bitwiseOperator=operator\",\n        \"compareOperator=operator\",\n        \"updateOperator=operator\",\n        \"typeOperator=operator\",\n        \"punctuation\",\n        \"separator=punctuation\",\n        \"bracket=punctuation\",\n        \"angleBracket=bracket\",\n        \"squareBracket=bracket\",\n        \"paren=bracket\",\n        \"brace=bracket\"\n    ]\n});\n/// Used to add a set of tags to a language syntax via\n/// [`Parser.withProps`](https://lezer.codemirror.net/docs/ref#lezer.Parser.withProps).\n/// The argument object can use syntax node selectors (see\n/// [`NodeType.match`](https://lezer.codemirror.net/docs/ref#tree.NodeType^match))\n/// as property names, and tag names (in the [default tag\n/// system](#highlight.defaultTags)) as values.\nconst styleTags = (tags) => defaultTags.add(tags);\n/// Create a highlighter theme that adds the given styles to the given\n/// tags. The spec's property names must be tag names, and the values\n/// [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n/// style objects that define the CSS for that tag.\nconst highlighter = (spec) => defaultTags.highlighter(spec);\nclass StyleRule {\n    constructor(type, flags, specificity, cls) {\n        this.type = type;\n        this.flags = flags;\n        this.specificity = specificity;\n        this.cls = cls;\n    }\n}\nclass Styling {\n    constructor(tags, spec) {\n        this.tags = tags;\n        this.cache = Object.create(null);\n        let modSpec = Object.create(null);\n        let nextCls = 0;\n        let rules = [];\n        for (let prop in spec) {\n            let tag = tags.get(prop);\n            let cls = \"c\" + nextCls++;\n            modSpec[cls] = spec[prop];\n            rules.push(new StyleRule(tag >> tags.typeShift, tag & tags.flagMask, tags.specificity(tag), cls));\n        }\n        this.rules = rules.sort((a, b) => b.specificity - a.specificity);\n        this.module = new StyleModule(modSpec);\n    }\n    match(tag) {\n        let known = this.cache[tag];\n        if (known != null)\n            return known;\n        let result = \"\";\n        let type = tag >> this.tags.typeShift, flags = tag & this.tags.flagMask;\n        for (;;) {\n            for (let rule of this.rules) {\n                if (rule.type == type && (rule.flags & flags) == rule.flags) {\n                    if (result)\n                        result += \" \";\n                    result += this.module[rule.cls];\n                    flags &= ~rule.flags;\n                    if (type)\n                        break;\n                }\n            }\n            if (type)\n                type = this.tags.parents[type];\n            else\n                break;\n        }\n        return this.cache[tag] = result;\n    }\n}\nclass Highlighter {\n    constructor(view, prop, styling) {\n        this.prop = prop;\n        this.styling = styling;\n        this.tree = view.state.tree;\n        this.decorations = this.buildDeco(view.visibleRanges, this.tree);\n    }\n    update(update) {\n        let syntax = update.state.facet(EditorState.syntax);\n        if (!syntax.length) {\n            this.decorations = Decoration.none;\n        }\n        else if (syntax[0].parsePos(update.state) < update.view.viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n        }\n        else if (this.tree != syntax[0].getTree(update.state) || update.viewportChanged) {\n            this.tree = syntax[0].getTree(update.state);\n            this.decorations = this.buildDeco(update.view.visibleRanges, this.tree);\n        }\n    }\n    buildDeco(ranges, tree) {\n        let builder = new RangeSetBuilder();\n        let start = 0;\n        function flush(pos, style) {\n            if (pos > start && style)\n                builder.add(start, pos, Decoration.mark({ class: style })); // FIXME cache these\n            start = pos;\n        }\n        for (let { from, to } of ranges) {\n            start = from;\n            // The current node's own classes\n            let curClass = \"\";\n            let context = [];\n            let inherited = [];\n            tree.iterate({\n                from, to,\n                enter: (type, start) => {\n                    let inheritedClass = inherited.length ? inherited[inherited.length - 1] : \"\";\n                    let cls = inheritedClass;\n                    let style = type.prop(this.prop);\n                    if (style != null) {\n                        let val = this.styling.match(style);\n                        if (val) {\n                            if (cls)\n                                cls += \" \";\n                            cls += val;\n                        }\n                        if (style & Inherit)\n                            inheritedClass = cls;\n                    }\n                    context.push(cls);\n                    if (inheritedClass)\n                        inherited.push(inheritedClass);\n                    if (cls != curClass) {\n                        flush(start, curClass);\n                        curClass = cls;\n                    }\n                },\n                leave: (_t, _s, end) => {\n                    context.pop();\n                    inherited.pop();\n                    let backTo = context.length ? context[context.length - 1] : \"\";\n                    if (backTo != curClass) {\n                        flush(Math.min(to, end), curClass);\n                        curClass = backTo;\n                    }\n                }\n            });\n        }\n        return builder.finish();\n    }\n}\n/// A default highlighter (works well with light themes).\nconst defaultHighlighter = highlighter({\n    invalid: { color: \"#f00\" },\n    keyword: { color: \"#708\" },\n    atom: { color: \"#219\" },\n    number: { color: \"#164\" },\n    string: { color: \"#a11\" },\n    character: { color: \"#a11\" },\n    regexp: { color: \"#e40\" },\n    escape: { color: \"#e40\" },\n    \"variableName definition\": { color: \"#00f\" },\n    typeName: { color: \"#085\" },\n    \"propertyName definition\": { color: \"#00c\" },\n    comment: { color: \"#940\" },\n    meta: { color: \"#555\" }\n});\n\nexport { TagSystem, defaultHighlighter, defaultTags, highlighter, styleTags };\n","import { EditorView, ViewPlugin, themeClass, BlockType, PluginField } from '../../view';\nimport { RangeValue, Range, RangeSet } from '../../rangeset';\nimport { MapMode, Facet, fillConfig, Annotation, combineConfig } from '../../state';\n\n/// A gutter marker represents a bit of information attached to a line\n/// in a specific gutter. Your own custom markers have to extend this\n/// class.\nclass GutterMarker extends RangeValue {\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /// Render the DOM node for this marker, if any.\n    toDOM(_view) { return null; }\n    /// Create a range that places this marker at the given position.\n    at(pos) { return new Range(pos, pos, this); }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.startMapMode = GutterMarker.prototype.endMapMode = MapMode.TrackBefore;\nconst defaults = {\n    style: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    initialMarkers: () => RangeSet.empty,\n    updateMarkers: (markers) => markers,\n    lineMarker: () => null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = Facet.define();\n/// Define an editor gutter.\nfunction gutter(config) {\n    return [gutters(), activeGutters.of(fillConfig(config, defaults))];\n}\nconst baseTheme = EditorView.baseTheme({\n    gutters: {\n        background: \"#f5f5f5\",\n        borderRight: \"1px solid silver\",\n        color: \"#999\",\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        left: 0\n    },\n    gutter: {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        overflow: \"hidden\"\n    },\n    gutterElement: {\n        boxSizing: \"border-box\"\n    },\n    \"gutterElement.lineNumber\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    }\n});\nconst unfixGutters = Facet.define({\n    combine: values => values.some(x => x)\n});\n/// The gutter-drawing plugin is automatically enabled when you add a\n/// gutter, but you can use this function to explicitly configure it.\n///\n/// Unless `fixed` is explicitly set to `false`, the gutters are\n/// fixed, meaning they don't scroll along with the content\n/// horizontally.\nfunction gutters(config) {\n    let result = [\n        gutterView,\n        baseTheme\n    ];\n    if (config && config.fixed === false)\n        result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutters\");\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)\n            this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (!this.updateGutters(update))\n            return;\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));\n        this.view.viewportLines(line => {\n            let text;\n            if (Array.isArray(line.type))\n                text = line.type.find(b => b.type == BlockType.Text);\n            else\n                text = line.type == BlockType.Text ? line : undefined;\n            if (!text)\n                return;\n            for (let cx of contexts)\n                cx.line(this.view, text);\n        }, 0);\n        for (let cx of contexts)\n            cx.finish();\n        this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (update.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n    }\n    updateGutters(update) {\n        let prev = update.prevState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged;\n        if (prev == cur) {\n            for (let gutter of this.gutters)\n                if (gutter.update(update))\n                    change = true;\n        }\n        else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur) {\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                }\n                else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters)\n                g.dom.remove();\n            for (let g of gutters)\n                this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n}).provide(PluginField.scrollMargins, value => {\n    if (value.gutters.length == 0 || !value.fixed)\n        return null;\n    return value.view.textDirection == \"ltr\" ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };\n});\nclass UpdateContext {\n    constructor(gutter, viewport) {\n        this.gutter = gutter;\n        this.localMarkers = [];\n        this.i = 0;\n        this.height = 0;\n        this.cursor = gutter.markers.iter(viewport.from);\n    }\n    line(view, line) {\n        if (this.localMarkers.length)\n            this.localMarkers = [];\n        while (this.cursor.value && this.cursor.from <= line.from) {\n            if (this.cursor.from == line.from)\n                this.localMarkers.push(this.cursor.value);\n            this.cursor.next();\n        }\n        let forLine = this.gutter.config.lineMarker(view, line, this.localMarkers);\n        if (forLine)\n            this.localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (this.localMarkers.length == 0 && !gutter.config.renderEmptyElements)\n            return;\n        let above = line.top - this.height;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, line.height, above, this.localMarkers, gutter.elementClass);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        }\n        else {\n            let markers = this.localMarkers, elt = gutter.elements[this.i];\n            if (sameMarkers(markers, elt.markers)) {\n                markers = elt.markers;\n                this.localMarkers.length = 0;\n            }\n            elt.update(view, line.height, above, markers, gutter.elementClass);\n        }\n        this.height = line.bottom;\n        this.i++;\n    }\n    finish() {\n        let gutter = this.gutter;\n        while (gutter.elements.length > this.i)\n            gutter.dom.removeChild(gutter.elements.pop().dom);\n    }\n}\nclass SingleGutterView {\n    constructor(view, config) {\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutter\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        this.elementClass = themeClass(\"gutterElement\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        for (let prop in config.domEventHandlers) {\n            this.dom.addEventListener(prop, (event) => {\n                let line = view.lineAtHeight(event.clientY);\n                if (config.domEventHandlers[prop](view, line, event))\n                    event.preventDefault();\n            });\n        }\n        this.markers = config.initialMarkers(view);\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)], this.elementClass);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = this.config.updateMarkers(this.markers.map(update.changes), update);\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0])\n                this.spacer.update(update.view, 0, 0, [updated], this.elementClass);\n        }\n        return this.markers == prevMarkers;\n    }\n    destroy() {\n        this.dom.remove();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers, eltClass) {\n        this.height = -1;\n        this.above = 0;\n        this.dom = document.createElement(\"div\");\n        this.update(view, height, above, markers, eltClass);\n    }\n    update(view, height, above, markers, cssClass) {\n        if (this.height != height)\n            this.dom.style.height = (this.height = height) + \"px\";\n        if (this.above != above)\n            this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (this.markers != markers) {\n            this.markers = markers;\n            for (let ch; ch = this.dom.lastChild;)\n                ch.remove();\n            let cls = cssClass;\n            for (let m of markers) {\n                let dom = m.toDOM(view);\n                if (dom)\n                    this.dom.appendChild(dom);\n                let c = m.elementClass;\n                if (c)\n                    cls += \" \" + c;\n            }\n            this.dom.className = cls;\n        }\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].compare(b[i]))\n            return false;\n    return true;\n}\n/// Used to insert markers into the line number gutter.\nconst lineNumberMarkers = Annotation.define();\nconst lineNumberConfig = Facet.define({\n    combine(values) {\n        return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {\n            domEventHandlers(a, b) {\n                let result = {};\n                for (let event in a)\n                    result[event] = a[event];\n                for (let event in b) {\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n    eq(other) { return this.number == other.number; }\n    toDOM(view) {\n        let config = view.state.facet(lineNumberConfig);\n        return document.createTextNode(config.formatNumber(this.number));\n    }\n}\nconst lineNumberGutter = gutter({\n    style: \"lineNumber\",\n    updateMarkers(markers, update) {\n        for (let tr of update.transactions) {\n            let ann = tr.annotation(lineNumberMarkers);\n            if (ann)\n                markers = markers.update(ann);\n        }\n        return markers;\n    },\n    lineMarker(view, line, others) {\n        if (others.length)\n            return null;\n        // FIXME try to make the line number queries cheaper?\n        return new NumberMarker(view.state.doc.lineAt(line.from).number);\n    },\n    initialSpacer(view) {\n        return new NumberMarker(maxLineNumber(view.state.doc.lines));\n    },\n    updateSpacer(spacer, update) {\n        let max = maxLineNumber(update.view.state.doc.lines);\n        return max == spacer.number ? spacer : new NumberMarker(max);\n    }\n});\n/// Create a line number gutter extension. The order in which the\n/// gutters appear is determined by their extension priority.\nfunction lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while (last < lines)\n        last = last * 10 + 9;\n    return last;\n}\n\nexport { GutterMarker, gutter, gutters, lineNumberMarkers, lineNumbers };\n","var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n};\nvar base_1 = base;\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \";\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n};\nvar shift_1 = shift;\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor);\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent);\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\n\nvar keyName = function(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1;\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\";\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\";\n  if (name == \"Del\") name = \"Delete\";\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\";\n  if (name == \"Up\") name = \"ArrowUp\";\n  if (name == \"Right\") name = \"ArrowRight\";\n  if (name == \"Down\") name = \"ArrowDown\";\n  return name\n};\n\nvar w3cKeyname = {\n\tbase: base_1,\n\tshift: shift_1,\n\tkeyName: keyName\n};\n\nexport default w3cKeyname;\nexport { base_1 as base, keyName, shift_1 as shift };\n","import { keyName, base } from 'w3c-keyname';\nimport { EditorView } from '../../view';\n\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; ++i) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/// Create a view extension that registers a keymap.\n///\n/// You can add multiple keymap behaviors to an editor. Their\n/// priorities determine their precedence (the ones specified early or\n/// with high priority get to dispatch first). When a handler has\n/// returned `true` for a given key, no further handlers are called.\nconst keymap = (map) => {\n    let set = new NormalizedKeymap(map);\n    return EditorView.domEventHandlers.of({\n        keydown(view, event) {\n            let handler = set.get(event);\n            return handler ? handler(view) : false;\n        }\n    });\n};\n/// Stores a set of keybindings in normalized form, and helps looking\n/// up the binding for a keyboard event. Only needed when binding keys\n/// in some custom way.\nclass NormalizedKeymap {\n    /// Create a normalized map.\n    constructor(map) {\n        this.map = Object.create(null);\n        for (const prop in map)\n            this.map[normalizeKeyName(prop)] = map[prop];\n    }\n    /// Look up the binding for the given keyboard event, or `undefined`\n    /// if none is found.\n    get(event) {\n        const name = keyName(event), isChar = name.length == 1 && name != \" \";\n        const direct = this.map[modifiers(name, event, !isChar)];\n        if (direct)\n            return direct;\n        let baseName;\n        if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&\n            (baseName = base[event.keyCode]) && baseName != name) {\n            const fromCode = this.map[modifiers(baseName, event, true)];\n            if (fromCode)\n                return fromCode;\n        }\n        return undefined;\n    }\n}\n\nexport { NormalizedKeymap, keymap };\n","import { EditorSelection, SelectionRange, Transaction, EditorState } from '../../state';\n\nfunction moveSelection(view, dir, granularity) {\n    let transaction = view.state.t().forEachRange(range => {\n        if (!range.empty && granularity != \"lineboundary\")\n            return new SelectionRange(dir == \"left\" || dir == \"backward\" ? range.from : range.to);\n        return new SelectionRange(view.movePos(range.head, dir, granularity, \"move\"));\n    });\n    if (transaction.selection.eq(view.state.selection))\n        return false;\n    if (granularity == \"line\")\n        transaction.annotate(Transaction.preserveGoalColumn, true);\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Move the selection one character to the left (which is backward in\n/// left-to-right text, forward in right-to-left text).\nconst moveCharLeft = view => moveSelection(view, \"left\", \"character\");\n/// Move the selection one character to the right.\nconst moveCharRight = view => moveSelection(view, \"right\", \"character\");\n/// Move the selection one word to the left.\nconst moveWordLeft = view => moveSelection(view, \"left\", \"word\");\n/// Move the selection one word to the right.\nconst moveWordRight = view => moveSelection(view, \"right\", \"word\");\n/// Move the selection one line up.\nconst moveLineUp = view => moveSelection(view, \"backward\", \"line\");\n/// Move the selection one line down.\nconst moveLineDown = view => moveSelection(view, \"forward\", \"line\");\n/// Move the selection to the start of the line.\nconst moveLineStart = view => moveSelection(view, \"backward\", \"lineboundary\");\n/// Move the selection to the end of the line.\nconst moveLineEnd = view => moveSelection(view, \"forward\", \"lineboundary\");\nfunction extendSelection(view, dir, granularity) {\n    let transaction = view.state.t().forEachRange(range => {\n        return new SelectionRange(range.anchor, view.movePos(range.head, dir, granularity, \"extend\"));\n    });\n    if (transaction.selection.eq(view.state.selection))\n        return false;\n    if (granularity == \"line\")\n        transaction.annotate(Transaction.preserveGoalColumn, true);\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Move the selection head one character to the left, while leaving\n/// the anchor in place.\nconst extendCharLeft = view => extendSelection(view, \"left\", \"character\");\n/// Move the selection head one character to the right.\nconst extendCharRight = view => extendSelection(view, \"right\", \"character\");\n/// Move the selection head one word to the left.\nconst extendWordLeft = view => extendSelection(view, \"left\", \"word\");\n/// Move the selection head one word to the right.\nconst extendWordRight = view => extendSelection(view, \"right\", \"word\");\n/// Move the selection head one line up.\nconst extendLineUp = view => extendSelection(view, \"backward\", \"line\");\n/// Move the selection head one line down.\nconst extendLineDown = view => extendSelection(view, \"forward\", \"line\");\n/// Move the selection head to the start of the line.\nconst extendLineStart = view => extendSelection(view, \"backward\", \"lineboundary\");\n/// Move the selection head to the end of the line.\nconst extendLineEnd = view => extendSelection(view, \"forward\", \"lineboundary\");\n/// Move the selection to the start of the document.\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(EditorSelection.single(0)).scrollIntoView());\n    return true;\n};\n/// Move the selection to the end of the document.\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(EditorSelection.single(state.doc.length)).scrollIntoView());\n    return true;\n};\n/// Select the entire document.\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(EditorSelection.single(0, state.doc.length)));\n    return true;\n};\nfunction deleteText(view, dir) {\n    let transaction = view.state.t().forEachRange((range, transaction) => {\n        let { from, to } = range;\n        if (from == to) {\n            let target = view.movePos(range.head, dir, \"character\", \"move\");\n            from = Math.min(from, target);\n            to = Math.max(to, target);\n        }\n        if (from == to)\n            return range;\n        transaction.replace(from, to, \"\");\n        return new SelectionRange(from);\n    });\n    if (!transaction.docChanged)\n        return false;\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Delete the character before the cursor (which is the one to left\n/// in left-to-right text, but the one to the right in right-to-left\n/// text).\nconst deleteCharBackward = view => deleteText(view, \"backward\");\n/// Delete the character after the cursor.\nconst deleteCharForward = view => deleteText(view, \"forward\");\n// FIXME support indenting by tab, configurable indent units\nfunction space(n) {\n    let result = \"\";\n    for (let i = 0; i < n; i++)\n        result += \" \";\n    return result;\n}\nfunction getIndentation(state, pos) {\n    for (let f of state.facet(EditorState.indentation)) {\n        let result = f(state, pos);\n        if (result > -1)\n            return result;\n    }\n    return -1;\n}\n/// Replace the selection with a newline and indent the newly created\n/// line(s).\nconst insertNewlineAndIndent = ({ state, dispatch }) => {\n    let i = 0, indentation = state.selection.ranges.map(r => {\n        let indent = getIndentation(state, r.from);\n        return indent > -1 ? indent : /^\\s*/.exec(state.doc.lineAt(r.from).slice(0, 50))[0].length;\n    });\n    dispatch(state.t().forEachRange(({ from, to }, tr) => {\n        let indent = indentation[i++], line = tr.doc.lineAt(to);\n        while (to < line.end && /s/.test(line.slice(to - line.start, to + 1 - line.start)))\n            to++;\n        tr.replace(from, to, [\"\", space(indent)]);\n        return new SelectionRange(from + indent + 1);\n    }).scrollIntoView());\n    return true;\n};\n/// Auto-indent the selected lines. This uses the [indentation\n/// behavor](#state.EditorState^indentation) as source.\nconst indentSelection = ({ state, dispatch }) => {\n    // FIXME this will base all indentation on the same state, which is\n    // wrong (indentation looks at the indent of previous lines, which may\n    // be changed).\n    let lastLine = -1, positions = [];\n    for (let range of state.selection.ranges) {\n        for (let { start, end } = state.doc.lineAt(range.from);;) {\n            if (start != lastLine) {\n                lastLine = start;\n                let indent = getIndentation(state, start), current;\n                if (indent > -1 &&\n                    indent != (current = /^\\s*/.exec(state.doc.slice(start, Math.min(end, start + 100)))[0].length))\n                    positions.push({ pos: start, current, indent });\n            }\n            if (end + 1 > range.to)\n                break;\n            ({ start, end } = state.doc.lineAt(end + 1));\n        }\n    }\n    if (positions.length > 0) {\n        let tr = state.t();\n        for (let { pos, current, indent } of positions) {\n            let start = tr.changes.mapPos(pos);\n            tr.replace(start, start + current, space(indent));\n        }\n        dispatch(tr);\n    }\n    return true;\n};\n/// The default keymap for Linux/Windows/non-Mac platforms. Binds the\n/// arrows for cursor motion, shift-arrow for selection extension,\n/// ctrl-arrows for by-word motion, home/end for line start/end,\n/// ctrl-home/end for document start/end, ctrl-a to select all,\n/// backspace/delete for deletion, and enter for newline-and-indent.\nconst pcBaseKeymap = {\n    \"ArrowLeft\": moveCharLeft,\n    \"ArrowRight\": moveCharRight,\n    \"Shift-ArrowLeft\": extendCharLeft,\n    \"Shift-ArrowRight\": extendCharRight,\n    \"Mod-ArrowLeft\": moveWordLeft,\n    \"Mod-ArrowRight\": moveWordRight,\n    \"Shift-Mod-ArrowLeft\": extendWordLeft,\n    \"Shift-Mod-ArrowRight\": extendWordRight,\n    \"ArrowUp\": moveLineUp,\n    \"ArrowDown\": moveLineDown,\n    \"Shift-ArrowUp\": extendLineUp,\n    \"Shift-ArrowDown\": extendLineDown,\n    \"Home\": moveLineStart,\n    \"End\": moveLineEnd,\n    \"Shift-Home\": extendLineStart,\n    \"Shift-End\": extendLineEnd,\n    \"Mod-Home\": selectDocStart,\n    \"Mod-End\": selectDocEnd,\n    \"Mod-a\": selectAll,\n    \"Backspace\": deleteCharBackward,\n    \"Delete\": deleteCharForward,\n    \"Enter\": insertNewlineAndIndent\n};\n/// The default keymap for Mac platforms. Includes the bindings from\n/// the [PC keymap](#commands.pcBaseKeymap) (using Cmd instead of\n/// Ctrl), and adds Mac-specific default bindings.\nconst macBaseKeymap = {\n    \"Control-b\": moveCharLeft,\n    \"Control-f\": moveCharRight,\n    \"Shift-Control-b\": extendCharLeft,\n    \"Shift-Control-f\": extendCharRight,\n    \"Control-p\": moveLineUp,\n    \"Control-n\": moveLineDown,\n    \"Shift-Control-p\": extendLineUp,\n    \"Shift-Control-n\": extendLineDown,\n    \"Control-a\": moveLineStart,\n    \"Control-e\": moveLineEnd,\n    \"Shift-Control-a\": extendLineStart,\n    \"Shift-Control-e\": extendLineEnd,\n    \"Cmd-ArrowUp\": selectDocStart,\n    \"Cmd-ArrowDown\": selectDocEnd,\n    \"Control-d\": deleteCharForward,\n    \"Control-h\": deleteCharBackward\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n    : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false;\n/// The default keymap for the current platform.\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\nexport { baseKeymap, deleteCharBackward, deleteCharForward, extendCharLeft, extendCharRight, extendLineDown, extendLineEnd, extendLineStart, extendLineUp, extendWordLeft, extendWordRight, indentSelection, insertNewlineAndIndent, macBaseKeymap, moveCharLeft, moveCharRight, moveLineDown, moveLineEnd, moveLineStart, moveLineUp, moveWordLeft, moveWordRight, pcBaseKeymap, selectAll, selectDocEnd, selectDocStart };\n","import { NodeProp, Tree } from 'lezer-tree';\nimport { EditorState, Annotation, StateField, languageData } from '../../state';\nimport { ViewPlugin } from '../../view';\n\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a number. That number may be -1, to indicate that no\n/// definitive indentation can be determined, or a column number to\n/// which the given line should be indented.\nconst indentNodeProp = new NodeProp();\nfunction syntaxIndentation(syntax) {\n    return EditorState.indentation.of((state, pos) => {\n        return computeIndentation(state, syntax.getTree(state), pos);\n    });\n}\n// Compute the indentation for a given position from the syntax tree.\nfunction computeIndentation(state, ast, pos) {\n    let tree = ast.resolve(pos);\n    // Enter previous nodes that end in empty error terms, which means\n    // they were broken off by error recovery, so that indentation\n    // works even if the constructs haven't been finished.\n    for (let scan = tree, scanPos = pos;;) {\n        let last = scan.childBefore(scanPos);\n        if (!last)\n            break;\n        if (last.type.prop(NodeProp.error) && last.start == last.end) {\n            tree = scan;\n            scanPos = last.start;\n        }\n        else {\n            scan = last;\n            scanPos = scan.end + 1;\n        }\n    }\n    for (; tree; tree = tree.parent) {\n        let strategy = indentStrategy(tree.type) || (tree.parent == null ? topIndent : null);\n        if (strategy)\n            return strategy(new IndentContext(state, pos, tree));\n    }\n    return -1;\n}\nfunction indentStrategy(type) {\n    let strategy = type.prop(indentNodeProp);\n    if (!strategy) {\n        let delim = type.prop(NodeProp.delim);\n        if (delim)\n            return delimitedIndent({ closing: delim.split(\" \")[1] });\n    }\n    return strategy;\n}\nfunction topIndent() { return 0; }\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nclass IndentContext {\n    /// @internal\n    constructor(\n    /// The editor state.\n    state, \n    /// The position at which indentation is being computed.\n    pos, \n    /// The syntax tree node for which the indentation strategy is\n    /// registered.\n    node) {\n        this.state = state;\n        this.pos = pos;\n        this.node = node;\n    }\n    /// The indent unit (number of spaces per indentation level).\n    get unit() { return this.state.indentUnit; }\n    /// Get the text directly after `this.pos`, either the entire line\n    /// or the next 50 characters, whichever is shorter.\n    get textAfter() {\n        return this.state.doc.slice(this.pos, Math.min(this.pos + 50, this.state.doc.lineAt(this.pos).end)).match(/^\\s*(.*)/)[1];\n    }\n    /// find the column position (taking tabs into account) of the given\n    /// position in the given string.\n    countColumn(line, pos) {\n        // FIXME use extending character information\n        if (pos < 0)\n            pos = line.length;\n        let tab = this.state.tabSize;\n        for (var i = 0, n = 0;;) {\n            let nextTab = line.indexOf(\"\\t\", i);\n            if (nextTab < 0 || nextTab >= pos)\n                return n + (pos - i);\n            n += nextTab - i;\n            n += tab - (n % tab);\n            i = nextTab + 1;\n        }\n    }\n    /// Find the indentation column of the given document line.\n    lineIndent(line) {\n        let text = line.slice(0, Math.min(50, line.length, this.node.start > line.start ? this.node.start - line.start : 1e8));\n        return this.countColumn(text, text.search(/\\S/));\n    }\n    /// Get the indentation at the reference line for `this.tree`, which\n    /// is the line on which it starts, unless there is a node that is\n    /// _not_ a parent of this node covering the start of that line. If\n    /// so, the line at the start of that node is tried, again skipping\n    /// on if it is covered by another such node.\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.start);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.start);\n            while (atBreak.parent && atBreak.parent.start == atBreak.start)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.start);\n        }\n        return this.lineIndent(line);\n    }\n    /// Find the column for the given position.\n    column(pos) {\n        let line = this.state.doc.lineAt(pos);\n        return this.countColumn(line.slice(0, pos - line.start), pos - line.start);\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.start);\n    if (!openToken)\n        return null;\n    let openLine = context.state.doc.lineAt(openToken.start);\n    for (let pos = openToken.end;;) {\n        let next = tree.childAfter(pos);\n        if (!next)\n            return null;\n        if (!next.type.prop(NodeProp.skipped))\n            return next.start < openLine.end ? openToken : null;\n        pos = next.end;\n    }\n}\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => {\n        let closed = context.textAfter.slice(0, closing.length) == closing;\n        let aligned = align ? bracketedAligned(context) : null;\n        if (aligned)\n            return closed ? context.column(aligned.start) : context.column(aligned.end);\n        return context.baseIndent + (closed ? 0 : context.unit * units);\n    };\n}\n/// An indentation strategy that aligns a node content to its base\n/// indentation.\nconst flatIndent = (context) => context.baseIndent;\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nfunction continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\n\n/// This node prop is used to associate folding information with node\n/// types. Given a subtree, it should check whether that tree is\n/// foldable and return the range that can be collapsed when it is.\nconst foldNodeProp = new NodeProp();\nfunction syntaxFolding(syntax) {\n    return EditorState.foldable.of((state, start, end) => {\n        let inner = syntax.getTree(state).resolve(end);\n        let found = null;\n        for (let cur = inner; cur; cur = cur.parent) {\n            if (cur.end <= end || cur.start > end)\n                continue;\n            if (found && cur.start < start)\n                break;\n            let prop = cur.type.prop(foldNodeProp);\n            if (prop) {\n                let value = prop(cur, state);\n                if (value && value.from <= end && value.from >= start && value.to > end)\n                    found = value;\n            }\n        }\n        return found;\n    });\n}\n\n/// A [syntax provider](#state.Syntax) based on a\n/// [Lezer](https://lezer.codemirror.net) parser.\nclass LezerSyntax {\n    /// Create a syntax instance for the given parser. You'll usually\n    /// want to use the\n    /// [`withProps`](https://lezer.codemirror.net/docs/ref/#lezer.Parser.withProps)\n    /// method to register CodeMirror-specific syntax node props in the\n    /// parser, before passing it to this constructor.\n    constructor(parser) {\n        this.parser = parser;\n        let setSyntax = Annotation.define();\n        this.field = StateField.define({\n            create(state) { return SyntaxState.advance(Tree.empty, parser, state.doc); },\n            update(value, tr) { return value.apply(tr, parser, setSyntax); }\n        });\n        this.extension = [\n            EditorState.syntax.of(this),\n            this.field,\n            ViewPlugin.define(view => new HighlightWorker(view, this, setSyntax)),\n            syntaxIndentation(this),\n            syntaxFolding(this)\n        ];\n    }\n    getTree(state) {\n        return state.field(this.field).tree;\n    }\n    parsePos(state) {\n        return state.field(this.field).upto;\n    }\n    ensureTree(state, upto, timeout = 100) {\n        let field = state.field(this.field);\n        if (field.upto >= upto)\n            return field.updatedTree;\n        if (!field.parse)\n            field.startParse(this.parser, state.doc);\n        if (field.parse.pos < upto) {\n            let done = work(field.parse, timeout, upto);\n            if (done)\n                return field.stopParse(done, state.doc.length);\n        }\n        return field.parse.pos < upto ? null : field.stopParse();\n    }\n    get docNodeType() { return this.parser.group.types[1]; }\n    languageDataAt(state, pos) {\n        let type = this.parser.group.types[1];\n        if (this.parser.hasNested) {\n            let tree = this.getTree(state);\n            let target = tree.resolve(pos);\n            while (target) {\n                if (target.type.prop(NodeProp.top)) {\n                    type = target.type;\n                    break;\n                }\n                target = target.parent;\n            }\n        }\n        return (type.prop(languageData) || nothing);\n    }\n}\nconst nothing = {};\nclass DocStream {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get(pos) {\n        if (pos >= this.length)\n            return -1;\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos) {\n            if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n                this.cursor = this.doc.iter();\n                this.cursorPos = 0;\n            }\n            this.string = this.cursor.next(pos - this.cursorPos).value;\n            this.cursorPos = pos + this.string.length;\n            stringStart = this.cursorPos - this.string.length;\n        }\n        return this.string.charCodeAt(pos - stringStart);\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.slice(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n    clip(at) {\n        return new DocStream(this.doc, at);\n    }\n}\nfunction work(parse, time, upto = 5000000 /* MaxPos */) {\n    let endTime = Date.now() + time;\n    for (;;) {\n        let done = parse.advance();\n        if (done)\n            return done;\n        if (parse.pos > upto || Date.now() > endTime)\n            return null;\n    }\n}\nfunction takeTree(parse, base) {\n    let parsed = parse.forceFinish();\n    let after = base.applyChanges([{ fromA: 0, toA: parse.pos, fromB: 0, toB: parse.pos }]);\n    return parsed.append(after);\n}\nclass SyntaxState {\n    constructor(tree, upto) {\n        this.tree = tree;\n        this.upto = upto;\n        this.parse = null;\n        this.updatedTree = tree;\n    }\n    static advance(tree, parser, doc) {\n        let parse = parser.startParse(new DocStream(doc), { cache: tree });\n        let done = work(parse, 25 /* Apply */);\n        return done ? new SyntaxState(done, doc.length) : new SyntaxState(takeTree(parse, tree), parse.pos);\n    }\n    apply(tr, parser, annotation) {\n        let given = tr.annotation(annotation);\n        return given || (!tr.docChanged && this) || SyntaxState.advance((this.parse ? takeTree(this.parse, this.updatedTree) : this.updatedTree).applyChanges(tr.changes.changedRanges()), parser, tr.doc);\n    }\n    startParse(parser, doc) {\n        this.parse = parser.startParse(new DocStream(doc), { cache: this.updatedTree });\n    }\n    stopParse(tree, upto) {\n        if (!tree)\n            tree = takeTree(this.parse, this.updatedTree);\n        this.updatedTree = tree;\n        this.upto = (upto !== null && upto !== void 0 ? upto : this.parse.pos);\n        this.parse = null;\n        return tree;\n    }\n}\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback ||\n    ((callback, { timeout }) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\n// FIXME figure out some way to back off from full re-parses when the\n// document is largeyou could waste a lot of battery re-parsing a\n// multi-megabyte document every time you insert a backtick, even if\n// it happens in the background.\nclass HighlightWorker {\n    constructor(view, syntax, setSyntax) {\n        this.view = view;\n        this.syntax = syntax;\n        this.setSyntax = setSyntax;\n        this.working = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        if (update.docChanged)\n            this.scheduleWork();\n    }\n    scheduleWork() {\n        if (this.working > -1)\n            return;\n        let { state } = this.view, field = state.field(this.syntax.field);\n        if (field.upto >= state.doc.length)\n            return;\n        this.working = requestIdle(this.work, { timeout: 200 /* Pause */ });\n    }\n    work(deadline) {\n        this.working = -1;\n        let { state } = this.view, field = state.field(this.syntax.field);\n        if (field.upto >= state.doc.length)\n            return;\n        if (!field.parse)\n            field.startParse(this.syntax.parser, state.doc);\n        let done = work(field.parse, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);\n        if (done || field.parse.badness > .8)\n            this.view.dispatch(state.t().annotate(this.setSyntax, new SyntaxState(field.stopParse(done, state.doc.length), state.doc.length)));\n        else\n            this.scheduleWork();\n    }\n    destroy() {\n        if (this.working >= 0)\n            cancelIdle(this.working);\n    }\n}\n\nfunction mkMatchProp() { return new NodeProp({ deserialize(str) { return str.split(\" \"); } }); }\n/// A node prop that encodes information about which other nodes match\n/// this node as delimiters. Should hold a space-separated list of\n/// node names of the closing nodes that match this node.\nconst openNodeProp = mkMatchProp();\n/// Like `openNodeProp`, but for closing nodes. Should hold a\n/// space-separated list of opening node names that match this closing\n/// delimiter.\nconst closeNodeProp = mkMatchProp();\n\nexport { IndentContext, LezerSyntax, closeNodeProp, continuedIndent, delimitedIndent, flatIndent, foldNodeProp, indentNodeProp, openNodeProp };\n","import { Facet, combineConfig, StateField } from '../../state';\nimport { EditorView, Decoration, themeClass } from '../../view';\nimport { closeNodeProp, openNodeProp } from '../../syntax';\n\nconst baseTheme = EditorView.baseTheme({\n    matchingBracket: { color: \"#0b0\" },\n    nonmatchingBracket: { color: \"#a22\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = Decoration.mark({ class: themeClass(\"matchingBracket\") }), nonmatchingMark = Decoration.mark({ class: themeClass(\"nonmatchingBracket\") });\nconst bracketMatchingState = StateField.define({\n    create() { return Decoration.none; },\n    update(deco, tr, state) {\n        if (!tr.docChanged && !tr.selectionSet)\n            return deco;\n        let decorations = [];\n        let config = state.facet(bracketMatchingConfig);\n        for (let range of state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(state, range.head, 1, config) ||\n                        (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return Decoration.set(decorations, true);\n    }\n}).provide(EditorView.decorations);\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? closeNodeProp : openNodeProp);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = state.tree, sub = tree.resolve(pos, dir), matches;\n    if (matches = matchingNodes(sub.type, dir, brackets))\n        return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);\n    else\n        return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.start, to: token.end };\n    let depth = 0;\n    return (parent && parent.iterate({\n        from: dir < 0 ? token.start : token.end,\n        to: dir < 0 ? parent.start : parent.end,\n        enter(type, from, to) {\n            if (dir < 0 ? to > token.start : from < token.end)\n                return undefined;\n            if (depth == 0 && matching.indexOf(type.name) > -1) {\n                return { start: firstToken, end: { from, to }, matched: true };\n            }\n            else if (matchingNodes(type, dir, brackets)) {\n                depth++;\n            }\n            else if (matchingNodes(type, -dir, brackets)) {\n                depth--;\n                if (depth == 0)\n                    return { start: firstToken, end: { from, to }, matched: false };\n            }\n            return false;\n        }\n    })) || { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.doc.slice(pos - 1, pos) : state.doc.slice(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexport { bracketMatching, matchBrackets };\n","import { EditorView } from '../../view';\nimport { SelectionRange, EditorState } from '../../state';\nimport { codePointAt, minPairCodePoint, isWordChar, fromCodePoint } from '../../text';\nimport { keyName } from 'w3c-keyname';\n\nconst defaults = {\n    closeBrackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    closeBracketsBefore: \")]}'\\\":;>\"\n};\n/// Extension to enable bracket-closing behavior. When a closeable\n/// bracket is typed, its closing bracket is immediately inserted\n/// after the cursor. When closing a bracket directly in front of that\n/// closing bracket, the cursor moves over the existing bracket. When\n/// backspacing in between brackets, both are removed.\nconst closeBrackets = EditorView.domEventHandlers.of({ keydown });\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return fromCodePoint(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    let syntax = state.facet(EditorState.syntax);\n    if (syntax.length == 0)\n        return defaults;\n    return syntax[0].languageDataAt(state, pos);\n}\nfunction keydown(view, event) {\n    if (event.ctrlKey || event.metaKey)\n        return false;\n    if (event.keyCode == 8) { // Backspace\n        let tr = handleBackspace(view.state);\n        if (!tr)\n            return false;\n        view.dispatch(tr);\n        return true;\n    }\n    let key = keyName(event);\n    if (key.length > 2 || key.length == 2 && codePointAt(key, 0) < minPairCodePoint)\n        return false;\n    let tr = handleInsertion(view.state, key);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n}\n/// Function that implements the extension's backspace behavior.\n/// Exported mostly for testing purposes.\nfunction handleBackspace(state) {\n    let conf = config(state, state.selection.primary.head);\n    let tokens = conf.closeBrackets || defaults.closeBrackets;\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (!range.empty)\n            return dont = range;\n        let before = prevChar(state.doc, range.head);\n        for (let token of tokens) {\n            if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0))) {\n                tr.replace(range.head - token.length, range.head + token.length, \"\");\n                return new SelectionRange(range.head - token.length);\n            }\n        }\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\n/// Implements the extension's behavior on text insertion. Again,\n/// exported mostly for testing.\nfunction handleInsertion(state, ch) {\n    let conf = config(state, state.selection.primary.head);\n    let tokens = conf.closeBrackets || defaults.closeBrackets;\n    for (let tok of tokens) {\n        let closed = closing(codePointAt(tok, 0));\n        if (ch == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1)\n                : handleOpen(state, tok, closed, conf.closeBracketsBefore || defaults.closeBracketsBefore);\n        if (ch == closed)\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.slice(pos, pos + 2);\n    return next.length == 2 && codePointAt(next, 0) < minPairCodePoint ? next.slice(0, 1) : next;\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.slice(pos - 2, pos);\n    return prev.length == 2 && codePointAt(prev, 0) < minPairCodePoint ? prev.slice(1) : prev;\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (!range.empty) {\n            tr.replace(range.to, range.to, close);\n            tr.replace(range.from, range.from, open);\n            return new SelectionRange(range.anchor + open.length, range.head + open.length);\n        }\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) {\n            tr.replace(range.head, range.head, open + close);\n            return new SelectionRange(range.head + open.length, range.head + open.length);\n        }\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\nfunction handleClose(state, open, close) {\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (range.empty && close == nextChar(state.doc, range.head))\n            return new SelectionRange(range.head + close.length);\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple) {\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (!range.empty) {\n            tr.replace(range.to, range.to, token);\n            tr.replace(range.from, range.from, token);\n            return new SelectionRange(range.anchor + token.length, range.head + token.length);\n        }\n        let pos = range.head, next = nextChar(state.doc, pos);\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                tr.replace(pos, pos, token + token);\n                return new SelectionRange(pos + token.length);\n            }\n            else {\n                let isTriple = allowTriple && state.doc.slice(pos, pos + token.length * 3) == token + token + token;\n                return new SelectionRange(pos + token.length * (isTriple ? 3 : 1));\n            }\n        }\n        else if (allowTriple && state.doc.slice(pos - 2 * token.length, pos) == token + token &&\n            nodeStart(state, pos - 2 * token.length)) {\n            tr.replace(pos, pos, token + token + token + token);\n            return new SelectionRange(pos + token.length);\n        }\n        else if (!isWordChar(next)) {\n            let prev = state.doc.slice(pos - 1, pos);\n            if (!isWordChar(prev) && prev != token) {\n                tr.replace(pos, pos, token + token);\n                return new SelectionRange(pos + token.length);\n            }\n        }\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\nfunction nodeStart(state, pos) {\n    let tree = state.tree.resolve(pos + 1);\n    return tree.parent && tree.start == pos;\n}\n\nexport { closeBrackets, handleBackspace, handleInsertion };\n","import { ViewPlugin, Decoration, WidgetType, EditorView } from '../../view';\nimport { Facet, combineConfig } from '../../state';\nimport { countColumn } from '../../text';\nimport { StyleModule } from 'style-mod';\n\nconst Specials = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/gu;\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nconst specialCharConfig = Facet.define({\n    combine(configs) {\n        // FIXME make configurations compose properly\n        let config = combineConfig(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        let styles = document.body.style;\n        config.replaceTabs = (styles.tabSize || styles.MozTabSize) == null;\n        if (config.replaceTabs)\n            config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, \"gu\");\n        if (config.addSpecialChars)\n            config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, \"gu\");\n        return config;\n    }\n});\n/// Returns an extension that installs highlighting of special\n/// characters.\nfunction specialChars(config = {}) {\n    return [specialCharConfig.of(config), specialCharPlugin, styleExt];\n}\nconst JoinGap = 10;\nconst specialCharPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.from = 0;\n        this.to = 0;\n        this.decorations = Decoration.none;\n        this.decorationCache = Object.create(null);\n        this.updateForViewport();\n    }\n    update(update) {\n        if (update.prevState.facet(specialCharConfig) != update.state.facet(specialCharConfig)) {\n            this.decorationCache = Object.create(null);\n            this.from = this.to = 0;\n            this.decorations = Decoration.none;\n        }\n        if (update.changes.length) {\n            this.decorations = this.decorations.map(update.changes);\n            this.from = update.changes.mapPos(this.from, 1);\n            this.to = update.changes.mapPos(this.to, -1);\n            this.closeHoles(update.changes.changedRanges());\n        }\n        this.updateForViewport();\n    }\n    closeHoles(ranges) {\n        let decorations = [], vp = this.view.viewport, replaced = [];\n        let config = this.view.state.facet(specialCharConfig);\n        for (let i = 0; i < ranges.length; i++) {\n            let { fromB: from, toB: to } = ranges[i];\n            // Must redraw all tabs further on the line\n            if (config.replaceTabs)\n                to = this.view.state.doc.lineAt(to).end;\n            while (i < ranges.length - 1 && ranges[i + 1].fromB < to + JoinGap)\n                to = Math.max(to, ranges[++i].toB);\n            // Clip to current viewport, to avoid doing work for invisible text\n            from = Math.max(vp.from, from);\n            to = Math.min(vp.to, to);\n            if (from >= to)\n                continue;\n            this.getDecorationsFor(from, to, decorations);\n            replaced.push(from, to);\n        }\n        if (replaced.length)\n            this.decorations = this.decorations.update({\n                add: decorations,\n                filter: pos => {\n                    for (let i = 0; i < replaced.length; i += 2)\n                        if (pos >= replaced[i] && pos < replaced[i + 1])\n                            return false;\n                    return true;\n                },\n                filterFrom: replaced[0],\n                filterTo: replaced[replaced.length - 1]\n            });\n    }\n    updateForViewport() {\n        let vp = this.view.viewport;\n        // Viewports match, don't do anything\n        if (this.from == vp.from && this.to == vp.to)\n            return;\n        let decorations = [];\n        if (this.from >= vp.to || this.to <= vp.from) {\n            this.getDecorationsFor(vp.from, vp.to, decorations);\n            this.decorations = Decoration.set(decorations);\n        }\n        else {\n            if (vp.from < this.from)\n                this.getDecorationsFor(vp.from, this.from, decorations);\n            if (this.to < vp.to)\n                this.getDecorationsFor(this.to, vp.to, decorations);\n            this.decorations = this.decorations.update({\n                add: decorations,\n                filter: (from, to) => from >= vp.from && to <= vp.to\n            });\n        }\n        this.from = vp.from;\n        this.to = vp.to;\n    }\n    getDecorationsFor(from, to, target) {\n        let config = this.view.state.facet(specialCharConfig);\n        let { doc } = this.view.state;\n        for (let pos = from, cursor = doc.iterRange(from, to), m; !cursor.next().done;) {\n            if (!cursor.lineBreak) {\n                while (m = config.specialChars.exec(cursor.value)) {\n                    let code = m[0].codePointAt ? m[0].codePointAt(0) : m[0].charCodeAt(0), deco;\n                    if (code == null)\n                        continue;\n                    if (code == 9) {\n                        let line = doc.lineAt(pos + m.index);\n                        let size = this.view.state.tabSize, col = countColumn(doc.slice(line.start, pos + m.index), 0, size);\n                        deco = Decoration.replace({ widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth) });\n                    }\n                    else {\n                        deco = this.decorationCache[code] ||\n                            (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(config, code) }));\n                    }\n                    target.push(deco.range(pos + m.index, pos + m.index + m[0].length));\n                }\n            }\n            pos += cursor.value.length;\n        }\n    }\n}).decorations();\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeHolder(code) {\n    if (code >= 32)\n        return null;\n    if (code == 10)\n        return \"\\u2424\";\n    return String.fromCharCode(9216 + code);\n}\nconst DefaultPlaceholder = \"\\u2022\";\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code) {\n        super(code);\n        this.options = options;\n    }\n    toDOM() {\n        let ph = placeHolder(this.value) || DefaultPlaceholder;\n        let desc = \"Control character \" + (Names[this.value] || this.value);\n        let custom = this.options.render && this.options.render(this.value, desc, ph);\n        if (custom)\n            return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.style.color = \"red\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nclass TabWidget extends WidgetType {\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\\t\";\n        span.className = style.tab;\n        span.style.width = this.value + \"px\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nconst style = new StyleModule({\n    tab: {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    }\n});\nconst styleExt = EditorView.styleModule.of(style);\n\nexport { specialChars };\n","import { Annotation, StateField, EditorState, Facet, combineConfig, fillConfig } from '../../state';\nimport { Decoration, EditorView, WidgetType, themeClass } from '../../view';\nimport { gutter, GutterMarker } from '../../gutter';\n\nconst foldAnnotation = Annotation.define();\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges) {\n        if (lines.some(l => l.from <= head && l.to >= head))\n            continue;\n        lines.push(view.lineAt(head));\n    }\n    return lines;\n}\nconst foldState = StateField.define({\n    create() {\n        return Decoration.none;\n    },\n    update(folded, tr) {\n        folded = folded.map(tr.changes);\n        let ann = tr.annotation(foldAnnotation);\n        if (ann) {\n            let { fold = [], unfold = [] } = ann;\n            if (unfold.length || fold.length)\n                folded = folded.update({\n                    add: fold.map(({ from, to }) => FoldWidget.decoration.range(from, to)),\n                    filter: (from, to) => !unfold.some(r => r.from == from && r.to == to),\n                    filterFrom: unfold.reduce((m, r) => Math.min(m, r.from), 1e8),\n                    filterTo: unfold.reduce((m, r) => Math.max(m, r.to), 0)\n                });\n        }\n        return folded;\n    }\n}).provide(EditorView.decorations);\nfunction foldInside(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n        if (!found || found.from > from)\n            found = ({ from, to });\n    });\n    return found;\n}\nconst foldCode = view => {\n    if (!view.state.field(foldState, false))\n        return false;\n    let fold = [];\n    for (let line of selectedLines(view)) {\n        let range = view.state.facet(EditorState.foldable)\n            .reduce((value, f) => value || f(view.state, line.from, line.to), null);\n        if (range)\n            fold.push(range);\n    }\n    if (!fold.length)\n        return false;\n    view.dispatch(view.state.t().annotate(foldAnnotation, { fold }));\n    return true;\n};\nconst unfoldCode = view => {\n    if (!view.state.field(foldState, false))\n        return false;\n    let unfold = [];\n    for (let line of selectedLines(view)) {\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded)\n            unfold.push(folded);\n    }\n    if (!unfold.length)\n        return false;\n    view.dispatch(view.state.t().annotate(foldAnnotation, { unfold }));\n    return true;\n};\nconst defaultConfig = {\n    placeholderDOM: null,\n    placeholderText: \"\"\n};\nconst foldConfig = Facet.define({\n    combine(values) { return combineConfig(values, defaultConfig); }\n});\nfunction codeFolding(config = {}) {\n    return [\n        foldConfig.of(config),\n        foldState,\n        baseTheme\n    ];\n}\nclass FoldWidget extends WidgetType {\n    ignoreEvents() { return false; }\n    toDOM(view) {\n        let conf = view.state.facet(foldConfig);\n        if (conf.placeholderDOM)\n            return conf.placeholderDOM();\n        let element = document.createElement(\"span\");\n        element.textContent = conf.placeholderText;\n        // FIXME should this have a role? does it make sense to allow focusing by keyboard?\n        element.setAttribute(\"aria-label\", view.phrase(\"folded code\"));\n        element.title = view.phrase(\"unfold\");\n        element.className = themeClass(\"foldPlaceholder\");\n        element.onclick = event => {\n            let line = view.lineAt(view.posAtDOM(event.target));\n            let folded = foldInside(view.state, line.from, line.to);\n            if (folded)\n                view.dispatch(view.state.t().annotate(foldAnnotation, { unfold: [folded] }));\n            event.preventDefault();\n        };\n        return element;\n    }\n}\nFoldWidget.decoration = Decoration.replace({ widget: new FoldWidget(null) });\nconst foldGutterDefaults = {\n    openText: \"\",\n    closedText: \"\"\n};\nclass FoldMarker extends GutterMarker {\n    constructor(config, open) {\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) { return this.config == other.config && this.open == other.open; }\n    toDOM(view) {\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\nfunction foldGutter(config = {}) {\n    let fullConfig = fillConfig(config, foldGutterDefaults);\n    return [\n        gutter({\n            style: \"foldGutter\",\n            lineMarker(view, line) {\n                // FIXME optimize this. At least don't run it for updates that\n                // don't change anything relevant\n                let folded = foldInside(view.state, line.from, line.to);\n                if (folded)\n                    return new FoldMarker(fullConfig, false);\n                if (view.state.facet(EditorState.foldable).some(f => f(view.state, line.from, line.to)))\n                    return new FoldMarker(fullConfig, true);\n                return null;\n            },\n            initialSpacer() {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: {\n                click: (view, line) => {\n                    let folded = foldInside(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch(view.state.t().annotate(foldAnnotation, { unfold: [folded] }));\n                        return true;\n                    }\n                    let range = view.state.facet(EditorState.foldable)\n                        .reduce((value, f) => value || f(view.state, line.from, line.to), null);\n                    if (range) {\n                        view.dispatch(view.state.t().annotate(foldAnnotation, { fold: [range] }));\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme = EditorView.baseTheme({\n    foldPlaceholder: {\n        background: \"#eee\",\n        border: \"1px solid silver\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \"gutterElement.foldGutter\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n\nexport { codeFolding, foldCode, foldGutter, unfoldCode };\n","/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024;\nclass Iteration {\n    constructor(enter, leave) {\n        this.enter = enter;\n        this.leave = leave;\n        this.result = undefined;\n    }\n    get done() { return this.result !== undefined; }\n    doEnter(type, start, end) {\n        let value = this.enter(type, start, end);\n        if (value === undefined)\n            return true;\n        if (value !== false)\n            this.result = value;\n        return false;\n    }\n}\nlet nextPropID = 0;\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp {\n    /// Create a new node prop type. You can optionally pass a\n    /// `deserialize` function.\n    constructor({ deserialize } = {}) {\n        this.id = nextPropID++;\n        this.deserialize = deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// Create a string-valued node prop whose deserialize function is\n    /// the identity function.\n    static string() { return new NodeProp({ deserialize: str => str }); }\n    /// Create a number-valued node prop whose deserialize function is\n    /// just `Number`.\n    static number() { return new NodeProp({ deserialize: Number }); }\n    /// Creates a boolean-valued node prop whose deserialize function\n    /// returns true for any input.\n    static flag() { return new NodeProp({ deserialize: () => true }); }\n    /// Store a value for this prop in the given object. This can be\n    /// useful when building up a prop object to pass to the\n    /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n    /// argument.\n    set(propObj, value) {\n        propObj[this.id] = value;\n        return propObj;\n    }\n    /// This is meant to be used with\n    /// [`NodeGroup.extend`](#tree.NodeGroup.extend) or\n    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n    /// values for each node type in the group. Takes a [match\n    /// object](#tree.NodeType.match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        return new NodePropSource(this, typeof match == \"function\" ? match : NodeType.match(match));\n    }\n}\n/// The special node type that the parser uses to represent parse\n/// errors has this flag set. (You shouldn't use it for custom nodes\n/// that represent erroneous content.)\nNodeProp.error = NodeProp.flag();\n/// Nodes that were produced by skipped expressions (such as\n/// comments) have this prop set to true.\nNodeProp.skipped = NodeProp.flag();\n/// Prop that is used to describe a rule's delimiters. For example,\n/// a parenthesized expression node would set this to the string `\"(\n/// )\"` (the open and close strings separated by a space). This is\n/// added by the parser generator's `@detectDelim` feature, but you\n/// can also manually add them.\nNodeProp.delim = NodeProp.string();\n/// Indicates that this node indicates a top level document.\nNodeProp.top = NodeProp.flag();\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node group.\nexport class NodePropSource {\n    /// @internal\n    constructor(\n    /// @internal\n    prop, \n    /// @internal\n    f) {\n        this.prop = prop;\n        this.f = f;\n    }\n}\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node group should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its group. Corresponds to the term ids\n    /// used in the parser.\n    id) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node names. Often\n    /// useful with [`NodeProp.add`](#tree.NodeProp.add). You can put\n    /// multiple node names, separated by spaces, in a single property\n    /// name to map multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => direct[node.name];\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0);\n/// A node group holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.group) a node group, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same group. A group can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeGroup {\n    /// Create a group with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this group, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node group\");\n    }\n    /// Create a copy of this group with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#tree.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let value = source.f(type);\n                if (value !== undefined) {\n                    if (!newProps) {\n                        newProps = Object.create(null);\n                        for (let prop in type.props)\n                            newProps[prop] = type.props[prop];\n                    }\n                    newProps[source.prop.id] = value;\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id) : type);\n        }\n        return new NodeGroup(newTypes);\n    }\n}\n/// A subtree is a representation of part of the syntax tree. It may\n/// either be the tree root, or a tagged node.\nexport class Subtree {\n    // Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    /// The depth (number of parent nodes) of this subtree\n    get depth() {\n        let d = 0;\n        for (let p = this.parent; p; p = p.parent)\n            d++;\n        return d;\n    }\n    /// The root of the tree that this subtree is part of\n    get root() {\n        let cx = this;\n        while (cx.parent)\n            cx = cx.parent;\n        return cx;\n    }\n    /// Find the node at a given position. By default, this will return\n    /// the lowest-depth subtree that covers the position from both\n    /// sides, meaning that nodes starting or ending at the position\n    /// aren't entered. You can pass a `side` of `-1` to enter nodes\n    /// that end at the position, or `1` to enter nodes that start\n    /// there.\n    resolve(pos, side = 0) {\n        let result = this.resolveAt(pos);\n        // FIXME this is slightly inefficient in that it scans the result\n        // of resolveAt twice (but further complicating child-finding\n        // logic seems unattractive as well)\n        if (side != 0)\n            for (;;) {\n                let child = (side < 0 ? result.childBefore(pos) : result.childAfter(pos));\n                if (!child || (side < 0 ? child.end : child.start) != pos)\n                    break;\n                result = child;\n            }\n        return result;\n    }\n    /// Get the first child of this subtree.\n    get firstChild() { return this.childAfter(this.start - 1); }\n    /// Find the last child of this subtree.\n    get lastChild() { return this.childBefore(this.end + 1); }\n}\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `Subtree` interface instead, which provides a view on some\n/// part of this data structure, and can be used (through `resolve`,\n/// for example) to zoom in on any single node.\nexport class Tree extends Subtree {\n    /// @internal\n    constructor(\n    /// @internal\n    type, \n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer` will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree @internal\n    length) {\n        super();\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n    }\n    /// @internal\n    get start() { return 0; }\n    /// @internal\n    get end() { return this.length; }\n    /// @internal\n    toString() {\n        let children = this.children.map(c => c.toString()).join();\n        return !this.name ? children :\n            (/\\W/.test(this.name) && !this.type.prop(NodeProp.error) ? JSON.stringify(this.name) : this.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    partial(start, end, offset, children, positions) {\n        for (let i = 0; i < this.children.length; i++) {\n            let from = this.positions[i];\n            if (from > end)\n                break;\n            let child = this.children[i], to = from + child.length;\n            if (to < start)\n                continue;\n            if (start <= from && end >= to) {\n                children.push(child);\n                positions.push(from + offset);\n            }\n            else if (child instanceof Tree) {\n                child.partial(start - from, end - from, offset + from, children, positions);\n            }\n        }\n    }\n    /// Apply a set of edits to a tree, removing all nodes that were\n    /// touched by the edits, and moving remaining nodes so that their\n    /// positions are updated for insertions/deletions before them. This\n    /// is likely to destroy a lot of the structure of the tree, and\n    /// mostly useful for extracting the nodes that can be reused in a\n    /// subsequent incremental re-parse.\n    applyChanges(changes) {\n        if (changes.length == 0)\n            return this;\n        let children = [], positions = [];\n        function cutAt(tree, pos, side) {\n            let found = -1;\n            tree.iterate({\n                from: pos,\n                to: side < 0 ? 0 : tree.length,\n                enter() { return found < 0 ? undefined : false; },\n                leave(type, start, end) {\n                    if (found < 0 && (side < 0 ? end <= pos : start >= pos) && !type.prop(NodeProp.error))\n                        found = side < 0 ? Math.min(pos, end - 1) : Math.max(pos, start + 1);\n                }\n            });\n            return found > -1 ? found : side < 0 ? 0 : tree.length;\n        }\n        let off = 0;\n        for (let i = 0, pos = 0;; i++) {\n            let next = i == changes.length ? null : changes[i];\n            let nextPos = next ? cutAt(this, next.fromA, -1) : this.length;\n            if (nextPos > pos)\n                this.partial(pos, nextPos, off, children, positions);\n            if (!next)\n                break;\n            pos = cutAt(this, next.toA, 1);\n            off += (next.toB - next.fromB) - (next.toA - next.fromA);\n        }\n        return new Tree(NodeType.none, children, positions, this.length + off);\n    }\n    /// Take the part of the tree up to the given position.\n    cut(at) {\n        if (at >= this.length)\n            return this;\n        let children = [], positions = [];\n        for (let i = 0; i < this.children.length; i++) {\n            let from = this.positions[i];\n            if (from >= at)\n                break;\n            let child = this.children[i], to = from + child.length;\n            children.push(to <= at ? child : child.cut(at - from));\n            positions.push(from);\n        }\n        return new Tree(this.type, children, positions, at);\n    }\n    /// @internal\n    iterate({ from = this.start, to = this.end, enter, leave }) {\n        let iter = new Iteration(enter, leave);\n        this.iterInner(from, to, 0, iter);\n        return iter.result;\n    }\n    /// @internal\n    iterInner(from, to, offset, iter) {\n        if (this.type.name && !iter.doEnter(this.type, offset, offset + this.length))\n            return;\n        if (from <= to) {\n            for (let i = 0; i < this.children.length && !iter.done; i++) {\n                let child = this.children[i], start = this.positions[i] + offset, end = start + child.length;\n                if (start > to)\n                    break;\n                if (end < from)\n                    continue;\n                child.iterInner(from, to, start, iter);\n            }\n        }\n        else {\n            for (let i = this.children.length - 1; i >= 0 && !iter.done; i--) {\n                let child = this.children[i], start = this.positions[i] + offset, end = start + child.length;\n                if (end < to)\n                    break;\n                if (start > from)\n                    continue;\n                child.iterInner(from, to, start, iter);\n            }\n        }\n        if (iter.leave && this.type.name)\n            iter.leave(this.type, offset, offset + this.length);\n        return;\n    }\n    /// @internal\n    resolveAt(pos) {\n        if (cacheRoot == this) {\n            for (let tree = cached;;) {\n                let next = tree.parent;\n                if (!next)\n                    break;\n                if (tree.start < pos && tree.end > pos)\n                    return tree.resolve(pos);\n                tree = next;\n            }\n        }\n        cacheRoot = this;\n        return cached = this.resolveInner(pos, 0, this);\n    }\n    /// @internal\n    childBefore(pos) {\n        return this.findChild(pos, -1, 0, this);\n    }\n    /// @internal\n    childAfter(pos) {\n        return this.findChild(pos, 1, 0, this);\n    }\n    /// @internal\n    findChild(pos, side, start, parent) {\n        for (let i = 0; i < this.children.length; i++) {\n            let childStart = this.positions[i] + start, select = -1;\n            if (childStart >= pos) {\n                if (side < 0 && i > 0)\n                    select = i - 1;\n                else if (side > 0)\n                    select = i;\n                else\n                    break;\n            }\n            if (select < 0 && (childStart + this.children[i].length > pos || side < 0 && i == this.children.length - 1))\n                select = i;\n            if (select >= 0) {\n                let child = this.children[select], childStart = this.positions[select] + start;\n                if (child.length == 0 && childStart == pos)\n                    continue;\n                if (child instanceof Tree) {\n                    if (child.type.name)\n                        return new NodeSubtree(child, childStart, parent);\n                    return child.findChild(pos, side, childStart, parent);\n                }\n                else {\n                    let found = child.findIndex(pos, side, childStart, 0, child.buffer.length);\n                    if (found > -1)\n                        return new BufferSubtree(child, childStart, found, parent);\n                }\n            }\n        }\n        return null;\n    }\n    /// @internal\n    resolveInner(pos, start, parent) {\n        let found = this.findChild(pos, 0, start, parent);\n        return found ? found.resolveAt(pos) : parent;\n    }\n    /// Append another tree to this tree. `other` must have empty space\n    /// big enough to fit this tree at its start.\n    append(other) {\n        if (other.children.length && other.positions[0] < this.length)\n            throw new Error(\"Can't append overlapping trees\");\n        return new Tree(this.type, this.children.concat(other.children), this.positions.concat(other.positions), other.length);\n    }\n    /// Balance the direct children of this tree.\n    balance(maxBufferLength = DefaultBufferLength) {\n        return this.children.length <= BalanceBranchFactor ? this\n            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nTree.prototype.parent = null;\n// Top-level `resolveAt` calls store their last result here, so that\n// if the next call is near the last, parent trees can be cheaply\n// reused.\nlet cacheRoot = Tree.empty;\nlet cached = Tree.empty;\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n    /// Create a tree buffer @internal\n    constructor(\n    /// @internal\n    buffer, \n    // The total length of the group of nodes in the buffer.\n    length, \n    /// @internal\n    group, \n    /// An optional type tag, used to tag a buffer as being part of a\n    /// repetition @internal\n    type = NodeType.none) {\n        this.buffer = buffer;\n        this.length = length;\n        this.group = group;\n        this.type = type;\n    }\n    /// @internal\n    toString() {\n        let parts = [];\n        for (let index = 0; index < this.buffer.length;)\n            index = this.childToString(index, parts);\n        return parts.join(\",\");\n    }\n    /// @internal\n    childToString(index, parts) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.group.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.prop(NodeProp.error))\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex > index) {\n            let children = [];\n            while (index < endIndex)\n                index = this.childToString(index, children);\n            result += \"(\" + children.join(\",\") + \")\";\n        }\n        parts.push(result);\n        return index;\n    }\n    /// @internal\n    cut(at) {\n        let cutPoint = 0;\n        while (cutPoint < this.buffer.length && this.buffer[cutPoint + 1] < at)\n            cutPoint += 4;\n        let newBuffer = new Uint16Array(cutPoint);\n        for (let i = 0; i < cutPoint; i += 4) {\n            newBuffer[i] = this.buffer[i];\n            newBuffer[i + 1] = this.buffer[i + 1];\n            newBuffer[i + 2] = Math.min(at, this.buffer[i + 2]);\n            newBuffer[i + 3] = Math.min(this.buffer[i + 3], cutPoint);\n        }\n        return new TreeBuffer(newBuffer, Math.min(at, this.length), this.group);\n    }\n    iterate({ from = 0, to = this.length, enter, leave }) {\n        let iter = new Iteration(enter, leave);\n        this.iterInner(from, to, 0, iter);\n        return iter.result;\n    }\n    /// @internal\n    iterInner(from, to, offset, iter) {\n        if (from <= to) {\n            for (let index = 0; index < this.buffer.length;)\n                index = this.iterChild(from, to, offset, index, iter);\n        }\n        else {\n            this.iterRev(from, to, offset, 0, this.buffer.length, iter);\n        }\n    }\n    /// @internal\n    iterChild(from, to, offset, index, iter) {\n        let type = this.group.types[this.buffer[index++]], start = this.buffer[index++] + offset, end = this.buffer[index++] + offset, endIndex = this.buffer[index++];\n        if (start > to)\n            return this.buffer.length;\n        if (end >= from && iter.doEnter(type, start, end)) {\n            while (index < endIndex && !iter.done)\n                index = this.iterChild(from, to, offset, index, iter);\n            if (iter.leave)\n                iter.leave(type, start, end);\n        }\n        return endIndex;\n    }\n    parentNodesByEnd(startIndex, endIndex) {\n        // Build up an array of node indices reflecting the order in which\n        // non-empty nodes end, to avoid having to scan for parent nodes\n        // at every position during reverse iteration.\n        let order = [];\n        let scan = (index) => {\n            let end = this.buffer[index + 3];\n            if (end == index + 4)\n                return end;\n            for (let i = index + 4; i < end;)\n                i = scan(i);\n            order.push(index);\n            return end;\n        };\n        for (let index = startIndex; index < endIndex;)\n            index = scan(index);\n        return order;\n    }\n    /// @internal\n    iterRev(from, to, offset, startIndex, endIndex, iter) {\n        let endOrder = this.parentNodesByEnd(startIndex, endIndex);\n        // Index range for the next non-empty node\n        let nextStart = -1, nextEnd = -1;\n        let takeNext = () => {\n            if (endOrder.length > 0) {\n                nextStart = endOrder.pop();\n                nextEnd = this.buffer[nextStart + 3];\n            }\n            else {\n                nextEnd = -1;\n            }\n        };\n        takeNext();\n        run: for (let index = endIndex; index > startIndex && !iter.done;) {\n            while (nextEnd == index) {\n                let base = nextStart;\n                let id = this.buffer[base], start = this.buffer[base + 1] + offset, end = this.buffer[base + 2] + offset;\n                takeNext();\n                if (start <= from && end >= to) {\n                    if (!iter.doEnter(this.group.types[id], start, end)) {\n                        // Skip the entire node\n                        index = base;\n                        while (nextEnd > base)\n                            takeNext();\n                        continue run;\n                    }\n                }\n            }\n            let endIndex = this.buffer[--index], end = this.buffer[--index] + offset, start = this.buffer[--index] + offset, id = this.buffer[--index];\n            if (start > from || end < to)\n                continue;\n            if ((endIndex != index + 4 || iter.doEnter(this.group.types[id], start, end)) && iter.leave)\n                iter.leave(this.group.types[id], start, end);\n        }\n    }\n    /// @internal\n    findIndex(pos, side, start, from, to) {\n        let lastI = -1;\n        for (let i = from, buf = this.buffer; i < to;) {\n            let start1 = buf[i + 1] + start, end1 = buf[i + 2] + start;\n            let ignore = start1 == end1 && start1 == pos;\n            if (start1 >= pos) {\n                if (side > 0 && !ignore)\n                    return i;\n                break;\n            }\n            if (end1 > pos)\n                return i;\n            if (!ignore)\n                lastI = i;\n            i = buf[i + 3];\n        }\n        return side < 0 ? lastI : -1;\n    }\n}\nclass NodeSubtree extends Subtree {\n    constructor(node, start, parent) {\n        super();\n        this.node = node;\n        this.start = start;\n        this.parent = parent;\n    }\n    get type() { return this.node.type; }\n    get end() { return this.start + this.node.length; }\n    resolveAt(pos) {\n        if (pos <= this.start || pos >= this.end)\n            return this.parent.resolveAt(pos);\n        return this.node.resolveInner(pos, this.start, this);\n    }\n    childBefore(pos) {\n        return this.node.findChild(pos, -1, this.start, this);\n    }\n    childAfter(pos) {\n        return this.node.findChild(pos, 1, this.start, this);\n    }\n    toString() { return this.node.toString(); }\n    iterate({ from = this.start, to = this.end, enter, leave }) {\n        let iter = new Iteration(enter, leave);\n        this.node.iterInner(from, to, this.start, iter);\n        return iter.result;\n    }\n}\nclass BufferSubtree extends Subtree {\n    constructor(buffer, bufferStart, index, parent) {\n        super();\n        this.buffer = buffer;\n        this.bufferStart = bufferStart;\n        this.index = index;\n        this.parent = parent;\n    }\n    get type() { return this.buffer.group.types[this.buffer.buffer[this.index]]; }\n    get start() { return this.buffer.buffer[this.index + 1] + this.bufferStart; }\n    get end() { return this.buffer.buffer[this.index + 2] + this.bufferStart; }\n    get endIndex() { return this.buffer.buffer[this.index + 3]; }\n    childBefore(pos) {\n        let index = this.buffer.findIndex(pos, -1, this.bufferStart, this.index + 4, this.endIndex);\n        return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this);\n    }\n    childAfter(pos) {\n        let index = this.buffer.findIndex(pos, 1, this.bufferStart, this.index + 4, this.endIndex);\n        return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this);\n    }\n    iterate({ from = this.start, to = this.end, enter, leave }) {\n        let iter = new Iteration(enter, leave);\n        if (from <= to)\n            this.buffer.iterChild(from, to, this.bufferStart, this.index, iter);\n        else\n            this.buffer.iterRev(from, to, this.bufferStart, this.index, this.endIndex, iter);\n        return iter.result;\n    }\n    resolveAt(pos) {\n        if (pos <= this.start || pos >= this.end)\n            return this.parent.resolveAt(pos);\n        let found = this.buffer.findIndex(pos, 0, this.bufferStart, this.index + 4, this.endIndex);\n        return found < 0 ? this : new BufferSubtree(this.buffer, this.bufferStart, found, this).resolveAt(pos);\n    }\n    toString() {\n        let result = [];\n        this.buffer.childToString(this.index, result);\n        return result.join(\"\");\n    }\n}\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\nconst BalanceBranchFactor = 8;\nfunction buildTree(data) {\n    let { buffer, group, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = group.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = group.types;\n    function takeNode(parentStart, minPos, children, positions, tagBuffer) {\n        let { id, start, end, size } = cursor, buffer;\n        let startPos = start - parentStart;\n        if (size < 0) { // Reused node\n            children.push(reused[id]);\n            positions.push(startPos);\n            cursor.next();\n            return;\n        }\n        let type = types[id], node;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, group, tagBuffer);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            // Check if this is a repeat wrapper. Store the id of the inner\n            // repeat node in the variable if it is\n            let repeating = id >= group.types.length ? id - (group.types.length - minRepeatType) : -1;\n            if (repeating > -1) {\n                type = types[repeating];\n                while (cursor.pos > endPos) {\n                    let isRepeat = cursor.id == repeating; // This starts with an inner repeated node\n                    takeNode(start, endPos, localChildren, localPositions, isRepeat ? type : NodeType.none);\n                }\n            }\n            else {\n                while (cursor.pos > endPos)\n                    takeNode(start, endPos, localChildren, localPositions, NodeType.none);\n            }\n            localChildren.reverse();\n            localPositions.reverse();\n            if (repeating > -1 && localChildren.length > BalanceBranchFactor)\n                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);\n            else\n                node = new Tree(type, localChildren, localPositions, end - start);\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function findBufferSize(maxSize) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer)\n        // If `type` is > -1, only include siblings with that same type\n        // (used to group repeat content into a buffer)\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size, startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0)\n                    break scan;\n                if (fork.id >= minRepeatType)\n                    localSkipped += 4;\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        return size > 4 ? { size, start, skip } : null;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        let startIndex = index;\n        if (size > 4) {\n            let endPos = cursor.pos - (size - 4);\n            while (cursor.pos > endPos)\n                index = copyToBuffer(bufferStart, buffer, index);\n        }\n        if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(0, 0, children, positions, NodeType.none);\n    let length = children.length ? positions[0] + children[0].length : 0;\n    return new Tree(group.types[topID], children.reverse(), positions.reverse(), length);\n}\nfunction balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {\n    let localChildren = [], localPositions = [];\n    if (length <= maxBufferLength) {\n        for (let i = from; i < to; i++) {\n            localChildren.push(children[i]);\n            localPositions.push(positions[i] - start);\n        }\n    }\n    else {\n        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i];\n            i++;\n            for (; i < to; i++) {\n                let nextEnd = positions[i] + children[i].length;\n                if (nextEnd - groupStart > maxChild)\n                    break;\n            }\n            if (i == groupFrom + 1) {\n                let only = children[groupFrom];\n                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n                    for (let j = 0; j < only.children.length; j++) {\n                        localChildren.push(only.children[j]);\n                        localPositions.push(only.positions[j] + groupStart - start);\n                    }\n                    continue;\n                }\n                localChildren.push(only);\n            }\n            else if (i == groupFrom + 1) {\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart);\n                if (innerType != NodeType.none && !containsType(inner.children, innerType))\n                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);\n                localChildren.push(inner);\n            }\n            localPositions.push(groupStart - start);\n        }\n    }\n    return new Tree(outerType, localChildren, localPositions, length);\n}\nfunction containsType(nodes, type) {\n    for (let elt of nodes)\n        if (elt.type == type)\n            return true;\n    return false;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import {Stack, Recover} from \"./stack\"\nimport {Action, Specialize, Term, Seq, StateFlag, ParseState} from \"./constants\"\nimport {InputStream, Token, StringStream, Tokenizer, TokenGroup} from \"./token\"\nimport {DefaultBufferLength, Tree, TreeBuffer, NodeGroup, NodeType, NodeProp, NodePropSource} from \"lezer-tree\"\nimport {decodeArray} from \"./decode\"\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG!)\n\n/// Nested grammar values are associated with nesting positions in the\n/// grammar. If they are null, the nested region is simply skipped\n/// over. If they hold a parser object, that parser is used to parse\n/// the region. To implement dynamic behavior, the value may also be a\n/// function which returns a description of the way the region should\n/// be parsed.\nexport type NestedGrammar = null | Parser | ((input: InputStream, stack: Stack) => NestedGrammarSpec)\n\n/// An object indicating how to proceed with a nested parse.\nexport interface NestedGrammarSpec {\n  /// When given, this is used to provide a parser that should be used\n  /// to parse the content.\n  parser?: Parser\n  /// When `parser` is given, this can be used to configure which top\n  /// rule to parse with it.\n  top?: string\n  /// This being true means that the outer grammar should use\n  /// the fallback expression provided for the nesting to parse the\n  /// content.\n  stay?: boolean\n  /// Alternatively, `parseNode` may hold a function which will be made\n  /// responsible for parsing the region.\n  parseNode?: (input: InputStream, start: number) => Tree\n  /// An optional extra type to tag the resulting tree with.\n  wrapType?: number,\n  /// When a `filterEnd` property is present, that should hold a\n  /// function that determines whether a given end token (which matches\n  /// the end token specified in the grammar) should be used (true) or\n  /// ignored (false). This is mostly useful for implementing things\n  /// like XML closing tag matching.\n  filterEnd?: (endToken: string) => boolean\n}\n\nclass CacheCursor {\n  trees: Tree[]\n  start = [0]\n  index = [0]\n  nextStart: number = 0\n\n  constructor(tree: Tree) { this.trees = [tree] }\n\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(pos: number): Tree | TreeBuffer | null {\n    if (pos < this.nextStart) return null\n\n    for (;;) {\n      let last = this.trees.length - 1\n      if (last < 0) { // End of tree\n        this.nextStart = 1e9\n        return null\n      }\n      let top = this.trees[last], index = this.index[last]\n      if (index == top.children.length) {\n        this.trees.pop()\n        this.start.pop()\n        this.index.pop()\n        continue\n      }\n      let next = top.children[index]\n      let start = this.start[last] + top.positions[index]\n      if (start >= pos) return start == pos ? next : null\n      if (next instanceof TreeBuffer) {\n        this.index[last]++\n        this.nextStart = start + next.length\n      } else {\n        this.index[last]++\n        if (start + next.length >= pos) { // Enter this node\n          this.trees.push(next)\n          this.start.push(start)\n          this.index.push(0)\n        }\n      }\n    }\n  }\n}\n\nclass CachedToken extends Token {\n  extended = -1\n  mask = 0\n\n  clear(start: number) {\n    this.start = start\n    this.value = this.extended = -1\n  }\n}\n\nconst dummyToken = new Token\n\nclass TokenCache {\n  tokens: CachedToken[] = []\n  mainToken: Token = dummyToken\n\n  actions: number[] = []\n\n  constructor(parser: Parser) {\n    this.tokens = parser.tokenizers.map(_ => new CachedToken)\n  }\n\n  getActions(stack: Stack, input: InputStream) {\n    let actionIndex = 0\n    let main: Token | null = null\n    let {parser} = stack.cx, {tokenizers} = parser\n\n    let mask = parser.stateSlot(stack.state, ParseState.TokenizerMask)\n    for (let i = 0; i < tokenizers.length; i++) {\n      if (((1 << i) & mask) == 0) continue\n      let tokenizer = tokenizers[i], token = this.tokens[i]\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {\n        this.updateCachedToken(token, tokenizer, stack, input)\n        token.mask = mask\n      }\n\n      let startIndex = actionIndex\n      if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex)\n      actionIndex = this.addActions(stack, token.value, token.end, actionIndex)\n      if (actionIndex > startIndex) {\n        main = token\n        break\n      }\n      if (!main || token.value != Term.Err) main = token\n    }\n\n    while (this.actions.length > actionIndex) this.actions.pop()\n    if (!main) {\n      main = dummyToken\n      main.start = stack.pos\n      if (stack.pos == input.length) main.accept(stack.cx.parser.eofTerm, stack.pos)\n      else main.accept(Term.Err, stack.pos + 1)\n    }\n    this.mainToken = main\n    return this.actions\n  }\n\n  updateCachedToken(token: CachedToken, tokenizer: Tokenizer, stack: Stack, input: InputStream) {\n    token.clear(stack.pos)\n    tokenizer.token(input, token, stack)\n    if (token.value > -1) {\n      let {parser} = stack.cx\n      let specIndex = findOffset(parser.data, parser.specializeTable, token.value)\n      if (specIndex >= 0) {\n        let found = parser.specializations[specIndex][input.read(token.start, token.end)]\n        if (found != null) {\n          if ((found & 1) == Specialize.Specialize) token.value = found >> 1\n          else token.extended = found >> 1\n        }\n      }\n    } else if (stack.pos == input.length) {\n      token.accept(stack.cx.parser.eofTerm, stack.pos)\n    } else {\n      token.accept(Term.Err, stack.pos + 1)\n    }\n  }\n\n  putAction(action: number, token: number, end: number, index: number) {\n    // Don't add duplicate actions\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index\n    this.actions[index++] = action\n    this.actions[index++] = token\n    this.actions[index++] = end\n    return index\n  }\n\n  addActions(stack: Stack, token: number, end: number, index: number) {\n    let {state} = stack, {parser} = stack.cx, {data} = parser\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? ParseState.Skip : ParseState.Actions), next; (next = data[i]) != Seq.End; i += 3) {\n        if (next == token || (next == Term.Err && index == 0))\n          index = this.putAction(data[i + 1] | (data[i + 2] << 16), token, end, index)\n      }\n    }\n    return index\n  }\n}\n\n/// Options that can be passed to control parsing.\nexport interface ParseOptions {\n  /// Passing a cached tree is used for incremental parsing. This\n  /// should be a tree whose content is aligned with the current\n  /// document (though a call to `Tree.unchanged`) if any changes were\n  /// made since it was produced. The parser will try to reuse nodes\n  /// from this tree in the new parse, greatly speeding up the parse\n  /// when it can reuse nodes for most of the document.\n  cache?: Tree\n  /// When true, the parser will raise an exception, rather than run\n  /// its error-recovery strategies, when the input doesn't match the\n  /// grammar.\n  strict?: boolean,\n  /// The maximum length of the TreeBuffers generated in the output\n  /// tree. Defaults to 1024.\n  bufferLength?: number,\n  /// The name of the @top declaration to parse from. If not\n  /// specified, the first @top declaration is used.\n  top?: string\n}\n\nexport class StackContext {\n  reused: (Tree | TreeBuffer)[] = []\n  tokens: TokenCache\n  constructor(\n    readonly parser: Parser,\n    readonly maxBufferLength: number,\n    readonly input: InputStream,\n    readonly topTerm: number,\n    readonly parent: Stack | null = null,\n    public wrapType: number = -1 // Set to -2 when a stack descending from this nesting event finishes\n  ) {\n    this.tokens = new TokenCache(parser)\n  }\n}\n\nconst recoverDist = 5, maxRemainingPerStep = 3, minBufferLengthPrune = 200, forceReduceLimit = 10\n\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nexport class ParseContext {\n  // Active parse stacks.\n  private stacks: Stack[]\n  // The position to which the parse has advanced.\n  public pos = 0\n  private recovering = 0\n  private tokenCount = 0\n  private cache: CacheCursor | null\n  private strict: boolean\n\n  /// @internal\n  constructor(parser: Parser,\n              input: InputStream,\n              {cache = undefined, strict = false, bufferLength = DefaultBufferLength, top = undefined}: ParseOptions = {}) {\n    let topInfo = top ? parser.topRules[top] : parser.defaultTop\n    if (!topInfo) throw new RangeError(`Invalid top rule name ${top}`)\n    this.stacks = [Stack.start(new StackContext(parser, bufferLength, input, topInfo[1]), topInfo[0])]\n    this.strict = strict\n    this.cache = cache ? new CacheCursor(cache) : null\n  }\n\n  /// @internal\n  putStack(stack: Stack) {\n    this.stacks.push(stack)\n    if (this.pos < 0 || stack.pos < this.pos) this.pos = stack.pos\n  }\n\n  /// Move the parser forward. This will process all parse stacks at\n  /// `this.pos` and try to advance them to a further position. If no\n  /// stack for such a position is found, it'll start error-recovery.\n  ///\n  /// When the parse is finished, this will return a syntax tree. When\n  /// not, it returns `null`.\n  advance() {\n    let stacks = this.stacks, pos = this.pos\n    // This will now hold stacks beyond `pos`.\n    this.stacks = []\n    // Will be reset to the next position by `putStack`.\n    this.pos = -1\n    let stopped: Stack[] | null = null, stoppedTokens: number[] | null = null\n\n    // Keep advancing any stacks at `pos` until they either move\n    // forward or can't be advanced. Gather stacks that can't be\n    // advanced further in `stopped`.\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i]\n      for (;;) {\n        if (stack.pos > pos) {\n          this.putStack(stack)\n        } else {\n          let result = this.advanceStack(stack, stacks)\n          if (result) {\n            stack = result\n            continue\n          } else {\n            if (!stopped) { stopped = []; stoppedTokens = [] }\n            stopped.push(stack)\n            let tok = stack.cx.tokens.mainToken\n            stoppedTokens!.push(tok.value, tok.end)\n          }\n        }\n        break\n      }\n    }\n\n    if (!this.stacks.length) {\n      let finished = stopped && findFinished(stopped)\n      if (finished) return finished.toTree()\n\n      if (this.strict) throw new SyntaxError(\"No parse at \" + pos)\n      if (!this.recovering) this.recovering = recoverDist\n    }\n\n    if (this.recovering && stopped) {\n      let finished = this.runRecovery(stopped, stoppedTokens!)\n      if (finished) return finished.forceAll().toTree()\n    }\n\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * maxRemainingPerStep\n      if (this.stacks.length > maxRemaining) {\n        this.stacks.sort((a, b) => a.recovered - b.recovered)\n        this.stacks.length = maxRemaining\n      }\n      if (this.stacks.some(s => s.reducePos > pos)) this.recovering--\n    } else if (this.stacks.length > 1 && this.stacks[0].buffer.length > minBufferLengthPrune) {\n      // Prune stacks that have been running without splitting for a\n      // while, to avoid getting stuck with multiple successful stacks\n      // running endlessly on.\n      let minLen = 1e9, minI = -1\n      for (let i = 0; i < this.stacks.length; i++) {\n        let stack = this.stacks[i]\n        if (stack.buffer.length < minLen) { minLen = stack.buffer.length; minI = i }\n      }\n      if (minLen > minBufferLengthPrune) this.stacks.splice(minI, 1)\n    }\n\n    this.tokenCount++\n    return null\n  }\n\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` is given, stacks split\n  // off by ambiguous operations will be pushed to that, or given to\n  // `putStack` if they move `pos` forward.\n  private advanceStack(stack: Stack, split: null | Stack[]) {\n    let start = stack.pos, {input, parser} = stack.cx\n    let base = verbose ? stack + \" -> \" : \"\"\n\n    if (this.cache) {\n      for (let cached = this.cache.nodeAt(start); cached;) {\n        let match = parser.group.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1\n        if (match > -1) {\n          stack.useNode(cached, match)\n          if (verbose) console.log(base + stack + ` (via reuse of ${parser.getName(cached.type.id)})`)\n          return stack\n        }\n        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break\n        let inner = cached.children[0]\n        if (inner instanceof Tree) cached = inner\n        else break\n      }\n    }\n\n    let nest = parser.startNested(stack.state)\n    maybeNest: if (nest > -1) {\n      let {grammar, end: endToken, placeholder} = parser.nested[nest]\n      let filterEnd = undefined, parseNode = null, nested, top, wrapType = undefined\n      if (typeof grammar == \"function\") {\n        let query = grammar(input, stack)\n        if (query.stay) break maybeNest\n        ;({parseNode, parser: nested, top, filterEnd, wrapType} = query)\n      } else {\n        nested = grammar\n      }\n      let end = this.scanForNestEnd(stack, endToken, filterEnd)\n      let clippedInput = stack.cx.input.clip(end)\n      if (parseNode || !nested) {\n        let node = parseNode ? parseNode(clippedInput, stack.pos) : Tree.empty\n        if (node.length != end - stack.pos) node = new Tree(node.type, node.children, node.positions, end - stack.pos)\n        if (wrapType != null) node = new Tree(parser.group.types[wrapType], [node], [0], node.length)\n        stack.useNode(node, parser.getGoto(stack.state, placeholder, true))\n        return stack\n      } else {\n        let topInfo = top ? nested.topRules[top] : nested.defaultTop\n        let newStack = Stack.start(new StackContext(nested, stack.cx.maxBufferLength, clippedInput, topInfo[1], stack, wrapType),\n                                   topInfo[0], stack.pos)\n        if (verbose) console.log(base + newStack + ` (nested)`)\n        return newStack\n      }\n    }\n\n    let defaultReduce = parser.stateSlot(stack.state, ParseState.DefaultReduce)\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce)\n      if (verbose) console.log(base + stack + ` (via always-reduce ${parser.getName(defaultReduce & Action.ValueMask)})`)\n      return stack\n    }\n\n    let actions = stack.cx.tokens.getActions(stack, input)\n    for (let i = 0; i < actions.length;) {\n      let action = actions[i++], term = actions[i++], end = actions[i++]\n      let last = i == actions.length || !split\n      let localStack = last ? stack : stack.split()\n      localStack.apply(action, term, end)\n      if (verbose)\n        console.log(base + localStack + ` (via ${(action & Action.ReduceFlag) == 0 ? \"shift\"\n                     : `reduce of ${parser.getName(action & Action.ValueMask)}`} for ${\n        parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`)\n      if (last) return localStack\n      else if (localStack.pos > start) this.putStack(localStack)\n      else split!.push(localStack)\n    }\n\n    if (stack.cx.parent && stack.pos == input.length) return finishNested(stack)\n    return null\n  }\n\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `putStack`.\n  private advanceFully(stack: Stack) {\n    let pos = stack.pos\n    for (;;) {\n      let result = this.advanceStack(stack, null)\n      if (!result) return stack\n      if (result.pos > pos) {\n        this.putStack(result)\n        return null\n      }\n      stack = result\n    }\n  }\n\n  private runRecovery(stacks: Stack[], tokens: number[]) {\n    let finished: Stack | null = null\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1]\n      let base = verbose ? stack + \" -> \" : \"\"\n\n      let force = stack.split(), forceBase = base\n      for (let j = 0; force.forceReduce() && j < forceReduceLimit; j++) {\n        if (verbose) console.log(forceBase + force + \" (via force-reduce)\")\n        let stopped = this.advanceFully(force)\n        if (!stopped) break\n        force = stopped\n        if (verbose) forceBase = stopped + \" -> \"\n      }\n\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + insert + \" (via recover-insert)\")\n        this.advanceFully(insert)\n      }\n\n      if (stack.cx.input.length > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++\n          token = Term.Err\n        }\n        stack.recoverByDelete(token, tokenEnd)\n        if (verbose) console.log(base + stack + ` (via recover-delete ${stack.cx.parser.getName(token)})`)\n        this.putStack(stack)\n      } else if (!stack.cx.parent && (!finished || finished.recovered > stack.recovered)) {\n        finished = stack\n      }\n    }\n    return finished\n  }\n\n  /// Force the parse to finish, generating a tree containing the nodes\n  /// parsed so far.\n  forceFinish() {\n    return this.stacks[0].split().forceAll().toTree()\n  }\n\n  /// A value that indicates how successful the parse is so far, as\n  /// the number of error-recovery steps taken divided by the number\n  /// of tokens parsed. Could be used to decide to abort a parse when\n  /// the input doesn't appear to match the grammar at all.\n  get badness() {\n    return this.stacks[0].recovered * Recover.Token / this.tokenCount\n  }\n\n  private scanForNestEnd(stack: Stack, endToken: TokenGroup, filter?: ((token: string) => boolean)) {\n    let input = stack.cx.input\n    for (let pos = stack.pos; pos < input.length; pos++) {\n      dummyToken.start = pos\n      dummyToken.value = -1\n      endToken.token(input, dummyToken, stack)\n      if (dummyToken.value > -1 && (!filter || filter(input.read(pos, dummyToken.end)))) return pos\n    }\n    return input.length\n  }\n}\n\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nexport class Parser {\n  /// @internal\n  maxNode: number\n  /// @internal\n  maxRepeatWrap: number\n  private nextStateCache: (readonly number[] | null)[] = []\n\n  /// @internal\n  constructor(\n    /// The parse states for this grammar @internal\n    readonly states: Readonly<Uint32Array>,\n    /// A blob of data that the parse states, as well as some\n    /// of `Parser`'s fields, point into @internal\n    readonly data: Readonly<Uint16Array>,\n    /// The goto table. See `computeGotoTable` in\n    /// lezer-generator for details on the format @internal\n    readonly goto: Readonly<Uint16Array>,\n    /// A node group with the node types used by this parser.\n    readonly group: NodeGroup,\n    /// The first repeat-related term id @internal\n    readonly minRepeatTerm: number,\n    /// The tokenizer objects used by the grammar @internal\n    readonly tokenizers: readonly Tokenizer[],\n    /// Maps top rule names to [state ID, top term ID] pairs.\n    readonly topRules: {[name: string]: [number, number]},\n    /// Metadata about nested grammars used in this grammar @internal\n    readonly nested: readonly {\n      /// A name, used by `withNested`\n      name: string,\n      /// The grammar or grammar query function to use\n      grammar: NestedGrammar,\n      /// A token-recognizing automaton for the end of the nesting\n      end: TokenGroup,\n      /// The id of the placeholder term that appears in the grammar at\n      /// the position of this nesting\n      placeholder: number\n    }[],\n    /// Points into this.data at an array of token types that\n    /// are specialized @internal\n    readonly specializeTable: number,\n    /// For each specialized token type, this holds an object mapping\n    /// names to numbers, with the first bit indicating whether the\n    /// specialization extends or replaces the original token, and the\n    /// rest of the bits holding the specialized token type. @internal\n    readonly specializations: readonly {[value: string]: number}[],\n    /// Points into this.data at an array that holds the\n    /// precedence order (higher precedence first) for ambiguous\n    /// tokens @internal\n    readonly tokenPrecTable: number,\n    /// An optional object mapping term ids to name strings @internal\n    readonly termNames: null | {[id: number]: string} = null\n  ) {\n    this.maxNode = this.group.types.length - 1\n    this.maxRepeatWrap = this.group.types.length + (this.group.types.length - minRepeatTerm) - 1\n    for (let i = 0, l = this.states.length / ParseState.Size; i < l; i++) this.nextStateCache[i] = null\n  }\n\n  /// Parse a given string or stream.\n  parse(input: InputStream | string, options?: ParseOptions) {\n    if (typeof input == \"string\") input = new StringStream(input)\n    let cx = new ParseContext(this, input, options)\n    for (;;) {\n      let done = cx.advance()\n      if (done) return done\n    }\n  }\n\n  /// Create a `ParseContext`.\n  startParse(input: InputStream | string, options?: ParseOptions) {\n    if (typeof input == \"string\") input = new StringStream(input)\n    return new ParseContext(this, input, options)\n  }\n\n  /// Get a goto table entry @internal\n  getGoto(state: number, term: number, loose = false) {\n    let table = this.goto\n    if (term >= table[0]) return -1\n    for (let pos = table[term + 1];;) {\n      let groupTag = table[pos++], last = groupTag & 1\n      let target = table[pos++]\n      if (last && loose) return target\n      for (let end = pos + (groupTag >> 1); pos < end; pos++)\n        if (table[pos] == state) return target\n      if (last) return -1\n    }\n  }\n\n  /// Check if this state has an action for a given terminal @internal\n  hasAction(state: number, terminal: number) {\n    let data = this.data\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? ParseState.Skip : ParseState.Actions), next; (next = data[i]) != Seq.End; i += 3) {\n        if (next == terminal || next == Term.Err)\n          return data[i + 1] | (data[i + 2] << 16)\n      }\n    }\n    return 0\n  }\n\n  /// @internal\n  stateSlot(state: number, slot: number) {\n    return this.states[(state * ParseState.Size) + slot]\n  }\n\n  /// @internal\n  stateFlag(state: number, flag: number) {\n    return (this.stateSlot(state, ParseState.Flags) & flag) > 0\n  }\n\n  /// @internal\n  startNested(state: number) {\n    let flags = this.stateSlot(state, ParseState.Flags)\n    return flags & StateFlag.StartNest ? flags >> StateFlag.NestShift : -1\n  }\n\n  /// @internal\n  validAction(state: number, action: number) {\n    if (action == this.stateSlot(state, ParseState.DefaultReduce)) return true\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) return false\n      if (action == (this.data[i + 1] | (this.data[i + 2] << 16))) return true\n    }\n  }\n\n  /// Get the states that can follow this one through shift actions or\n  /// goto jumps. @internal\n  nextStates(state: number): readonly number[] {\n    let cached = this.nextStateCache[state]\n    if (cached) return cached\n    let result: number[] = []\n    for (let i = this.stateSlot(state, ParseState.Actions); this.data[i] != Seq.End; i += 3) {\n      if ((this.data[i + 2] & (Action.ReduceFlag >> 16)) == 0 && !result.includes(this.data[i + 1]))\n        result.push(this.data[i + 1])\n    }\n    let table = this.goto, max = table[0]\n    for (let term = 0; term < max; term++) {\n      for (let pos = table[term + 1];;) {\n        let groupTag = table[pos++], target = table[pos++]\n        for (let end = pos + (groupTag >> 1); pos < end; pos++)\n          if (table[pos] == state && !result.includes(target)) result.push(target)\n        if (groupTag & 1) break\n      }\n    }\n    return this.nextStateCache[state] = result\n  }\n\n  /// @internal\n  overrides(token: number, prev: number) {\n    let iPrev = findOffset(this.data, this.tokenPrecTable, prev)\n    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev\n  }\n\n  /// Create a new `Parser` instance with different values for (some\n  /// of) the nested grammars. This can be used to, for example, swap\n  /// in a different language for a nested grammar or fill in a nested\n  /// grammar that was left blank by the original grammar.\n  withNested(spec: {[name: string]: NestedGrammar | null}) {\n    return new Parser(this.states, this.data, this.goto, this.group, this.minRepeatTerm, this.tokenizers, this.topRules,\n                      this.nested.map(obj => {\n                        if (!Object.prototype.hasOwnProperty.call(spec, obj.name)) return obj\n                        return {name: obj.name, grammar: spec[obj.name], end: obj.end, placeholder: obj.placeholder}\n                      }),\n                      this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames)\n  }\n\n  /// Create a new `Parser` instance whose node types have the given\n  /// props added. You should use [`NodeProp.add`](#tree.NodeProp.add)\n  /// to create the arguments to this method.\n  withProps(...props: NodePropSource[]) {\n    return new Parser(this.states, this.data, this.goto, this.group.extend(...props), this.minRepeatTerm,\n                      this.tokenizers, this.topRules, this.nested,\n                      this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames)\n  }\n\n  /// Returns the name associated with a given term. This will only\n  /// work for all terms when the parser was generated with the\n  /// `--names` option. By default, only the names of tagged terms are\n  /// stored.\n  getName(term: number): string {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.group.types[term].name || term)\n  }\n\n  /// The eof term id is always allocated directly after the node\n  /// types. @internal\n  get eofTerm() { return this.maxRepeatWrap + 1 }\n\n  /// Tells you whether this grammar has any nested grammars.\n  get hasNested() { return this.nested.length > 0 }\n\n  /// @internal\n  get defaultTop() { return this.topRules[Object.keys(this.topRules)[0]] }\n\n  /// The node type produced by the default top rule.\n  get topType() { return this.group.types[this.defaultTop[1]] }\n\n  /// (Used by the output of the parser generator) @internal\n  static deserialize(spec: {\n    states: string,\n    stateData: string,\n    goto: string,\n    nodeNames: string,\n    repeatNodeCount: number,\n    nodeProps?: [NodeProp<any>, ...(string | number)[]][],\n    tokenData: string,\n    tokenizers: (Tokenizer | number)[],\n    topRules: {[name: string]: [number, number]},\n    nested?: [string, null | NestedGrammar, string, number][],\n    specializeTable: number,\n    specializations?: readonly {[term: string]: number}[],\n    tokenPrec: number,\n    termNames?: {[id: number]: string}\n  }) {\n    let tokenArray = decodeArray(spec.tokenData)\n    let nodeNames = spec.nodeNames.split(\" \"), minRepeatTerm = nodeNames.length\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\")\n    let nodeProps: {[id: number]: any}[] = []\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push(noProps)\n    function setProp(nodeID: number, prop: NodeProp<any>, value: string) {\n      if (nodeProps[nodeID] == noProps) nodeProps[nodeID] = Object.create(null)\n      prop.set(nodeProps[nodeID], prop.deserialize(value))\n    }\n    setProp(0, NodeProp.error, \"\")\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0]\n      for (let i = 1; i < propSpec.length; i += 2)\n        setProp(propSpec[i] as number, prop, propSpec[i + 1] as string)\n    }\n    let group = new NodeGroup(nodeNames.map((name, i) => new NodeType(name, nodeProps[i], i)))\n\n    return new Parser(decodeArray(spec.states, Uint32Array), decodeArray(spec.stateData),\n                      decodeArray(spec.goto), group, minRepeatTerm,\n                      spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value),\n                      spec.topRules,\n                      (spec.nested || []).map(([name, grammar, endToken, placeholder]) =>\n                                              ({name, grammar, end: new TokenGroup(decodeArray(endToken), 0), placeholder})),\n                      spec.specializeTable, (spec.specializations || []).map(withoutPrototype),\n                      spec.tokenPrec, spec.termNames)\n  }\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\nfunction findOffset(data: Readonly<Uint16Array>, start: number, term: number) {\n  for (let i = start, next; (next = data[i]) != Seq.End; i++)\n    if (next == term) return i - start\n  return -1\n}\n\n// Strip the prototypes from objects, so that they can safely be\n// accessed as maps.\nfunction withoutPrototype(obj: {}) {\n  if (!(obj instanceof Object)) return obj\n  let result: {[key: string]: any} = Object.create(null)\n  for (let prop in obj) if (Object.prototype.hasOwnProperty.call(obj, prop)) result[prop] = (obj as any)[prop]\n  return result\n}\n\nfunction findFinished(stacks: Stack[]) {\n  let best: Stack | null = null\n  for (let stack of stacks) {\n    if (stack.pos == stack.cx.input.length &&\n        stack.cx.parser.stateFlag(stack.state, StateFlag.Accepting) &&\n        (!best || best.recovered > stack.recovered))\n      best = stack\n  }\n  return best\n}\n\nfunction finishNested(stack: Stack) {\n  if (stack.cx.wrapType == -2) return null // Another nested stack already finished\n  let parent = stack.cx.parent!, tree = stack.forceAll().toTree()\n  let parentParser = parent.cx.parser, info = parentParser.nested[parentParser.startNested(parent.state)]\n  tree = new Tree(tree.type, tree.children, tree.positions.map(p => p - parent!.pos), stack.pos - parent.pos)\n  if (stack.cx.wrapType > -1) tree = new Tree(parentParser.group.types[stack.cx.wrapType], [tree], [0], tree.length)\n  stack.cx.wrapType = -2\n  parent.useNode(tree, parentParser.getGoto(parent.state, info.placeholder, true))\n  if (verbose) console.log(parent + ` (via unnest ${stack.cx.wrapType > -1 ? parentParser.getName(stack.cx.wrapType) : tree.type.name})`)\n  return parent\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {Action, Term, StateFlag, ParseState} from \"./constants\"\nimport {StackContext} from \"./parse\"\nimport {Tree, TreeBuffer, BufferCursor} from \"lezer-tree\"\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nexport class Stack {\n  /// @internal\n  constructor(\n    // A group of values that the stack will share with all\n    // split instances\n    ///@internal\n    readonly cx: StackContext,\n    // Holds state, pos, value stack pos (15 bits array index, 15 bits\n    // buffer index) triplets for all but the top state\n    /// @internal\n    readonly stack: number[],\n    // The current parse state\n    /// @internal\n    public state: number,\n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    public reducePos: number,\n    // The input position up to which this stack has parsed.\n    public pos: number,\n    // The amount of error-recovery that happened on this stack\n    /// @internal\n    public recovered: number,\n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    readonly buffer: number[],\n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    readonly bufferBase: number,\n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    readonly parent: Stack | null\n  ) {}\n\n  /// @internal\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.recovered ? \"!\" + this.recovered : \"\"}`\n  }\n\n  // Start an empty stack\n  /// @internal\n  static start(cx: StackContext, state: number, pos = 0) {\n    return new Stack(cx, [], state, pos, pos, 0, [], 0, null)\n  }\n\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /// @internal\n  pushState(state: number, start: number) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length)\n    this.state = state\n  }\n\n  // Apply a reduce action\n  /// @internal\n  reduce(action: number) {\n    let depth = action >> Action.ReduceDepthShift, type = action & Action.ValueMask\n    let {parser} = this.cx\n    if (depth == 0) {\n      // Zero-depth reductions are a special casethey add stuff to\n      // the stack without popping anything off.\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true)\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos)\n      return\n    }\n\n    // Find the base index into `this.stack`, content after which will\n    // be dropped. Note that with `StayFlag` reductions we need to\n    // consume two extra frames (the dummy parent node for the skipped\n    // expression and the state that we'll be staying in, which should\n    // be moved to `this.state`).\n    let base = this.stack.length - ((depth - 1) * 3) - (action & Action.StayFlag ? 6 : 0)\n    let start = this.stack[base - 2]\n    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase\n    if (type < parser.minRepeatTerm || // Normal term\n        (action & Action.RepeatFlag) || // Inner repeat marker\n        (type > parser.maxNode && type <= parser.maxRepeatWrap)) { // Repeat wrapper\n      let pos = parser.stateFlag(this.state, StateFlag.Skipped) ? this.pos : this.reducePos\n      this.storeNode(type, start, pos, count + 4, true)\n    }\n    if (action & Action.StayFlag) {\n      this.state = this.stack[base]\n    } else {\n      let baseStateID = this.stack[base - 3]\n      this.state = parser.getGoto(baseStateID, type, true)\n    }\n    while (this.stack.length > base) this.stack.pop()\n  }\n\n  // Shift a value into the buffer\n  /// @internal\n  storeNode(term: number, start: number, end: number, size = 4, isReduce = false) {\n    if (term == Term.Err) { // Try to omit/merge adjacent error nodes\n      let cur: Stack | null = this, top = this.buffer.length\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase\n        cur = cur.parent\n      }\n      if (top > 0 && cur.buffer[top - 4] == Term.Err && cur.buffer[top - 1] > -1) {\n        if (start == end) return\n        if (cur.buffer[top - 2] >= start) { cur.buffer[top - 2] = end; return }\n      }\n    }\n\n    if (!isReduce || this.pos == end) { // Simple case, just append\n      this.buffer.push(term, start, end, size)\n    } else { // There may be skipped nodes that have to be moved forward\n      let index = this.buffer.length\n      if (index > 0 && this.buffer[index - 4] != Term.Err) while (index > 0 && this.buffer[index - 2] > end) {\n        // Move this record forward\n        this.buffer[index] = this.buffer[index - 4]\n        this.buffer[index + 1] = this.buffer[index - 3]\n        this.buffer[index + 2] = this.buffer[index - 2]\n        this.buffer[index + 3] = this.buffer[index - 1]\n        index -= 4\n        if (size > 4) size -= 4\n      }\n      this.buffer[index] = term\n      this.buffer[index + 1] = start\n      this.buffer[index + 2] = end\n      this.buffer[index + 3] = size\n    }\n  }\n\n  // Apply a shift action\n  /// @internal\n  shift(action: number, next: number, nextEnd: number) {\n    if (action & Action.GotoFlag) {\n      this.pushState(action & Action.ValueMask, this.pos)\n    } else if ((action & Action.StayFlag) == 0) { // Regular shift\n      let start = this.pos, nextState = action, {parser} = this.cx\n      if (nextEnd > this.pos || next <= parser.maxNode) {\n        this.pos = nextEnd\n        if (!parser.stateFlag(nextState, StateFlag.Skipped)) this.reducePos = nextEnd\n      }\n      this.pushState(nextState, start)\n      if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4)\n    } else { // Shift-and-stay, which means this is a skipped token\n      if (next <= this.cx.parser.maxNode) this.buffer.push(next, this.pos, nextEnd, 4)\n      this.pos = nextEnd\n    }\n  }\n\n  // Apply an action\n  /// @internal\n  apply(action: number, next: number, nextEnd: number) {\n    if (action & Action.ReduceFlag) this.reduce(action)\n    else this.shift(action, next, nextEnd)\n  }\n\n  // Add a prebuilt node into the buffer. This may be a reused node or\n  // the result of running a nested parser.\n  /// @internal\n  useNode(value: Tree | TreeBuffer, next: number) {\n    let index = this.cx.reused.length - 1\n    if (index < 0 || this.cx.reused[index] != value) {\n      this.cx.reused.push(value)\n      index++\n    }\n    let start = this.pos\n    this.reducePos = this.pos = start + value.length\n    this.pushState(next, start)\n    this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */)\n  }\n\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /// @internal\n  split() {\n    let parent: Stack | null = this\n    let off = parent.buffer.length\n    // Because the top of the buffer (after this.pos) may be mutated\n    // to reorder reductions and skipped tokens, and shared buffers\n    // should be immutable, this copies any outstanding skipped tokens\n    // to the new buffer, and puts the base pointer before them.\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4\n    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off\n    // Make sure parent points to an actual parent with content, if there is such a parent.\n    while (parent && base == parent.bufferBase) parent = parent.parent\n    return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos,\n                     this.recovered, buffer, base, parent)\n  }\n\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /// @internal\n  recoverByDelete(next: number, nextEnd: number) {\n    let isNode = next <= this.cx.parser.maxNode\n    if (isNode) this.storeNode(next, this.pos, nextEnd)\n    this.storeNode(Term.Err, this.pos, nextEnd, isNode ? 8 : 4)\n    this.pos = this.reducePos = nextEnd\n    this.recovered += Recover.Token\n  }\n\n  /// Check if the given term would be able to be shifted (optionally\n  /// after some reductions) on this stack. This can be useful for\n  /// external tokenizers that want to make sure they only provide a\n  /// given token when it applies.\n  canShift(term: number) {\n    for (let sim = new SimulatedStack(this);;) {\n      let action = this.cx.parser.stateSlot(sim.top, ParseState.DefaultReduce) || this.cx.parser.hasAction(sim.top, term)\n      if ((action & Action.ReduceFlag) == 0) return true\n      if (action == 0) return false\n      sim.reduce(action)\n    }\n  }\n\n  /// Find the start position of the rule that is currently being parsed.\n  get ruleStart() {\n    let force = this.cx.parser.stateSlot(this.state, ParseState.ForcedReduce)\n    if (!(force & Action.ReduceFlag)) return 0\n    let base = this.stack.length - (3 * (force >> Action.ReduceDepthShift))\n    return this.stack[base + 1]\n  }\n\n  /// Find the start position of the innermost instance of any of the\n  /// given term types, or return `-1` when none of them are found.\n  ///\n  /// **Note:** this is only reliable when there is at least some\n  /// state that unambiguously matches the given rule on the stack.\n  /// I.e. if you have a grammar like this, where the difference\n  /// between `a` and `b` is only apparent at the third token:\n  ///\n  ///     a { b | c }\n  ///     b { \"x\" \"y\" \"x\" }\n  ///     c { \"x\" \"y\" \"z\" }\n  ///\n  /// Then a parse state after `\"x\"` will not reliably tell you that\n  /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n  /// for either of those two rules (assuming that `a` isn't part of\n  /// some rule that includes other things starting with `\"x\"`).\n  startOf(types: readonly number[]) {\n    for (let frame = this.stack.length; frame >= 0; frame -= 3) {\n      let state = frame == this.stack.length ? this.state : this.stack[frame]\n      let force = this.cx.parser.stateSlot(state, ParseState.ForcedReduce)\n      if (types.includes(force & Action.ValueMask)) {\n        let base = frame - (3 * (force >> Action.ReduceDepthShift))\n        return this.stack[base + 1]\n      }\n    }\n    return -1\n  }\n\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /// @internal\n  recoverByInsert(next: number): Stack[] {\n    let nextStates = this.cx.parser.nextStates(this.state)\n    if (nextStates.length > Recover.MaxNext) {\n      let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next))\n      for (let i = 0; best.length < Recover.MaxNext && i < nextStates.length; i++)\n        if (!best.includes(nextStates[i])) best.push(nextStates[i])\n      nextStates = best\n    }\n    let result: Stack[] = []\n    for (let i = 0; i < nextStates.length && result.length < Recover.MaxNext; i++) {\n      if (nextStates[i] == this.state) continue\n      let stack = this.split()\n      stack.storeNode(Term.Err, stack.pos, stack.pos, 4, true)\n      stack.pushState(nextStates[i], this.pos)\n      stack.recovered += Recover.Token\n      result.push(stack)\n    }\n    return result\n  }\n\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /// @internal\n  forceReduce() {\n    let reduce = this.cx.parser.stateSlot(this.state, ParseState.ForcedReduce)\n    if ((reduce & Action.ReduceFlag) == 0) return false\n    if (!this.cx.parser.validAction(this.state, reduce)) {\n      this.storeNode(Term.Err, this.reducePos, this.reducePos, 4, true)\n      this.recovered += Recover.Reduce\n    }\n    this.reduce(reduce)\n    return true\n  }\n\n  /// @internal\n  forceAll() {\n    while (!this.cx.parser.stateFlag(this.state, StateFlag.Accepting) && this.forceReduce()) {}\n    return this\n  }\n\n  // Convert the stack's buffer to a syntax tree.\n  /// @internal\n  toTree(): Tree {\n    return Tree.build({buffer: StackBufferCursor.create(this),\n                       group: this.cx.parser.group,\n                       topID: this.cx.topTerm,\n                       maxBufferLength: this.cx.maxBufferLength,\n                       reused: this.cx.reused,\n                       minRepeatType: this.cx.parser.minRepeatTerm})\n  }\n}\n\nexport const enum Recover {\n  Token = 2,\n  Reduce = 1,\n  MaxNext = 4\n}\n\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n  top: number\n  rest: number[]\n  offset: number\n\n  constructor(readonly stack: Stack) {\n    this.top = stack.state\n    this.rest = stack.stack\n    this.offset = this.rest.length\n  }\n\n  reduce(action: number) {\n    let term = action & Action.ValueMask, depth = action >> Action.ReduceDepthShift\n    if (depth == 0) {\n      if (this.rest == this.stack.stack) this.rest = this.rest.slice()\n      this.rest.push(this.top, 0, 0)\n      this.offset += 3\n    } else {\n      this.offset -= (depth - 1) * 3\n    }\n    let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true)\n    this.top = goto\n  }\n}\n\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor implements BufferCursor {\n  buffer: number[]\n\n  constructor(public stack: Stack, public pos: number, public index: number) {\n    this.buffer = stack.buffer\n    if (this.index == 0) this.maybeNext()\n  }\n\n  static create(stack: Stack) {\n    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length)\n  }\n\n  maybeNext() {\n    let next = this.stack.parent\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase\n      this.stack = next\n      this.buffer = next.buffer\n    }\n  }\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  next() {\n    this.index -= 4\n    this.pos -= 4\n    if (this.index == 0) this.maybeNext()\n  }\n\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index)\n  }\n}\n","import {Stack} from \"./stack\"\n\n/// Tokenizers write the tokens they read into instances of this class.\nexport class Token {\n  /// The start of the token. This is set by the parser, and should not\n  /// be mutated by the tokenizer.\n  start = -1\n  /// This starts at -1, and should be updated to a term id when a\n  /// matching token is found.\n  value = -1\n  /// When setting `.value`, you should also set `.end` to the end\n  /// position of the token. (You'll usually want to use the `accept`\n  /// method.)\n  end = -1\n\n  /// Accept a token, setting `value` and `end` to the given values.\n  accept(value: number, end: number) {\n    this.value = value\n    this.end = end\n  }\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code points. Most access will be\n/// sequential, so implementations can optimize for that.\nexport interface InputStream {\n  /// The end of the stream.\n  length: number\n  /// Get the code point at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream\n  get(pos: number): number\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `InputStream` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): InputStream\n}\n\n/// An `InputStream` that is backed by a single, flat string.\nexport class StringStream implements InputStream {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringStream(this.string, at) }\n}\n\nexport interface Tokenizer {\n  token(input: InputStream, token: Token, stack: Stack): void\n  contextual: boolean\n}\n\n/// @internal\nexport class TokenGroup implements Tokenizer {\n  contextual!: boolean\n\n  constructor(readonly data: Readonly<Uint16Array>, readonly id: number) {}\n\n  token(input: InputStream, token: Token, stack: Stack) { readToken(this.data, input, token, stack, this.id) }\n}\n\nTokenGroup.prototype.contextual = false\n\nexport class ExternalTokenizer {\n  contextual: boolean\n\n  constructor(readonly token: (input: InputStream, token: Token, stack: Stack) => void,\n              options: {contextual?: boolean} = {}) {\n    this.contextual = options && options.contextual || false\n  }\n}\n\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data: Readonly<Uint16Array>,\n                   input: InputStream,\n                   token: Token,\n                   stack: Stack,\n                   group: number) {\n  let state = 0, groupMask = 1 << group\n  scan: for (let pos = token.start;;) {\n    if ((groupMask & data[state]) == 0) break\n    let accEnd = data[state + 1]\n    // Check whether this state can lead to a token in the current group\n    // Accept tokens in this state, possibly overwriting\n    // lower-precedence / shorter tokens\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i]\n      if (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value)) {\n        token.accept(term, pos)\n        break\n      }\n    }\n    let next = input.get(pos++)\n    // Do a binary search on the state's edges\n    for (let low = 0, high = data[state + 2]; low < high;) {\n      let mid = (low + high) >> 1\n      let index = accEnd + mid + (mid << 1)\n      let from = data[index], to = data[index + 1]\n      if (next < from) high = mid\n      else if (next >= to) low = mid + 1\n      else { state = data[index + 2]; continue scan }\n    }\n    break\n  }\n}\n","// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\n\nimport {Encode} from \"./constants\"\n\nexport function decodeArray<T extends {[i: number]: number} = Uint16Array>(input: string, Type: {new (n: number): T} = Uint16Array as any): T {\n  let array: T | null = null\n  for (let pos = 0, out = 0; pos < input.length;) {\n    let value = 0\n    for (;;) {\n      let next = input.charCodeAt(pos++), stop = false\n      if (next == Encode.BigValCode) { value = Encode.BigVal; break }\n      if (next >= Encode.Gap2) next--\n      if (next >= Encode.Gap1) next--\n      let digit = next - Encode.Start\n      if (digit >= Encode.Base) { digit -= Encode.Base; stop = true }\n      value += digit\n      if (stop) break\n      value *= Encode.Base\n    }\n    if (array) array[out++] = value\n    else array = new Type(value)\n  }\n  return array!\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar lezer = require('lezer');\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = lezer.Parser.deserialize({\n  states: \"$bOSOPOOOROP'#Cb'#CbOjOPO'#CcOqOPO'#CfOROP'#Cn'#CnQROPOOOROP'#Ce'#CeO![OPO'#CdOROP,58},58}O!`OPO,58}OROP,59Q,59QO!gOPO,59QOSOPO,59OO!nOPO'#CiO!uOPO'#CgO!yOPO1G.iO!}OPO'#CjOSOPO'#ChO#UOPO1G.lOROP1G.j1G.jOROP,59R,59ROROP-E6e-E6eOROP7+$T7+$TOROP,59S,59SOROP-E6f-E6fOROP7+$W7+$W\",\n  stateData: \"#YaOS~QSORSOSSOTSOcPOdQOhRO~cUOgWO~QSORSOSSOTSOcPOdQOhROiYO~e[O~f^Og]P~faOi^P~f^Og]X~cUO~gfO~faOi^X~iiO~\",\n  goto: \"!dcPPPPPPddjpdtz!Q!TPPP!WXSOR[aQXQRe^TVQ^Q]XRd]Q`ZRg`R_XRbZQTOQZRQc[Rha\",\n  nodeNames: \" JsonText True False Null Number String Object Property PropertyName Array\",\n  nodeProps: [\n    [lezer.NodeProp.delim, 7,\"{ }\",10,\"[ ]\"]\n  ],\n  repeatNodeCount: 2,\n  tokenData: \"(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oa~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOc~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOf~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOe~~&rOh~~&wOi~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOd~~(pOg~\",\n  tokenizers: [0],\n  topRules: {\"JsonText\":[0,1]},\n  specializeTable: 3,\n  tokenPrec: 3\n});\n\nexports.parser = parser;\n","import {EditorView} from \"@codemirror/next/view\"\nimport {EditorState} from \"@codemirror/next/state\"\nimport {defaultHighlighter} from \"@codemirror/next/highlight\"\nimport {lineNumbers} from \"@codemirror/next/gutter\"\nimport {keymap} from \"@codemirror/next/keymap\"\nimport {baseKeymap} from \"@codemirror/next/commands\"\nimport {bracketMatching} from \"@codemirror/next/matchbrackets\"\nimport {closeBrackets} from \"@codemirror/next/closebrackets\"\nimport {specialChars} from \"@codemirror/next/special-chars\"\nimport {foldGutter} from \"@codemirror/next/fold\"\n\nlet json = String.raw`{\n  \"literals\": [true, false, null],\n  \"numbers\": [1, 123, 123.5, -123, 43e5, 23e-5, 23e+5],\n  \"strings\": [\n    \"A simple string\",\n    \"Escapes: \\n\\b\\r\\t\",\n    \"Unicode: \\u005c\"\n  ],\n  {\n    \"let us\": {\n      \"nest\": [\"some\", \"things\"]\n    }\n  }\n}`\n\nimport {parser} from \"./dist/index\"\nimport {Subtree} from  \"lezer-tree\"\nimport {LezerSyntax, foldNodeProp} from \"@codemirror/next/syntax\"\nimport {styleTags} from \"@codemirror/next/highlight\"\n\nlet jsonSyntax = new LezerSyntax(parser.withProps(\n  foldNodeProp.add({\n    Array(tree) { return {from: tree.start + 1, to: tree.end - 1} },\n    Object(tree) { return {from: tree.start + 1, to: tree.end - 1} }\n  }),\n  styleTags({\n    Number: 'number',\n    String: 'string',\n    'True False': 'atom',\n    Null: 'null',\n    PropertyName: 'propertyName'\n  })\n))\n\nlet view = new EditorView({state: EditorState.create({\n  doc: json,\n  extensions: [\n    lineNumbers(),\n    defaultHighlighter,\n    keymap(baseKeymap),\n    specialChars(),\n    closeBrackets,\n    bracketMatching(),\n    foldGutter(),\n    jsonSyntax\n  ]\n})})\n\ndocument.body.appendChild(view.dom)\n"]}